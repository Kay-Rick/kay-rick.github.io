<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="Stay Foolish">
<meta name="theme-color" content="#adb5bd">
<title>Rick</title>
<link rel="shortcut icon" href="/favicon.ico?v=1684417673813">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Rick</span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> Index
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> Archives
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> Tags
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> About
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Rick</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">25</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">29</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          LeetCode
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://kay-rick.github.io/post/leetcode-zhuan-ji-3-lian-biao/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              12-13
              <small>【LeetCode专辑 - 3】链表</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://kay-rick.github.io/post/leetcode-zhuan-ji-2-shuang-zhi-zhen-suan-fa/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              12-06
              <small>【LeetCode专辑 - 2】双指针算法</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://kay-rick.github.io/post/zai-tan-shuang-zhi-zhen-suan-fa/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              11-30
              <small>再谈双指针算法</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://kay-rick.github.io/post/leetcode-zhuan-ji-1-er-fen-cha-zhao/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              11-29
              <small>【LeetCode专辑 - 1】二分查找</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="/media/images/custom-bgImg.png" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/she-ji-mo-shi-gong-han-fang-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Factory Method：再工厂方法设计模式中：父类决定实例的生成方式，但不决定所要生成的具体的类，具体的处理让子类负责&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/br&gt;
&lt;h2 id=&#34;uml&#34;&gt;UML&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210210145007493.png&#34; alt=&#34;image-20210210145007493&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建者&lt;code&gt;Factory&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负责具体生成&lt;code&gt;Product&lt;/code&gt;角色的抽象类，&lt;code&gt;Factory&lt;/code&gt;角色对于实际负责生成实例的&lt;code&gt;ConcreteFactorty&lt;/code&gt;角色一无所知，它唯一知道的是&lt;strong&gt;要调用&lt;code&gt;Product&lt;/code&gt;角色和生成实例的方法（&lt;code&gt;factoryMethod&lt;/code&gt;）就可以生成&lt;code&gt;Product&lt;/code&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;产品&lt;code&gt;Product&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
是一个抽象类，它定义了在Factory Method模式中生成哪些实例所持有的接口（API），具体处理由子类&lt;code&gt;ConcreteProduct&lt;/code&gt;决定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;具体的产品&lt;code&gt;ConcreteProduct&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;角色属于加工这一方，他决定了具体的产品&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;具体的创建者&lt;code&gt;ConcreteFactory&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcreteFactory&lt;/code&gt;角色属于加工这一方，它负责生成具体的产品&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h2 id=&#34;sample&#34;&gt;Sample&lt;/h2&gt;
&lt;/br&gt;
&lt;p&gt;我们以生成身份ID卡为例，一共有四个类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210210152516916.png&#34; alt=&#34;image-20210210152516916&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;factory&#34;&gt;Factory&lt;/h3&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Factory {
    
    /**
     * 使用了一系列抽象工厂方法来创建产品，方法实现由具体的工厂来完成
     */
    public final Product create(String owner) {
        Product product = createProduct(owner);
        registerProduct(product);
        return product;
    }
    
    /**
     * 制造产品
     * @param owner
     * @return
     */
    protected abstract Product createProduct(String owner);

    /**
     * 注册产品
     * @param product
     * @return
     */
    protected abstract void registerProduct(Product product);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;product&#34;&gt;Product&lt;/h3&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Product {
    public abstract void use();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;concretefactory&#34;&gt;ConcreteFactory&lt;/h3&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IDCardFactory extends Factory {

    private List&amp;lt;String&amp;gt; owners = new ArrayList&amp;lt;&amp;gt;();
    
    @Override
    protected Product createProduct(String owner) {
        return new IDCard(owner);
    }

    @Override
    protected void registerProduct(Product product) {
        owners.add(((IDCard)product).getOwner());
    }
    
    public List&amp;lt;String&amp;gt; getOwners() {
        return owners;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;concreteproduct&#34;&gt;ConcreteProduct&lt;/h3&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IDCard extends Product {

    private String owner;

    public IDCard(String owner) {
        System.out.println(&amp;quot;制作&amp;quot; + owner + &amp;quot;的ID卡&amp;quot;);
        this.owner = owner;
    }
    
    @Override
    public void use() {
        System.out.println(&amp;quot;使用&amp;quot; + owner + &amp;quot;的ID卡&amp;quot;);
    }
    
    public String getOwner() {
        return owner;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;test&#34;&gt;Test&lt;/h3&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        Factory factory = new IDCardFactory();
        Product card1 = factory.create(&amp;quot;Rick&amp;quot;);
        Product card2 = factory.create(&amp;quot;Kay&amp;quot;);
        card1.use();
        card2.use();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;system-suitability&#34;&gt;System Suitability&lt;/h2&gt;
&lt;/br&gt;
&lt;p&gt;工厂方法非常适用以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个类不知道它所必须创建的对象的类的时候&lt;/li&gt;
&lt;li&gt;当一个类希望由它的子类来指定它所创建的对象的时候&lt;/li&gt;
&lt;li&gt;当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望帮助子类是代理者这一信息局部化的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际业务开发中可以对业务进行优化：&lt;strong&gt;避免创建者与具体的产品逻辑耦合，满足单一职责、每一个业务逻辑实现都在所属自己的类中完成，满足开闭原则，无需更改使用调用方法就可以在程序中引入新的产品类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来看一个具体的业务场景：在互联网营销场景下我们经常会给客户返利积分，最后通过积分在兑换商品，那么我们模拟积分兑换中的发放多种类型的商品，假设我们由下面两种类型的商品接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优惠券：CardService中&lt;code&gt;CouponResult sendCoupon(String uId, String couponNumber, String uuid)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实物商品：GoodsService中&lt;code&gt;Boolean deliverGoods(DeliverReq req)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们发现：接口&lt;strong&gt;返回类型不同，入参不同，另外可能会随着后续的业务的发展，会新增其他种商品类型&lt;/strong&gt;。如果我们不考虑任何扩展性，那么对这几种奖励发放只需使用if-else语句判断，调用不同接口即可满足需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是在经过多次迭代和拓展之后，代码的维护和重构成本将变得非常高，测试回归验证时间长&lt;/strong&gt;。这种场景我们考虑使用工厂方法对代码进行进一步优化&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210210212315933.png&#34; alt=&#34;image-20210210212315933&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StoreFactory&lt;/code&gt;：定义一个工厂类，在工厂类里面按照类型实现各种商品的服务：当id是1时表示是优惠劵发放，id是2时表示是实物商品发放&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StoreFactory {

    public StoreInterface getService(Integer id) {
        if (null == id)
            return null;
        if (1 == id)
            return new CardService();
        if (2 == id)
            return new GoodsService();
        throw new RuntimeException(&amp;quot;不存在商品服务信息&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StoreInterface&lt;/code&gt;：统一发奖接口，所有奖品无论是实物、虚拟还是第三方，都需要我们的程序实现此接口进行处理，以保证最终入参出参的统一性。&lt;strong&gt;接口入参包括：用户ID、奖品ID、业务ID以及扩展字段用于处理发放实物商品时的收货地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface StoreInterface {
    
    void sendGift(String uid, String giftId, String bizId, Map&amp;lt;String, String&amp;gt; extmap) throws Exception;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CardCommonService&lt;/code&gt;和&lt;code&gt;GoodsCommonService&lt;/code&gt;实现奖品发放接口：实现接口中的方法，在&lt;strong&gt;方法中调用原有接口的方法，并对出参和入参进行封装适配现在的接口（代码中没有展现具体CardService和GoodsService）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在统一了入参及出参后，调用方不在需要关心奖品发放的内部逻辑，按照统一的方式处理即可&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GoodsCommonService implements StoreInterface {
    
	private Logger logger = LoggerFactory.getLogger(this.getClass());
    
    // 模拟注入
    private GoodsService goodsService = new GoodsService();
    
    @Override
    public void sendGift(String uid, String giftId, String bizId, Map&amp;lt;String, String&amp;gt; extmap) throws Exception {
        DeliverReq deliverReq = new DeliverReq();
        deliverReq.setUserName(queryUserName(uId));
        deliverReq.setUserPhone(queryUserPhoneNumber(uId));
        deliverReq.setSku(commodityId);
        deliverReq.setOrderId(bizId);
        deliverReq.setConsigneeUserName(extMap.get(&amp;quot;consigneeUserName&amp;quot;));
        deliverReq.setConsigneeUserPhone(extMap.get(&amp;quot;consigneeUserPhone&amp;quot;));
        deliverReq.setConsigneeUserAddress(extMap.get(&amp;quot;consigneeUserAddress&amp;quot;));
        // 真正调用原有接口方法
        Boolean isSuccess = goodsService.deliverGoods(deliverReq);
        logger.info(&amp;quot;请求参数[实物商品] =&amp;gt; uId：{} commodityId：{} bizId：{} extMap：{}&amp;quot;, uId, commodityId, bizId, JSON.toJSON(extMap));
        logger.info(&amp;quot;测试结果[实物商品]：{}&amp;quot;, isSuccess);
        if (!isSuccess) throw new RuntimeException(&amp;quot;实物商品发放失败&amp;quot;);
    }
    
    private String queryUserName(String uId) {
        return &amp;quot;Rick&amp;quot;;
    }
    private String queryUserPhoneNumber(String uId) {
        return &amp;quot;15200101232&amp;quot;;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CardCommonService implements StoreInterface {
    
	private Logger logger = LoggerFactory.getLogger(this.getClass());
	
    // 模拟注入
	private CardService CardService = new CardService();
    
    @Override
    public void sendGift(String uid, String giftId, String bizId, Map&amp;lt;String, String&amp;gt; extmap) throws Exception {
        String mobile = queryUserMobile(uId);
        // 正在调用原来接口
        CardService.grantToken(mobile, bizId);
        logger.info(&amp;quot;请求参数[优惠劵] =&amp;gt; uId：{} commodityId：{} bizId：{} extMap：{}&amp;quot;, uId, commodityId, bizId, JSON.toJSON(extMap));
        logger.info(&amp;quot;测试结果[优惠劵]：success&amp;quot;);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;：该工厂方法完美适应了需求，如果再加入新的奖品类型也会很轻松适配，代码可维护性大大提高&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test1() throws Exception {
    
    StoreFactory storeFactory = new StoreFactory();
    
    // 1. 优惠劵发放
    StoreInterface cardService = storeFactory.getService(1);
    cardService.sendGift(&amp;quot;10001&amp;quot;, &amp;quot;EGM1023938910232121323432&amp;quot;, &amp;quot;791098764902132&amp;quot;, null);
    
    // 2. 实物商品发放
    StoreInterface goodsService = storeFactory.getService(2);
    Map&amp;lt;String,String&amp;gt; extMap = new HashMap&amp;lt;String,String&amp;gt;();
    extMap.put(&amp;quot;consigneeUserName&amp;quot;, &amp;quot;Rick&amp;quot;);
    extMap.put(&amp;quot;consigneeUserPhone&amp;quot;, &amp;quot;15200292123&amp;quot;);
    extMap.put(&amp;quot;consigneeUserAddress&amp;quot;, &amp;quot;北京市朝阳区&amp;quot;);
    goodsService.sendGift(&amp;quot;10001&amp;quot;, &amp;quot;9820198721311&amp;quot;, &amp;quot;1023000020112221113&amp;quot;, extMap);
    
}
&lt;/code&gt;&lt;/pre&gt;
">设计模式-工厂方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/shen-ru-li-jie-aes-jia-mi-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;高级加密标准AES（Advanced Encryption Standard）是美国联邦政府采用的一种区块加密标准。DES算法由于其密钥较短，难以抵抗现有的攻击，因此不再作为加密标准。AES用来替代原先的DES，现在AES已成为对称密钥加密中流行的算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;算法概述&#34;&gt;算法概述&lt;/h2&gt;
&lt;/br&gt;
&lt;p&gt;AES算法说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AES中明文分组可变：128、192、256比特&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;密钥长度可变：各自可独立指定128、192、256比特&lt;/strong&gt;，平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AES加密过程是在&lt;strong&gt;一个4×4的字节矩阵上运作&lt;/strong&gt;，这个矩阵又称为“状态（state）”，其初值就是一个明文区块，&lt;strong&gt;矩阵中一个元素大小就是明文区块中的一个Byte，其矩阵的列数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可视情况增加&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环加密的次数由&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的长度和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的长度决定&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225172759081.png&#34; alt=&#34;image-20210225172759081&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环加密过程中除最后一轮外均包含4个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加轮密钥&lt;code&gt;AddRoundKey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字节代替&lt;code&gt;SubBytes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;行移位&lt;code&gt;ShiftRows&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列混淆&lt;code&gt;MixColumns&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225213410269.png&#34; alt=&#34;image-20210225213410269&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;p&gt;接下来我们分析AES加密过程中每一轮的处理步骤&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;aes加密&#34;&gt;AES加密&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;字节替换&#34;&gt;字节替换&lt;/h3&gt;
&lt;p&gt;16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组&lt;/p&gt;
&lt;p&gt;在字节替换的步骤中，矩阵中的各字节透&lt;strong&gt;过一个8位的S盒进行转换。这个步骤提供了加密法非线性的变换能力&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225172357175.png&#34; alt=&#34;image-20210225172357175&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;/br&gt;
&lt;p&gt;&lt;strong&gt;S盒的使用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里的S盒是一个16行16列的矩阵，输入8a，则去找第8行第10列交界点处的值：输出7e，即7e=S（8a）&lt;/li&gt;
&lt;li&gt;这里针对每一个字节对照S盒进行字节替换&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225181454137.png&#34; alt=&#34;image-20210225181454137&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;行移位&#34;&gt;行移位&lt;/h3&gt;
&lt;p&gt;行移位描述矩阵的列操作。&lt;strong&gt;在此步骤中，每一行都向左循环位移某个偏移量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偏移量的多少和状态矩阵的列数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;密切相关&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225182751031.png&#34; alt=&#34;image-20210225182751031&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;图中所示是一个4列的矩阵，移位的结果是：第一行不变，第二行循环左移&lt;strong&gt;1&lt;/strong&gt;个字节，第三行循环左移&lt;strong&gt;2&lt;/strong&gt;个字节，第四行循环左移&lt;strong&gt;3&lt;/strong&gt;个字节&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225181905001.png&#34; alt=&#34;image-20210225181905001&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;列混淆&#34;&gt;列混淆&lt;/h3&gt;
&lt;/br&gt;
&lt;ul&gt;
&lt;li&gt;将每列视为有限域&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;GF(2^8)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;上多项式，每一行的四个元素分别当作&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1, x, x^2, x^3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的系数，与固定的多项式&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c(x)=3x^3 + x^2 + x + 2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进行模&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x^4+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;后相乘，记为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;⊗&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\otimes&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;⊗&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225182212003.png&#34; alt=&#34;image-20210225182212003&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;列混淆运算也可写为矩阵乘法：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;⊗&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b(x) = c(x) \otimes a(x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⊗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225184704499.png&#34; alt=&#34;image-20210225184704499&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最后一个加密循环中省略列混淆步骤，目的是在解密过程中统一每一轮解密都进行逆列混淆&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;加轮密钥&#34;&gt;加轮密钥&lt;/h3&gt;
&lt;/br&gt;
&lt;h4 id=&#34;密钥编排&#34;&gt;密钥编排&lt;/h4&gt;
&lt;/br&gt;
&lt;p&gt;密钥编排指从种子密钥（以字节为元素的矩阵阵列描述密钥，阵列为4行，列数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为密钥长度除32）&lt;strong&gt;得到轮密钥的过程&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225193449885.png&#34; alt=&#34;image-20210225193449885&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;密钥字符&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;单位是以4字节（32bit）为元素的一维阵列，如果明文要经过&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_r&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;轮加密，状态矩阵一共有&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;列，则一共有&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_b* (N_r+1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个密钥字符数量。例如AES-128就需要 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;44&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;4 * (10 + 1) = 44&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个密钥字符，每一轮加密使用4个字符&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225195318012.png&#34; alt=&#34;image-20210225195318012&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;p&gt;&lt;strong&gt;获得&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W[N_b * (N_r + 1)]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225200250807.png&#34; alt=&#34;image-20210225200250807&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;前&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个字取为种子密钥，以后每个字的计算按照递归方式定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k &amp;lt;= 6&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的倍数，那么第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;列：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;⊕&lt;/mo&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W[i]=W[i-4] \oplus W[i-1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⊕&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的倍数，那么第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;列由如下等式确定：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;⊕&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W[i]=W[i-4] \oplus T(W[i-1])&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⊕&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这里的T函数较为复杂
&lt;ul&gt;
&lt;li&gt;自循环移位RotByte：将1个字中的4个字节循环左移1个字节&lt;/li&gt;
&lt;li&gt;S盒变换SubByte：对字循环的结果使用S盒进行字节代换&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与轮常数Rcon异或&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void KeyExpansion (byteKey[4 * Nk] , W[Nb * (Nr + 1)]) {
	for (i = 0; i &amp;lt; Nk; i++)
		W[i] = (Key[4 * i], Key[4 * i + 1], Key[4 * i + 2], Key[4 * i + 3] );
	for (i = Nk; i &amp;lt; Nb * (Nr + 1); i++) {
		temp = W[i - 1];
		if (i % Nk == 0)
			temp = SubByte(RotByte(temp)) ^ Rcon[i / Nk];
		W[i] = W[i - Nk] ^ temp;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225205907163.png&#34; alt=&#34;image-20210225205907163&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;轮常数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Rcon[i/N_k]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为轮常数，其值与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;无关，定义为（字节用十六进制表示，同时理解为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;GF(2^8)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;上的元素）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;00&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;00&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;00&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Rcon [i]=(RC[i], 00, 00, 00)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;RC[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是有限域&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;GF(2^8)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中值为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x^{i - 1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.824664em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.824664em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k &amp;gt; 6&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，区别在于：&lt;strong&gt;当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i - 4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N_k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的整倍数时，须先将前一个字&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W[i - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;经过SubByte变换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void KeyExpansion (byteKey[4 * Nk] , W[Nb * (Nr + 1)]) {
	for (i = 0; i &amp;lt; Nk; i++)
		W[i] = (Key[4 * i], Key[4 * i + 1], Key[4 * i + 2], Key[4 * i + 3] );
	for (i = Nk; i &amp;lt; Nb * (Nr + 1); i++) {
		temp = W[i - 1];
		if (i % Nk == 0)
			temp = SubByte(RotByte(temp)) ^ Rcon[i / Nk];
        else if (i % Nk == 4)
            temp = SubByte(temp);
		W[i] = W[i - Nk] ^ temp;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h4 id=&#34;异或&#34;&gt;异或&lt;/h4&gt;
&lt;p&gt;通过密钥编排，我们得到轮密钥（扩展密钥），&lt;strong&gt;这把密钥大小会跟原矩阵一样，以与原矩阵中每个对应的字节作异或即生成了输出值&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225182050401.png&#34; alt=&#34;image-20210225182050401&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/br&gt;
&lt;h2 id=&#34;aes解密&#34;&gt;AES解密&lt;/h2&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225171918112.png&#34; alt=&#34;image-20210225171918112&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;p&gt;AES的每一轮解密都是AES加密相对应的逆操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逆行移位：&lt;strong&gt;它对状态的每一行进行循环右移&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逆字节替换：应用逆S盒进行字节替换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逆列混淆：将状态矩阵中的每一列视为系数在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;GF(2^8)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;上的次数小于4的多项式与同一个固定的多项式&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;09&lt;/mn&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d(x)=0Bx^3 + 0Dx^2 + 09x + 0E&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;相乘，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d(x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c(x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;互逆&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225214634170.png&#34; alt=&#34;image-20210225214634170&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加轮密钥&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;AES的工作模式和填充模式已经在DES中做有相应介绍，只需将DES分组的64位换为AES的128位即可，不再赘述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/br&gt;
&lt;h2 id=&#34;aes-in-java&#34;&gt;AES in Java&lt;/h2&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * @Author: Kay_Rick@outlook.com
 * @Date: 2021-02-24 22:25:15
 * @LastEditors: Kay_Rick@outlook.com
 * @LastEditTime: 2021-02-25 22:18:49
 * @Description: AESEncryptionExample
 */
package Crypt;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

public class AESEncryptionExample {
    private static Cipher encryptCipher;
    private static Cipher decryptCipher;
    // AES 16Byte(128bits) paramters
    private static final byte[] iv = { 11, 22, 33, 44, 99, 88, 77, 66, 43, 65, 76, 43, 34, 64, 43, 92};

    public static void main(String[] args) {
        String clearTextFile = &amp;quot;D:\\Server\\Cryption\\source.txt&amp;quot;;
        String cipherTextFile = &amp;quot;D:\\Server\\Cryption\\cipher.txt&amp;quot;;
        String clearTextNewFile = &amp;quot;D:\\Server\\Cryption\\source-new.txt&amp;quot;;

        try {
            // create SecretKey using KeyGenerator
            // SecretKey key = KeyGenerator.getInstance(&amp;quot;AES&amp;quot;).generateKey(); 
            KeyGenerator kgen = KeyGenerator.getInstance(&amp;quot;AES&amp;quot;);
            // specify the AES256 (default AES128)
            kgen.init(256, new SecureRandom());
            SecretKey key = kgen.generateKey();

            // create iv parameter using CBC encrypt mode,
            // default ECB encrypt mode does not need iv parameters
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);

            // get Cipher instance and initiate in encrypt mode
            // this cipher instance using CBC encrypt mode and padding 16Byte when the datablock less than 16Byte
            encryptCipher = Cipher.getInstance(&amp;quot;AES/CBC/PKCS5Padding&amp;quot;);
            encryptCipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);

            // get Cipher instance and initiate in decrypt mode
            decryptCipher = Cipher.getInstance(&amp;quot;AES/CBC/PKCS5Padding&amp;quot;);
            decryptCipher.init(Cipher.DECRYPT_MODE, key, paramSpec);

            // method to encrypt clear text file to encrypted file
            encrypt(new FileInputStream(clearTextFile), new FileOutputStream(cipherTextFile));

            // method to decrypt encrypted file to clear text file
            decrypt(new FileInputStream(cipherTextFile), new FileOutputStream(clearTextNewFile));
            System.out.println(&amp;quot;done&amp;quot;);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
                | InvalidAlgorithmParameterException | IOException e) {
            e.printStackTrace();
        }
    }

    private static void encrypt(InputStream is, OutputStream os) throws IOException {
        // create CipherOutputStream to encrypt the data using encryptCipher
        os = new CipherOutputStream(os, encryptCipher);
        writeData(is, os);
    }

    private static void decrypt(InputStream is, OutputStream os) throws IOException {
        // create CipherOutputStream to decrypt the data using decryptCipher
        is = new CipherInputStream(is, decryptCipher);
        writeData(is, os);
    }

    // utility method to read data from input stream and write to output stream
    private static void writeData(InputStream is, OutputStream os) throws IOException {
        byte[] buf = new byte[1024];
        int numRead = 0;
        // read and write operation
        while ((numRead = is.read(buf)) &amp;gt;= 0) {
            os.write(buf, 0, numRead);
        }
        os.close();
        is.close();
    }

}
&lt;/code&gt;&lt;/pre&gt;
">深入理解AES加密算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/shen-ru-li-jie-des-jia-mi-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;数据加密标准（DES：Data Encryption Standard）属于对称分组密码算法，是1977年美国联邦信息处理标准（FIPS）中所采用的一种对称加密算法。随着算力的提高，现在DES已经可以被暴力破解了，因此不再建议使用DES算法。但在学习阶段，我们仍然要理解DES加密的算法思想。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;算法概述&#34;&gt;算法概述&lt;/h2&gt;
&lt;/br&gt;
&lt;p&gt;在学习DES加密算法之前，我们需要了解密码算法的体系结构如下：&lt;strong&gt;DES算法属于对称密码算法&lt;/strong&gt;（加密密钥盒解密密钥相同，或实质上等同）&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223163811837.png&#34; alt=&#34;image-20210223163811837&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;典型的DES&lt;strong&gt;以64位为分组对数据加密，加密和解密用的是同一个算法&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223172432598.png&#34; alt=&#34;image-20210223172432598&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;/br&gt;
&lt;h2 id=&#34;des加密&#34;&gt;DES加密&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;明文分组和ip置换&#34;&gt;明文分组和IP置换&lt;/h3&gt;
&lt;/br&gt;
&lt;p&gt;IP置换目的是将输入的64位数据块按位重新组合，并把输出分为L0、R0两部分，每部分各长32位。置换的规则按照置换表来进行置换&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223173111368.png&#34; alt=&#34;image-20210223173111368&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;置换：表中的数字代表新数据中此位置的数据在原数据中的位置&lt;/strong&gt;，即原数据块的第58位放到新数据的第1位，第50位放到第2位，……依此类推，第7位放到第64位&lt;/li&gt;
&lt;li&gt;置换后的数据分为L0和R0两部分，L0为新数据的左32位，R0为新数据的右32位&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;des加密迭代&#34;&gt;DES加密迭代&lt;/h3&gt;
&lt;/br&gt;
&lt;h4 id=&#34;密钥编排&#34;&gt;密钥编排&lt;/h4&gt;
&lt;/br&gt;
&lt;p&gt;密钥K长64位，8比特，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。&lt;/p&gt;
&lt;p&gt;在DES的每一轮迭代中，都需要产生出不同的48位子密钥&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;K_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，确定这些子密钥的方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将56位（不考虑每个字节的第8位，DES的密钥由64位减至56位，每个字节的第8位作为奇偶校验位）的&lt;strong&gt;密钥进行置换选择（PC-1），然后将密钥分成两部分，每部分28位&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据轮数，这两部分分别循环左移1位或2位。每轮移动的位数按子密钥计算逻辑表确定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;移动后，从56位中选出48位。这个过程中，既置换了每位的顺序，又选择了子密钥&lt;/strong&gt;，因此称为压缩置换（PC-2）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223180048101.png&#34; alt=&#34;image-20210223180048101&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;/br&gt;
&lt;h4 id=&#34;迭代运算&#34;&gt;迭代运算&lt;/h4&gt;
&lt;/br&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225141403051.png&#34; alt=&#34;image-20210225141403051&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当明文通过分组和IP置换后，我们得到两个分组左32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L_{i-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.891661em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和右32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R_{i-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.891661em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，接下来我们要经过16轮加密迭代，每一轮迭代的过程都是一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一轮迭代的左32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L_{i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;直接由上一轮迭代的右32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R_{i-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.891661em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;得到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一轮迭代的右32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R_{i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;由上一轮迭代的左32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L_{i-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.891661em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和右32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R_{i-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.891661em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;得到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设输入为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(x, y)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，则DES每一轮迭代的输出为：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;⊕&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(y, x \oplus f(k, y))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⊕&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225224613117.png&#34; alt=&#34;image-20210225224613117&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来我们讨论&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;函数中的细节实现&lt;/p&gt;
&lt;/br&gt;
&lt;h5 id=&#34;扩展置换&#34;&gt;扩展置换&lt;/h5&gt;
&lt;/br&gt;
&lt;p&gt;右32位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R_{i-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.891661em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;首先通过扩展 / 置换表扩展成48位：表中的数字代表位，旁边两列数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位&lt;/p&gt;
&lt;/br&gt;
&lt;h5 id=&#34;s盒代替&#34;&gt;S盒代替&lt;/h5&gt;
&lt;/br&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;S盒代替时DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;压缩后的子密钥&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;K_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与扩展分组异或以后得到48位的数据&lt;/strong&gt;，将这个数据送入S盒，进行替代运算。&lt;strong&gt;替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数&lt;/strong&gt;。S盒的6个输入确定了其对应的输出在哪一行哪一列，&lt;strong&gt;输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(&amp;lt;32)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223225040815.png&#34; alt=&#34;image-20210223225040815&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223234547147.png&#34; alt=&#34;image-20210223234547147&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;例如S1输入为101100，则行数和列数的二进制表示分别是10和1100，即第2行和第6列，然后去查S1盒对应的表，将查得数据转换位4位二进制数，依次类推，得到代换后的32比特&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225141837885.png&#34; alt=&#34;image-20210225141837885&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;/br&gt;
&lt;h5 id=&#34;p盒置换&#34;&gt;P盒置换&lt;/h5&gt;
&lt;/br&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225142516102.png&#34; alt=&#34;image-20210225142516102&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S盒代替运算的32位输出按照置换表进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始下一轮&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;ip逆置换&#34;&gt;IP逆置换&lt;/h3&gt;
&lt;/br&gt;
&lt;ul&gt;
&lt;li&gt;逆置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210223235452542.png&#34; alt=&#34;image-20210223235452542&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第40位放到新数据的第1位，第8位放到第2位，……依此类推，第25位放到第64位&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们知道DES算法的第一步就是对明文进行分组，每一组64位，然后进行分组加密，这里就会出现两个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于每一个分组如何去使用密码算法组成整个密文，这就是我们要讨论的分组密码工作模式&lt;/li&gt;
&lt;li&gt;要加密的密文不一定都是64的倍数，那么当最后一个分组不足64位如何填充&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/br&gt;
&lt;h2 id=&#34;des解密&#34;&gt;DES解密&lt;/h2&gt;
&lt;/br&gt;
&lt;p&gt;DES是一种对称密码算法，解密不是加密的逆序，而是使用同样的加密步骤，使用次序相反加密密钥。&lt;strong&gt;如果各轮加密密钥分别是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\{K_1，K_2，K_3…K_{16}\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，那么解密密钥就是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;15&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;14&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\{K_{16}，K_{15}，K_{14}…K_1\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;分组密码工作模式&#34;&gt;分组密码工作模式&lt;/h2&gt;
&lt;/br&gt;
&lt;p&gt;接下来我们介绍两种常见的分组密码工作模式：ECB和CBC模式。除此以外，还有CFB、OFB和计数器模式，这里先不做介绍&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;电码本模式ecb&#34;&gt;电码本模式（ECB）&lt;/h3&gt;
&lt;p&gt;ECB模式对划分出的每一组使用DES加密，然后将这些密文进行组合即完成整段明文的加密&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225144507226.png&#34; alt=&#34;image-20210225144507226&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;优点：实现简单，不同明文分组的加密可并行实施，硬件实施速度很快&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;相同的明文分组对应相同的密文分组&lt;/strong&gt;，不能隐藏铭文分组的统计规律和结构规律，不能抵抗替换攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;密码分组链接模式cbc&#34;&gt;密码分组链接模式（CBC）&lt;/h3&gt;
&lt;p&gt;这种模式先将明文分组与上一次的密文块进行按比特异或，然后再进行加密处理。这种模式必须选择一个初始8Byte的向量IV，用于加密第一块明文&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20210225145037172.png&#34; alt=&#34;image-20210225145037172&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;优点：明文块的统计特性得到了隐蔽，各密文块不仅与当前明文块有关，而且还与以前的明文块及初始化向量有关，从而使明文的统计规律在密文中得到了较好的隐藏&lt;/li&gt;
&lt;li&gt;缺点：整个加密的过程是串行的，效率低于ECB模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h2 id=&#34;分组密码填充方式&#34;&gt;分组密码填充方式&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;nopadding&#34;&gt;NoPadding&lt;/h3&gt;
&lt;p&gt;不做任何填充，但是要求明文必须是8字节（AES加密16字节）的整数倍&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;pkcs5paddingdefault&#34;&gt;PKCS5Padding（default）&lt;/h3&gt;
&lt;p&gt;如果明文块少于8个字节（64bit），在明文块末尾补足相应数量的字符，&lt;strong&gt;每个字节的值等于缺少的字符数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如明文：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\{1,2,3,4,5\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，缺少2个字节，则补全为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\{1,2,3,4,5,2,2\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;iso10126padding&#34;&gt;ISO10126Padding&lt;/h3&gt;
&lt;p&gt;如果明文块少于8个字节（64bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，&lt;strong&gt;其他字符填充随机数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如明文：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\{1,2,3,4,5\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，缺少2个字节，则可能补全为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\{1,2,3,4,5,a,b\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;des-in-java&#34;&gt;DES in Java&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * @Author: Kay_Rick@outlook.com
 * @Date: 2021-02-24 14:14:39
 * @LastEditors: Kay_Rick@outlook.com
 * @LastEditTime: 2021-02-25 22:07:13
 * @Description: DESEncryptionExample
 */
package Crypt;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

public class DESEncryptionExample {
    private static Cipher encryptCipher;
    private static Cipher decryptCipher;
    // DES 8Byte paramters
    private static final byte[] iv = { 11, 22, 33, 44, 99, 88, 77, 66};

    public static void main(String[] args) {
        String clearTextFile = &amp;quot;D:\\Server\\Cryption\\source.txt&amp;quot;;
        String cipherTextFile = &amp;quot;D:\\Server\\Cryption\\cipher.txt&amp;quot;;
        String clearTextNewFile = &amp;quot;D:\\Server\\Cryption\\source-new.txt&amp;quot;;

        try {
            // create SecretKey using KeyGenerator
            SecretKey key = KeyGenerator.getInstance(&amp;quot;DES&amp;quot;).generateKey();
            // create iv parameter using CBC encrypt mode,
            // default ECB encrypt mode does not need iv parameters
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);

            // get Cipher instance and initiate in encrypt mode
            // this cipher instance using CBC encrypt mode and padding 8Byte when the datablock less than 8Byte
            encryptCipher = Cipher.getInstance(&amp;quot;DES/CBC/PKCS5Padding&amp;quot;);
            encryptCipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);

            // get Cipher instance and initiate in decrypt mode
            decryptCipher = Cipher.getInstance(&amp;quot;DES/CBC/PKCS5Padding&amp;quot;);
            decryptCipher.init(Cipher.DECRYPT_MODE, key, paramSpec);

            // method to encrypt clear text file to encrypted file
            encrypt(new FileInputStream(clearTextFile), new FileOutputStream(cipherTextFile));

            // method to decrypt encrypted file to clear text file
            decrypt(new FileInputStream(cipherTextFile), new FileOutputStream(clearTextNewFile));
            System.out.println(&amp;quot;done&amp;quot;);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
                | InvalidAlgorithmParameterException | IOException e) {
            e.printStackTrace();
        }
    }

    private static void encrypt(InputStream is, OutputStream os) throws IOException {
        // create CipherOutputStream to encrypt the data using encryptCipher
        os = new CipherOutputStream(os, encryptCipher);
        writeData(is, os);
    }

    private static void decrypt(InputStream is, OutputStream os) throws IOException {
        // create CipherOutputStream to decrypt the data using decryptCipher
        is = new CipherInputStream(is, decryptCipher);
        writeData(is, os);
    }

    // utility method to read data from input stream and write to output stream
    private static void writeData(InputStream is, OutputStream os) throws IOException {
        byte[] buf = new byte[1024];
        int numRead = 0;
        // read and write operation
        while ((numRead = is.read(buf)) &amp;gt;= 0) {
            os.write(buf, 0, numRead);
        }
        os.close();
        is.close();
    }

}
&lt;/code&gt;&lt;/pre&gt;
">深入理解DES加密算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/zhao-fu-qin-bing-cha-ji-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这就是在我们算法中经常使用的并查集算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解决什么问题&#34;&gt;解决什么问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;将两个集合合并&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;询问两个元素是否在一个集合当中&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p[x]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的父节点&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将所有节点的父节点设为自己&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201220161933.png&#34; alt=&#34;image-20201220161932537&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int p[N];
for (int i = 1; i &amp;lt;= n; i++)
    p[i] = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;合并集合&#34;&gt;合并集合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将节点1合并到节点2形成一个集合，节点3和节点5合并到结点4形成一个集合&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201220162203.png&#34; alt=&#34;image-20201220162201911&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;再将两个集合合并成一个集合&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201220162425.png&#34; alt=&#34;image-20201220162424657&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// p[x]是x的集合编号，p[y]是y的集合编号
p[x] = y;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;判断当前节点是否是树根&#34;&gt;判断当前节点是否是树根&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (p[x] == x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;求节点的集合编号&#34;&gt;求节点的集合编号&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;while (p[x] != x)
    x = p[x];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;路径压缩优化，第一次求祖先节点的时候把所有遍历的点的父节点都设为祖先节点&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201220164122.png&#34; alt=&#34;image-20201220164121536&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 返回x的祖宗节点 + 路径压缩
int find (int x) {
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;合并集合-2&#34;&gt;合并集合&lt;/h2&gt;
&lt;p&gt;一共有n个数，编号是1~n，最开始每个数各自在一个集合中。现在要进行m个操作，操作共有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；&lt;/li&gt;
&lt;li&gt;“Q a b”，询问编号为a和b的两个数是否在同一个集合中；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输入整数n和m。接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每个询问指令”Q a b”，都要输出一个结果，如果a和b在同一集合内，则输出“Yes”，否则输出“No”。每个结果占一行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,m≤10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yes
No
Yes
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;

int p[N];
int n, m;
// 核心find函数
int find(int x) {
    if (x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i++)
        p[i] = i;
    while (m--) {
        char op[2];
        int a, b;
        scanf(&amp;quot;%s%d%d&amp;quot;, op, &amp;amp;a, &amp;amp;b);
        if (op[0] == &#39;M&#39;)
            p[find(a)] = find(b);
        else {
            if (find(a) != find(b))
                printf(&amp;quot;No\n&amp;quot;);
            else 
                printf(&amp;quot;Yes\n&amp;quot;);
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;连通块中的数量&#34;&gt;连通块中的数量&lt;/h2&gt;
&lt;p&gt;给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。现在要进行m个操作，操作共有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“C a b”，在点a和点b之间连一条边，a和b可能相等；&lt;/li&gt;
&lt;li&gt;“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；&lt;/li&gt;
&lt;li&gt;“Q2 a”，询问点a所在连通块中点的数量；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输入整数n和m。接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每个询问指令”Q1 a b”，如果a和b在同一个连通块中，则输出“Yes”，否则输出“No”。&lt;/p&gt;
&lt;p&gt;对于每个询问指令“Q2 a”，输出一个整数表示点a所在连通块中点的数量。每个结果占一行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,m≤10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yes
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

const int N = 100010;

// cnt数组维护连通块的结点数量
int p[N], cnt[N];
int n, m;

int find(int x) {
    if (x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    // 初始化
	for (int i = 1; i &amp;lt;= n; i++) {
        p[i] = i;
        cnt[i] = 1;
    }
    while (m--) {
        string op;
        int a, b;
        cin &amp;gt;&amp;gt; op;
        if (op == &amp;quot;C&amp;quot;) {
            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            a = find(a);
            b = find(b);
            if (a != b) {
                p[a] = b;
                // 注意这里不要写find(a)和find(b)：因为上面合并之后，find(b)会变，所以我们在前面记录a和b
                cnt[b] += cnt[a];
            }
        }
        else if (op == &amp;quot;Q1&amp;quot;) {
            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            if (find(a) == find(b))
                cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
            else 
                cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else {
            cin &amp;gt;&amp;gt; a;
            cout &amp;lt;&amp;lt; cnt[find(a)] &amp;lt;&amp;lt; endl;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">找父亲-并查集算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/lao-ji-chang-yong-wei-yun-suan/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在计算机内部都是使用0和1这样二进制来进行存储数据，那么对于很多操作，我们可以通过相关位运算来进行实现，这里就位运算的相关技巧进行一个总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;00000000&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;00000000&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;00000000&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \ ^{\land} \ 00000000 = x     ,  x \ \&amp;amp; \ 00000000 = 0    ,   x\  |\  00000000 = x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.751892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;11111111&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;11111111&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;11111111&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;11111111&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \ ^{\land} \ 11111111 = \sim x     ,  x \ \&amp;amp; \ 11111111 = x    ,   x\  |\  11111111 = 11111111&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.751892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \ ^{\land} \ x = 0     ,  x \ \&amp;amp;\  x = x    ,   x\  |\  x = x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.751892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;&amp;gt;&amp;gt; n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为算术右移，相当于除以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-7 &amp;gt;&amp;gt; 2 = -2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;&amp;gt;&amp;gt;&amp;gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为无符号右移，左边会补上 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，例如 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1073741822&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-7 &amp;gt;&amp;gt;&amp;gt; 2 = 1073741822&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;&amp;lt;&amp;lt; n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为算术左移，相当于乘以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;28&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-7 &amp;lt;&amp;lt; 2 = -28&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算技巧&#34;&gt;运算技巧&lt;/h2&gt;
&lt;p&gt;根据这些特点，部分操作就显得非常容易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;^{\land}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.751892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;实现数位翻转：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;11111111&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \ ^{\land} \ 11111111 = \sim x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.751892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;三个数中重复的两个数去除，只留下另一个数&lt;/strong&gt;：利用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;00000000&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;∧&lt;/mo&gt;&lt;/msup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \ ^{\land} \ 00000000 = x, x \ ^{\land} \ x = 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.751892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.946332em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\&amp;amp;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;实现掩码操作：一个数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;num&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mn&gt;00111100&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mask:00111100&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进行位与操作，只保留&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;num&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mask&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;部分相对应的位&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;|&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;实现设值操作：一个数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;num&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mn&gt;00111100&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mask:00111100&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进行位或操作，将&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;num&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mask&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;部分相对应的位都设置为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n\ \&amp;amp;\ (n - 1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;去除&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的位级中最低的那一位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，例如对于二进制表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;01011011&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;01011011&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，减去&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;得到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;01011010&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;01011010&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这两个数相与得到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;01011010&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;01011010&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-n = \sim n + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n\ \&amp;amp;\ (-n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：得到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的位级表示中最低的那一位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201218170102.png&#34; alt=&#34;image-20201217162448339&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;求第k位数&#34;&gt;求第k位数&lt;/h2&gt;
&lt;p&gt;例如：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;15&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1111&lt;/mn&gt;&lt;msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n = 15 = (1111)_{2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位移到最后一位：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x = n &amp;gt;&amp;gt; k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;看最后一位是多少：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x\ \&amp;amp; \ 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;因此要取最后一位元素：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;amp;&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x = n &amp;gt;&amp;gt; k\  \&amp;amp; \ 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int main() {
    int n = 10;
    // 从最高位输出：就是输出其二进制表示
    for (int k = 3; k &amp;gt;= 0; k--)
        cout &amp;lt;&amp;lt; (n &amp;gt;&amp;gt; k &amp;amp; 1);
   	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lowbitx&#34;&gt;lowbit(x)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lowbit(x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：返回&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的最后一位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1010&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;101000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x = 1010, lowbit(x) = 10, x = 101000, lowbit(x) = 1000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-x = \sim x + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有了&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lowbit(x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;操作，那么计算&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中有多少位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;就显得非常容易&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int lowbit(int x) {
    return x &amp;amp; (-x);
}

int main() {
    int x, ans = 0;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;x);
    while (x) {
        x -= lowbit(x);
        ans++;
    }
    printf(&amp;quot;%d &amp;quot;, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">牢记常用位运算</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/qiao-yong-chi-san-hua-chu-li/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;离散化的本质就是映射，专门用于处理&lt;strong&gt;数据的值域比较大，个数比较少&lt;/strong&gt;的情况，这时候我们的做法就是离散化：将这些间隔很大的点，映射到相邻的数组元素中，减少对空间的需求，也减少计算量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;离散化&#34;&gt;离散化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;值的范围比较大&lt;/li&gt;
&lt;li&gt;值的个数比较少&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201217180922.png&#34; alt=&#34;image-20201217180921393&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里可能会疑惑这和哈希有什么区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表不能像离散化那样缩小数组的空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;核心问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A[]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可能存在重复，需要去重&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; A;
sort(A.begin(), A.end());	// 排序
A.erase(unique(A.begin(), A.end()), A.end());	// 去除重复元素
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如何计算离散化后的值？ ==&amp;gt; 二分&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 二分求出x对应离散化的值
int find(int x) {
    int l = 0, r = A.size() - 1;
    while (l &amp;lt; r) {
        int mid = l + r &amp;gt;&amp;gt; 1;
        if (A[mid] &amp;gt;= x)
            r = mid;
       	l = mid + 1;
    }
    // 目的为了映射到 1 ~ n
    return r + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;区间和&#34;&gt;区间和&lt;/h2&gt;
&lt;p&gt;假定有一个无限长的数轴，数轴上每个坐标上的数都是0。现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。接下来 n 行，每行包含两个整数x和c。再接下里 m 行，每行包含两个整数l和r。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共m行，每行输出一个询问中所求的区间内数字和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;−10^9≤x≤10^9,
1≤n,m≤10^5,
−10^9≤l≤r≤10^9,
−10000≤c≤10000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.950078em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 3
1 2
3 6
7 5
1 3
4 6
7 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
0
5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据分布在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;−10^9≤x≤10^9&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.950078em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，加数据的次数和查询的次数所涉及的数据不超过&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;3 × 10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，离散化处理&lt;/li&gt;
&lt;li&gt;开辟额外数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;alls&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;存放所以要访问的数组下标，然后进行离散化&lt;/li&gt;
&lt;li&gt;要访问该下标的时候，根据映射关系&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;find(int\ x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;函数去访问离散化后的数组对应的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

typedef pair&amp;lt;int, int&amp;gt; PII;

const int N = 300010;

int n, m;
int a[N], s[N];
vector&amp;lt;PII&amp;gt; add, query;
// 存放需要进行离散化的数据
vector&amp;lt;int&amp;gt; alls;

int find(int x) {
    int l = 0, r = alls.size() - 1;
    while (l &amp;lt; r) {
        int mid = l + r &amp;gt;&amp;gt; 1;
        if (alls[mid] &amp;gt;= x) 
            r = mid;
        else 
            l = mid + 1;
    }
    // 映射到 1 ~ n
    return r + 1;
} 

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; n; i++) {
        int x, c;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; c;
        // 表示要在x的位置加上c
        add.push_back({x, c});
        // 存下要进行离散化处理的元素
        alls.push_back(x);
    }
    for (int i = 0; i &amp;lt; m; i++) {
        int l, r;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    // 去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    for (auto item : add) {
        // 找到离散化的位置
        int x = find(item.first);
        a[x] += item.second;
    }
    // 预处理前缀和
    for (int i = 1; i &amp;lt;= alls.size(); i++) 
        s[i] = s[i - 1] + a[i];
    for (auto item : query) {
        int l = find(item.first);
        int r = find(item.second);
        cout &amp;lt;&amp;lt; s[r] - s[l - 1] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">巧用“离散化”处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/qu-jian-he-bing-wen-ti/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;区间合并是一类比较经典的问题：将一部分有交集的区间进行合并，这里就区间合并算法做一个简单的分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;给定 n 个区间 [li,ri]，要求合并所有有交集的区间。注意如果在端点处相交，也算有交集。输出合并完成后的区间个数。例如：[1,3]和[2,6]可以合并为一个区间[1,6]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n。接下来n行，每行包含两个整数 l 和 r。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含一个整数，表示合并区间完成后的区间个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n≤100000,
−10^9≤li≤ri≤10^9&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.79549em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5
1 2
2 4
5 6
7 8
7 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;按区间左端点排序&lt;/li&gt;
&lt;li&gt;分情况合并&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过左端点排序之后，只会出现下面的情况：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201217195353.png&#34; alt=&#34;image-20201217195352660&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;情况一：当前区间完全被上一区间覆盖，直接跳过&lt;/li&gt;
&lt;li&gt;情况二：将当前区间的右端点更新为上一区间的右端点，达到区间延长的效果&lt;/li&gt;
&lt;li&gt;情况三：当前区间的左端点严格大于上一区间的右端点，则表示该区间不能合并，更新区间去合并下一段&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

typedef pair&amp;lt;int, int&amp;gt; PII;

vector&amp;lt;PII&amp;gt; seg;
int n;

int merge(vector&amp;lt;PII&amp;gt;&amp;amp; seg) {
    vector&amp;lt;PII&amp;gt; res;
    // sort默认先排first位置
    sort(seg.begin(), seg.end());
    int start = -2e9, end = -2e9;
    for (auto item : seg) {
        // 没有交集
        if (item.first &amp;gt; end) {
            // 如果是第一段就先不加入到结果集
            if (start != -2e9) 
                res.push_back({start, end});
            start = item.first;
            end = item.second;
        }
        // 合并操作
        else 
            end = max(end, item.second);
    }
    // 最后一段还没有加入到结果集中，这里判断防止空的情况
    if (start != -2e9)
        res.push_back({start, end});
    return res.size();
}

int main() {
   cin &amp;gt;&amp;gt; n;
   for (int i = 0; i &amp;lt; n; i++) {
       int l, r;
       cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
       seg.push_back({l, r});
   }
   cout &amp;lt;&amp;lt; merge(seg) &amp;lt;&amp;lt; endl;
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">区间合并问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/qia-si-kmp-suan-fa/"" data-c="
          &lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;KMP算法是一个效率非常高的字符串匹配算法。不过其难以理解。在这里总结一下最容易理解的KMP算法。&lt;/p&gt;
&lt;p&gt;KMP算法完成的任务是：给定两个字符串A和B，长度分别为n和m，&lt;strong&gt;判断B是否在A中出现，如果出现则返回出现的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;bf算法&#34;&gt;BF算法&lt;/h2&gt;
&lt;p&gt;在介绍&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;KMP&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;算法之前，我们首先看一下暴力匹配算法。暴力匹配非常容易理解：那就是暴力去遍历字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的每一个位置，然后从该位置开始和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进行匹配，但是这种方法的复杂度是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nm)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int BF(string A, string B) {
    int n = A.size();
    int m = B.size();
    for (int i = 0; i &amp;lt; n - m; i++) {
        int j = 0;
        while (j &amp;lt; m; j++) {
            if (A[i] != B[j])
                break;
        }
        // 全部匹配，输出下标
        if (j == m)
			cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
    }
    // 没有找到
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;kmp算法&#34;&gt;KMP算法&lt;/h2&gt;
&lt;h3 id=&#34;kmp原理&#34;&gt;KMP原理&lt;/h3&gt;
&lt;p&gt;对于暴力算法，如果出现不匹配字符，同时回退&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的指针。最主要的问题在于：如果字符串中重复的字符比较多，该算法就显得很蠢。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;KMP&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;算法通过一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的预处理，使匹配的复杂度降为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n+m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中寻找&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，当匹配到位置&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时两个字符串不相等，这时我们需要将字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;向前移动。&lt;strong&gt;常规方法是每次向前移动一位，但是它没有考虑前&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位已经比较过这个事实，所以效率不高&lt;/strong&gt;。事实上，如果我们提前计算某些信息，就有可能一次前移多位。假设我们根据已经获得的信息知道可以前移&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位，我们分析移位前后的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;有什么特点。我们可以得到如下的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S段字符串是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一个前缀&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;段字符串是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一个后缀&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;段和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;段字符串长度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i - k - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;段字符串和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;段字符串相等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以前移&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位之后，可以继续比较位置&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前提是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个位置满足：&lt;strong&gt;长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i-k-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前缀S和后缀P相同&lt;/strong&gt;。只有这样，我们才可以前移&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位后从新的位置继续比较&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201215183806.png&#34; alt=&#34;image-20201215183804856&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;KMP&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;算法的核心即是&lt;strong&gt;计算字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;每一个位置之前的字符串的前缀和后缀公共部分的最大长度&lt;/strong&gt;。获得&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;每一个位置的最大公共长度之后，就可以利用该最大公共长度快速和字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当每次比较到两个字符串的字符不同时，我们就可以根据最大公共长度将字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;向前移动(k = 已匹配长度 - 最大公共长度)位，接着继续比较下一个位置&lt;/strong&gt;。事实上，字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前移只是概念上的前移，只要我们在比较的时候从最大公共长度之后比较&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;即可达到字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前移的目的，&lt;strong&gt;在整个匹配过程中都不会出现字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的指针走回头路的情况&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;核心next数组&#34;&gt;核心next数组&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;KMP&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;算法的难点在于，如何计算&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组（仅仅与要去匹配的字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;有关）中的信息？如何根据这些信息正确地移动字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的指针？&lt;/p&gt;
&lt;p&gt;在这里我们需要注意的是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组表示的是长度信息，并且下标从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开始&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i] = j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表达的含义是：长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的字符串的前缀和后缀最大公共长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。表现在字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中就是：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[0, j - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这一段和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[i - j, i - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这一段是匹配相等的，并且是最大的匹配段&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201215203032.png&#34; alt=&#34;image-20201215203031366&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么现在我们已知&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，要求&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i + 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，我们怎么做？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果位置&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i] (j)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;处两个字符相同，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B[i] = B[j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;那么&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i + 1] = next[i] + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201215204222.png&#34; alt=&#34;image-20201215204221441&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果这两个位置的字符不相同：&lt;strong&gt;我们可以将长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的字符串继续分割&lt;/strong&gt;，获得其最大公共长度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[next[i]]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，然后再和位置&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的字符比较。这是因为长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前缀和后缀都可以分割成上部的构造&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201215211022.png&#34; alt=&#34;image-20201215211021807&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;因此，我们得到求&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;KMP&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;算法中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int n[N];
void getNext(string B) {
    int n = B.size();
    ne[0] = ne[1] = 0;
    for (int i = 1, j = 0; i &amp;lt; n; i++) {
        // j每次循环开始都表示next[i]的值
        while (j &amp;amp;&amp;amp; B[i] != B[j])
            j = ne[j];
        if (B[i] == B[j])
            j++;
        ne[i + 1] = j;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字符串匹配&#34;&gt;字符串匹配&lt;/h3&gt;
&lt;p&gt;在计算完成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组后，我们就可以利用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组在字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中寻找字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;出现的位置。&lt;strong&gt;匹配的代码其实和求&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组的代码非常相似，因为匹配过程和求&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组的过程其实是一致的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设现在字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个位置都和从某个位置开始的字符串&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;匹配，现在比较第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个位置&lt;/li&gt;
&lt;li&gt;如果第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个位置相同，接着比较第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个位置&lt;/li&gt;
&lt;li&gt;如果第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个位置不同，则出现不匹配，&lt;strong&gt;我们依旧要将长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的字符串分割，获得其最大公共长度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，然后从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;继续比较两个字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，完整的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;KMP&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;算法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file KMP.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-12-15 21:51:49
 * @brief KMP算法
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

const int N = 100010;
// next数组
int ne[N];
string A, B;

/**
 * @brief Get the Next object
 * @param str 
 */
void getNext(string str) {
    ne[0] = ne[1] = 0;
    for (int i = 1, j = 0; i &amp;lt; str.size(); i++) {
        // j每次循环开始都表示next[i]的值
        while (j &amp;gt; 0 &amp;amp;&amp;amp; str[i] != str[j])
            j = ne[j];
        if (str[i] == str[j])
            j++;
        ne[i + 1] = j;
    }
}

int main() {
    cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B;
    // 求B的next数组
    getNext(B);
    // KMP匹配过程，j从0开始
    for (int i = 0, j = 0; i &amp;lt; A.size(); i++) {
        // 没有匹配上，j后退到next[j]的位置
        while (j &amp;gt; 0 &amp;amp;&amp;amp; A[i] != B[j])
            j = ne[j];
        // 匹配上了
        if (A[i] == B[j])
            j++;
        if (j == B.size()) {
            // 输出匹配起点位置
            cout &amp;lt;&amp;lt; i - j + 1 &amp;lt;&amp;lt; endl;
            // j往后面走，继续匹配看是否还存在匹配的串
            j = ne[j];
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">掐死KMP算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/han-shu-shi-bian-cheng-yu-lambda-biao-da-shi-jin-jie-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在基础篇中，我们介绍了lambda表达式的使用和四种主要的函数式接口，其实lambda表达式还有很多应用的地方，例如方法引用、集合的forEach操作和强大的Stream流式编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;方法引用与-lambda&#34;&gt;方法引用与 lambda&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法引用可以让我们直接访问类的实例或者方法，在 lambda 只是执行一个方法的时候，就可以不用 lambda 的编写方式，而用方法引用的方式：实例/类::方法。这样不仅代码更加的紧凑，而且可以增加代码的可读性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当我们要传递给lambda体的操作已经有实现的方法了，可以使用方法引用，方法引用可以看做是lambda表达式深层次的表达。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要求：&lt;strong&gt;实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;::操作符&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;object::instanceMethod&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Class::staticMethod&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Class::instanceMethod&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两种情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Getter
@Setter
@ToString
@AllArgsConstructor
static class User {
    private String name;
    private Integer age;
}

public static List&amp;lt;User&amp;gt; userList = new ArrayList&amp;lt;&amp;gt;();
static {
    userList.add(new User(&amp;quot;A&amp;quot;, 26));
    userList.add(new User(&amp;quot;B&amp;quot;, 18));
    userList.add(new User(&amp;quot;C&amp;quot;, 23));
    userList.add(new User(&amp;quot;D&amp;quot;, 19));
}

/**
 * 测试方法引用
 */
@Test
public void methodRef() {
    User[] userArr = new User[userList.size()];
    userList.toArray(userArr);
    // User::getAge 调用 getAge 方法
    Arrays.sort(userArr, Comparator.comparing(User::getAge));
    for (User user : userArr) 
        System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们得到结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ name=&#39;B&#39;, age=&#39;18&#39;}
{ name=&#39;D&#39;, age=&#39;19&#39;}
{ name=&#39;C&#39;, age=&#39;23&#39;}
{ name=&#39;A&#39;, age=&#39;26&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;foreach-与-lambda&#34;&gt;forEach 与 lambda&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;带来了新的遍历方式，&lt;strong&gt;Java 8 为集合增加了&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;forEach&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法，它可以接受函数接口进行操作&lt;/strong&gt;。下面看一下 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的集合遍历方式。&lt;/p&gt;
&lt;p&gt;为什么可以进行&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;forEach + lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表达式遍历？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; {

}
public interface Iterable&amp;lt;T&amp;gt; {
    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Collection&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;集合接口继承了&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Iterable&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Iterable&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口中有默认实现方法&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;forEach(Consumer action)，forEach&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中需要传入实现&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Consumer&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这个函数式接口的实现类，那么我们自然可以使用lambda表达式进行集合的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;forEach&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;遍历&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void foreachTest() {
    List&amp;lt;String&amp;gt; skills = Arrays.asList(&amp;quot;Java&amp;quot;, &amp;quot;Golang&amp;quot;, &amp;quot;C++&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;Python&amp;quot;);
    // 使用 lambda 之前
    for (String skill : skills) {
        System.out.print(skill + &amp;quot;,&amp;quot;);
    }
    System.out.println();
    // 使用 lambda 之后
    // 方式1,forEach lambda
    skills.forEach((skill) -&amp;gt; System.out.print(skill + &amp;quot;,&amp;quot;));
    System.out.println();
    // 方式2，forEach 方法引用
    skills.forEach(System.out::print);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们得到结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Java,Golang,C++,C,Python,
Java,Golang,C++,C,Python,
JavaGolangC++CPython
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;stream-与-lambda&#34;&gt;Stream 与 lambda&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Stream&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;使用一种&lt;strong&gt;类似用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;SQL&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;语句从数据库查询数据的直观方式来提供一种对Java​集合运算和表达的高阶抽象&lt;/strong&gt;。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Stream API&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。&lt;br&gt;
得益于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的引入，让 Java 8 中的流式操作成为可能，Java 8 提供了&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;stream&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;类用于获取数据流。&lt;br&gt;
这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。&lt;strong&gt;元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201215152826.png&#34; alt=&#34;image-20201215152824768&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;创建stream&#34;&gt;创建Stream&lt;/h3&gt;
&lt;p&gt;数据源来源可以是集合、数组、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;I/O \ channel&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、产生器&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;generator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.80952em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 创建Stream：
 *      通过集合
 *      Stream.of()
 *      Arrays.stream()
 */
@Test
public void test1() {
    List&amp;lt;User&amp;gt; users = UserData.getUsers();
    // 通过集合来创建Stream
    Stream&amp;lt;User&amp;gt; stream = users.stream();
    // 获得并行流
    Stream&amp;lt;User&amp;gt; parallelStream = users.parallelStream();
    // 通过Stream.of()来创建Stream
    Stream&amp;lt;String&amp;gt; stream1 = Stream.of(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;);
    // 通过Arrays.stream()来创建
    Integer[] arrs = new Integer[]{1, 2, 3, 4, 5, 6};
    Stream&amp;lt;Integer&amp;gt; stream2 = Arrays.stream(arrs);
    // 创建无限流
    // public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; iterate(final T seed, final UnaryOperator&amp;lt;T&amp;gt; f)
    Stream.iterate(0, t -&amp;gt; t + 2).limit(10).forEach(System.out::println);
    System.out.println(&amp;quot;----------------&amp;quot;);
    // public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; generate(Supplier&amp;lt;T&amp;gt; s)
    Stream.generate(Math::random).limit(10).forEach(System.out::println);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;中间操作&#34;&gt;中间操作&lt;/h3&gt;
&lt;p&gt;多个中间操作可以连接起来形成一个流水线，除非流水线上出发终止操作。否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为“惰性求值”&lt;/p&gt;
&lt;h4 id=&#34;筛选和切片&#34;&gt;筛选和切片&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;filter(Predicate\  p)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：接收lambda，从流中排除某些元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;distinct()&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：筛选，通过流所生成元素的&lt;code&gt;hashCode()&lt;/code&gt;和&lt;code&gt;equals()&lt;/code&gt;去除重复元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;limit(long\ maxSize)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：截断流，使其元素不超过给定数量&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;skip(long\ n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：跳过元素，返回一个扔掉了前 &lt;code&gt;n&lt;/code&gt; 个元素的流，若流中元素不足 &lt;code&gt;n&lt;/code&gt; 个，则返回一个空流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 筛选和切片
 * limit(), distinct(), filter(), skip()
 */
@Test
public void test2() {
    Stream&amp;lt;Integer&amp;gt; stream = Stream.of(6, 4, 6, 7, 3, 9, 8, 10, 12, 14, 14);
    Stream&amp;lt;Integer&amp;gt; newStream = stream.filter(s -&amp;gt; s &amp;gt; 5) // 6 6 7 9 8 10 12 14 14(筛选出 &amp;gt; 5 的元素)
            .distinct() // 6 7 9 8 10 12 14 (去重)
            .skip(2) // 9 8 10 12 14 (跳过前两个)
            .limit(2); // 9 8 (截断前两个)
    newStream.forEach(System.out::println); // 终止操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;映射&#34;&gt;映射&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;map(Function\ f)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;flatMap(Function\ f)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：接收一个函数作为参数，将流中每个值斗转成另一个流，然后把所有流连成一个流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 映射map()， flatMap()
 */
@Test
public void test3() {
    List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;a,b,c&amp;quot;, &amp;quot;1,2,3&amp;quot;);
    // 将每个元素转换成一个新的不带逗号的元素
    Stream&amp;lt;String&amp;gt; stream1 = list.stream().map(s -&amp;gt; s.replaceAll(&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;));
    stream1.forEach(System.out::println);   // abc 123
    System.out.println(&amp;quot;--------------&amp;quot;);
    Stream&amp;lt;String&amp;gt; stream2 = list.stream().flatMap(s -&amp;gt; {
        String[] split = s.split(&amp;quot;,&amp;quot;);
        return Arrays.stream(split);
    });
    stream2.forEach(System.out::println);   // a b c 1 2 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;排序&#34;&gt;排序&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sorted()&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：产生一个新流，其中按自然顺序排序&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sorted(Comparator\ com)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：产生一个新流，其中按比较器顺序排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 排序sort()
 */
@Test
public void test4() {
    List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;aa&amp;quot;, &amp;quot;ff&amp;quot;, &amp;quot;dd&amp;quot;);
    //String 类自身已实现Compareable接口
    list.stream().sorted().forEach(System.out::println);// aa dd ff
    
    User u1 = new User(&amp;quot;aa&amp;quot;, 10);
    User u2 = new User(&amp;quot;bb&amp;quot;, 20);
    User u3 = new User(&amp;quot;aa&amp;quot;, 30);
    User u4 = new User(&amp;quot;dd&amp;quot;, 40);
    List&amp;lt;User&amp;gt; users = Arrays.asList(u1, u2, u3, u4);
    
    //自定义排序：先按姓名升序，姓名相同则按年龄升序
    users.stream().sorted((o1, o2) -&amp;gt; {
        if (o1.getName().equals(o2.getName()))
            return o1.getAge() - o2.getAge();
        else
            return o1.getName().compareTo(o2.getName());
    }).forEach(System.out::println);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;终止操作&#34;&gt;终止操作&lt;/h3&gt;
&lt;p&gt;终止操作会从流的流水线生成结果。其结果可以使任何不适流的值，例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;List、Integer&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，甚至是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;void&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。并且流进行了终止操作后，不能再次使用&lt;/p&gt;
&lt;h4 id=&#34;匹配与查找&#34;&gt;匹配与查找&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;allMatch(Predicate\ p)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：检查是否匹配所有元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;anyMatch(Predicate\ p)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：检查是否至少匹配一个元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;noneMatch(Predicate\ p)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：检查是否没有匹配所有元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;findFirst()&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：返回第一个元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;findAny()&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：返回当前流任意元素&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;count()&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：返回流中元素的总个数&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;max(Comparator\ c)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：返回流中元素最大值&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;min(Comparator\ c)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：返回流中元素最小值&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;forEach(Consumer\ c)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：内部迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 匹配和查找
 */
@Test
public void test5() {
    List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5);

    boolean allMatch = list.stream().allMatch(e -&amp;gt; e &amp;gt; 10); // false
    boolean noneMatch = list.stream().noneMatch(e -&amp;gt; e &amp;gt; 10); // true
    boolean anyMatch = list.stream().anyMatch(e -&amp;gt; e &amp;gt; 4); // true

    Integer findFirst = list.stream().findFirst().get(); // 1
    Integer findAny = list.stream().findAny().get(); // 1

    long count = list.stream().count(); //5
    Integer max = list.stream().max(Integer::compareTo).get(); //5
    Integer min = list.stream().min(Integer::compareTo).get(); //1　
    
    list.stream().forEach(System.out::println); // 1 2 3 4 5
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;规约&#34;&gt;规约&lt;/h4&gt;
&lt;p&gt;首先我们看一下&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;BinaryOperator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;BiFunction&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的接口信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface BinaryOperator&amp;lt;T&amp;gt; extends BiFunction&amp;lt;T,T,T&amp;gt; {
    ...
}

@FunctionalInterface
public interface BiFunction&amp;lt;T, U, R&amp;gt; {
    R apply(T t, U u);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;BinaryOperator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这个接口继承&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;BiFunction&amp;lt;T, T, T&amp;gt;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72243em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口，当我们向&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;BinaryOperator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口实现类传入一个参数类型为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的参数，就相当于我们传入&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;BiFunction&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这个接口两个类型都为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的参数，返回类型也是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这样就方便我们理解其&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;reduce&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的下面操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Optional&amp;lt;T&amp;gt; reduce(BinaryOperator\ accumulator)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72243em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：第一次执行时，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;accumulator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T reduce(T\ identity, BinaryOperator\ accumulator)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：流程跟上面一样，只是第一次执行时，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;accumulator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;函数的第一个参数为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;identity&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，而第二个参数为流中的第一个元素。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;U reduce(U\ identity,BiFunction&amp;lt;U, ?\ super\ T, U&amp;gt;\ accumulator,BinaryOperator\ combiner)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：在串行流&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Stream&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中，该方法跟第二个方法一样，即第三个参数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;combiner&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不会起作用。在并行流&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;parallelStream&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中,我们知道流被&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;fork\ join&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;出多个线程进行执行，此时&lt;strong&gt;每个线程的执行流程就跟第二个方法&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;reduce(identity,accumulator)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;一样，而第三个参数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;combiner&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;函数，则是将每个线程的执行结果当成一个新的流，然后使用第一个方法&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;reduce(accumulator)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;流程进行规约&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 规约reduce()
 */
@Test
public void test6() {
    List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5);
    Integer reduce1 = list.stream().reduce(0, (t1, t2) -&amp;gt; t1 + t2);
    System.out.println(&amp;quot;list总和：&amp;quot;+ reduce1); // 15
    System.out.println(&amp;quot;--------------&amp;quot;);
    User u1 = new User(&amp;quot;aa&amp;quot;, 10);
    User u2 = new User(&amp;quot;bb&amp;quot;, 20);
    User u3 = new User(&amp;quot;aa&amp;quot;, 30);
    User u4 = new User(&amp;quot;dd&amp;quot;, 40);
    List&amp;lt;User&amp;gt; users = Arrays.asList(u1, u2, u3, u4);
    // 计算年龄总和
    Optional&amp;lt;Integer&amp;gt; reduce2 = users.stream().map(User::getAge).reduce(Integer::sum);
    System.out.println(&amp;quot;年龄总和：&amp;quot; + reduce2);
    System.out.println(&amp;quot;-------------&amp;quot;);
    Integer reduce3 = list.parallelStream().reduce(0, (x1, x2) -&amp;gt; {
        System.out.println(&amp;quot;parallelStream accumulator: x1:&amp;quot; + x1 + &amp;quot; x2:&amp;quot; + x2); 
        return x1 - x2;
    }, (x1, x2) -&amp;gt; {
        System.out.println(&amp;quot;parallelStream combiner: x1:&amp;quot; + x1 + &amp;quot; x2:&amp;quot; + x2);
        return x1 * x2;
    });
    System.out.println(reduce3);    // -120
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;收集&#34;&gt;收集&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;collect(Collector\ c)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：将流转换为其他形式。接收一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Collector&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口的实现，用于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Stream&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中元素做汇总的方法（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Collector&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口中方法的实现决定了如何对流执行收集的操作：如收集到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;List、Set、Map&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 收集collect()
 */
@Test
public void test7() {
    User s1 = new User(&amp;quot;aa&amp;quot;, 10);
    User s2 = new User(&amp;quot;bb&amp;quot;, 20);
    User s3 = new User(&amp;quot;cc&amp;quot;, 10);
    List&amp;lt;User&amp;gt; list = Arrays.asList(s1, s2, s3);

    // 装成list
    List&amp;lt;Integer&amp;gt; ageList = list.stream().map(User::getAge).collect(Collectors.toList()); // [10, 20, 10]
    System.out.println(ageList); // [10, 20, 10]
    // 转成set
    Set&amp;lt;Integer&amp;gt; ageSet = list.stream().map(User::getAge).collect(Collectors.toSet()); 
    System.out.println(ageSet); // [20, 10]
    // 转成map,注:key不能相同，否则报错
    Map&amp;lt;String, Integer&amp;gt; userMap = list.stream().collect(Collectors.toMap(User::getName, User::getAge)); // {cc=10, bb=20, aa=10}
    System.out.println(userMap);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;lambda总结&#34;&gt;lambda总结&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lamdba&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;结合函数接口，方法引用，类型推导以及流式操作，可以让代码变得更加简洁紧凑，也可以借此开发出更加强大且支持并行计算的程序，函数编程也为 Java 带来了新的程序设计方式。但是缺点也很明显，在实际的使用过程中可能会发现调式困难，测试表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lamdba&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的遍历性能并不如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;for&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的性能高。&lt;/p&gt;
">函数式编程与lambda表达式（进阶篇）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/han-shu-shi-bian-cheng-yu-lambda-biao-da-shi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Java 8 早已经在2014 年 3月 18日发布，毫无疑问 Java 8 对 Java 来说绝对算得上是一次重大版本更新，它包含了十多项语言、库、工具、JVM 等方面的新特性。&lt;br&gt;
比如提供了语言级的匿名函数，也就是被官方称为 lambda 的表达式语法（外界也称为闭包，lambda 的引入也让流式操作成为可能，减少了代码编写的复杂性），比如函数式接口，方法引用，重复注解。再比如 Optional 预防空指针，Stearm 流式操作，LocalDateTime 时间操作等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;为什么使用lambda表达式&#34;&gt;为什么使用lambda表达式？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少代码编写的复杂性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;让流式操作称为可能&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Stream\ API&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void createLambda() throws InterruptedException {
    // 使用 Lambda 之前
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println(&amp;quot;JDK8 之前的线程创建&amp;quot;);
        }
    };
    new Thread(runnable).start();
    // 使用 lambda 之后
    Runnable runnable1Jdk8 = () -&amp;gt; System.out.println(&amp;quot;JDK8 之后的线程创建&amp;quot;);
    new Thread(runnable1Jdk8).start();
    // 更加紧凑的方式
    new Thread(() -&amp;gt; System.out.println(&amp;quot;JDK8 之后的线程创建&amp;quot;)).start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现 Java 8 中的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;碰到了函数接口&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Runnable&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，自动推断了要运行的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;run&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法，不仅省去了&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;run&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法的编写，也代码变得更加紧凑&lt;/p&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;lambda表达式的使用&#34;&gt;lambda表达式的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1. (params) -&amp;gt; expression
2. (params) -&amp;gt; {statements;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-&amp;gt;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; : 分割&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;参数和处理语句&lt;/li&gt;
&lt;li&gt;左边：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;形参列表：其实就是&lt;strong&gt;接口中抽象方法的形参列表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;右边：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;体：重写的抽象方法体&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;无参数无返回值&#34;&gt;无参数无返回值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test1() {
    Runnable r1 = new Runnable(){
        @Override
        public void run() {
            System.out.println(&amp;quot;Rick&amp;quot;);
        }
    };
    r1.run();
    System.out.println(&amp;quot;---------------&amp;quot;);
    Runnable r2 = () -&amp;gt; System.out.println(&amp;quot;Rick&amp;quot;);
    r2.run();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lambda需要一个参数但是没有返回值&#34;&gt;lambda需要一个参数，但是没有返回值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test2() {
    Consumer&amp;lt;String&amp;gt; con1 = new Consumer&amp;lt;String&amp;gt;(){

        @Override
        public void accept(String t) {
            System.out.println(t);
        }
        
    };
    con1.accept(&amp;quot;Rick&amp;quot;);
    System.out.println(&amp;quot;-----------------------&amp;quot;);
    Consumer&amp;lt;String&amp;gt; con2 = (String t) -&amp;gt; {
        System.out.println(t);
    };
    con2.accept(&amp;quot;Rick&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据类型可以省略可由编译器推断得出&#34;&gt;数据类型可以省略，可由编译器推断得出&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test3() {
    Consumer&amp;lt;String&amp;gt; con3 = (t) -&amp;gt; {
        System.out.println(t);
    };
    con3.accept(&amp;quot;Rick&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lamdba只需要一个参数时小括号可省略&#34;&gt;lamdba只需要一个参数时，小括号可省略&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test4() {
    Consumer&amp;lt;String&amp;gt; con4 = t -&amp;gt; {
        System.out.println(t);
    };
    con4.accept(&amp;quot;Rick&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lambda需要不止一个参数且有返回值&#34;&gt;lambda需要不止一个参数，且有返回值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test5() {   
    Comparator&amp;lt;Integer&amp;gt; com = new Comparator&amp;lt;Integer&amp;gt;(){
        @Override
        public int compare(Integer o1, Integer o2) {
            return Integer.compare(o1, o2);
        }
    };
    System.out.println(com.compare(12, 14));
    System.out.println(&amp;quot;---------------&amp;quot;);
    Comparator&amp;lt;Integer&amp;gt; com5 = (o1, o2) -&amp;gt; {
        return Integer.compare(o1, o2);
    };
    System.out.println(com5.compare(12, 14));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;当lambda体只有一条语句时return与大括号若有都可省略&#34;&gt;当lambda体只有一条语句时，return与大括号若有，都可省略&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test6() {
    Comparator&amp;lt;Integer&amp;gt; com6 = (o1, o2) -&amp;gt; Integer.compare(o1, o2);
    System.out.println(com6.compare(12, 14));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;Java 中的函数接口在使用时，可以隐式的转换成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表达式，在Java 8中已经有很多接口已经声明为函数接口，如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Runnable, Callable, Comparator&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;等。&lt;br&gt;
我们来看&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Runnable&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么什么样子的接口才是函数接口呢？有一个很简单的定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一个抽象函数的接口，函数接口使用注解 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 进行声明（注解声明不是必须的，如果没有注解，也是只有一个抽象函数，依旧会被认为是函数接口，并且该接口是一个编译级别的注解，用于检测函数式接口是否有错而已）&lt;/li&gt;
&lt;li&gt;多一个或者少一个抽象函数都不能定义为函数接口。&lt;strong&gt;但是，函数式接口里是可以包含默认方法、静态方法和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Object&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;里的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;public&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法，因为这些方法就不是抽象方法了，其有默认实现&lt;/strong&gt;，所以是符合函数式接口的定义&lt;/li&gt;
&lt;li&gt;如果使用了函数接口注解又不止一个抽象函数，那么编译器会拒绝编译。函数接口在使用时候可以隐式的转换成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;消费性接口consumer接收一个参数t没有返回值&#34;&gt;消费性接口Consumer：接收一个参数T，没有返回值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {
    void accept(T t);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test1() {
    StringBuilder sb = new StringBuilder(&amp;quot;Hello &amp;quot;);
    Consumer&amp;lt;StringBuilder&amp;gt; consumer = (str) -&amp;gt; str.append(&amp;quot;World!&amp;quot;);
    consumer.accept(sb);
    System.out.println(sb);     // Hello World!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;供给型接口supplier不接受任何参数但有返回值&#34;&gt;供给型接口Supplier：不接受任何参数但有返回值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Supplier&amp;lt;T&amp;gt; {
    T get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test2() {
    Supplier&amp;lt;String&amp;gt; supplier = () -&amp;gt; &amp;quot;Hello World!&amp;quot;;
    System.out.println(supplier.get());     // Hello World!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;断言性接口predicate判断方法的参数是否符合断言&#34;&gt;断言性接口Predicate：判断方法的参数是否符合断言&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Predicate&amp;lt;T&amp;gt; {
    boolean test(T t);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试过滤字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test3() {
    List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;ABC&amp;quot;, &amp;quot;ADR&amp;quot;, &amp;quot;CDK&amp;quot;, &amp;quot;ABU&amp;quot;);
    System.out.println(filterString(list, new Predicate&amp;lt;String&amp;gt;(){
        @Override
        public boolean test(String t) {
            return t.contains(&amp;quot;A&amp;quot;);
        }
    }));
    System.out.println(&amp;quot;------------------&amp;quot;);
    // (s) -&amp;gt; s.contains(&amp;quot;A&amp;quot;)) ：筛选出含有A
    System.out.println(filterString(list, (s) -&amp;gt; s.contains(&amp;quot;A&amp;quot;)));
}

/**
 * 过滤列表中的字符串
 * @param list
 * @param pr
 * @return
 */
public List&amp;lt;String&amp;gt; filterString (List&amp;lt;String&amp;gt; list, Predicate&amp;lt;String&amp;gt; pr) {
    List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    for (String str : list) {
        if (pr.test(str)) 
            res.add(str);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;功能性接口function接收一个功能参数t并返回一个功能结果r&#34;&gt;功能性接口Function：接收一个功能参数T，并返回一个功能结果R&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test4() {
    Function&amp;lt;String, String&amp;gt; function = (s1) -&amp;gt; s1 + &amp;quot;World!&amp;quot;;
    System.out.println(function.apply(&amp;quot;Hello &amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
">函数式编程与lambda表达式（基础篇）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/leetcode-zhuan-ji-3-lian-biao/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;链表是一种非常基础的数据结构，其中算法的题目难度一般都不是很大，重点在于画图理解、处理好边界条件和保留相关节点信息防止遍历后找不到所需节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;题目列表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&#34;&gt;19. 删除链表的倒数第N个节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/merge-two-sorted-lists/&#34;&gt;21. 合并两个有序链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/swap-nodes-in-pairs/&#34;&gt;24. 两两交换链表中的节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&#34;&gt;83. 删除排序链表中的重复元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&#34;&gt;160. 相交链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/reverse-linked-list/&#34;&gt;206. 反转链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/palindrome-linked-list/&#34;&gt;234. 回文链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/odd-even-linked-list/&#34;&gt;328. 奇偶链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/add-two-numbers-ii/&#34;&gt;445. 两数相加 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/split-linked-list-in-parts/&#34;&gt;725. 分隔链表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;删除链表的倒数第n个节点&#34;&gt;删除链表的倒数第N个节点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先统计链表中有&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sum&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个结点&lt;/li&gt;
&lt;li&gt;找到倒数第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个节点&lt;/li&gt;
&lt;li&gt;删除&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69841em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dummy = new ListNode(-1);
        dummy-&amp;gt;next = head;
        // 记录链表一共有多少个节点
        int sum = 0;
        while (head != nullptr) {
            sum++;
            head = head-&amp;gt;next;
        }
        // 找到倒数第 n + 1个节点
        auto p = dummy;
        for (int i = 0 ; i &amp;lt; sum - n; i++)
            p = p-&amp;gt;next;
        p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next;
        return dummy-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;合并两个有序链表&#34;&gt;合并两个有序链表&lt;/h2&gt;
&lt;h3 id=&#34;双指针&#34;&gt;双指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关键在于定义虚拟头结点，防止返回结果找不到头结点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr)
            return l2;
        if (l2 == nullptr)
            return l1; 
        // 定义虚拟头结点
        ListNode* dummy = new ListNode(-1);
        ListNode* tail = dummy;
        // 归并
        while (l1 != nullptr &amp;amp;&amp;amp; l2 != nullptr) {
            if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) {
                tail-&amp;gt;next = l1;
                l1 = l1-&amp;gt;next;
            }
            else {
                tail-&amp;gt;next = l2;
                l2 = l2-&amp;gt;next;
            }
            tail = tail-&amp;gt;next;
        }
        if (l1 != nullptr) 
            tail-&amp;gt;next = l1;
        if (l2 != nullptr)
            tail-&amp;gt;next = l2;
        // 返回链表：不返回虚拟头结点
        return dummy-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;递归&#34;&gt;递归&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if (l1 == nullptr)
            return l2;
        if (l2 == nullptr)
            return l1;

        if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) {
            l1-&amp;gt;next = mergeTwoLists(l1-&amp;gt;next, l2);
            return l1;
        } else {
            l2-&amp;gt;next = mergeTwoLists(l1, l2-&amp;gt;next);
            return l2;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两两交换链表中的节点&#34;&gt;两两交换链表中的节点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注意这里和反转链表的区别：&lt;strong&gt;两两交换相邻的节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;每次指向要交换两个结点的前一个结点&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201213190243.png&#34; alt=&#34;image-20201213190242011&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head-&amp;gt;next == nullptr)
            return head;
        // 建立虚拟头结点
        auto dummy = new ListNode(-1);
        dummy-&amp;gt;next = head;
        auto p = dummy;
        while (p-&amp;gt;next != nullptr &amp;amp;&amp;amp; p-&amp;gt;next-&amp;gt;next != nullptr) {
            auto a = p-&amp;gt;next;
            auto b = p-&amp;gt;next-&amp;gt;next;
            p-&amp;gt;next = b;
            a-&amp;gt;next = b-&amp;gt;next;
            b-&amp;gt;next = a;
            p = a;
        }
        return dummy-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除排序链表中的重复元素&#34;&gt;删除排序链表中的重复元素&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;找到结点值相同的结点删除&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69841em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == nullptr || head-&amp;gt;next == nullptr)
            return head;
        auto p = head;
        while (p-&amp;gt;next != nullptr) {
            if (p-&amp;gt;val == p-&amp;gt;next-&amp;gt;val) {
                p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next;
            }
            else 
                p = p-&amp;gt;next;
        }
        return head;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相交链表&#34;&gt;相交链表&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201213163950.png&#34; alt=&#34;image-20201213163845701&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;headA&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;走到尾结点的时候，将指针指向&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;headB&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;往前走；&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;headB&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;走到尾结点的时候，将指针指向&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;headA&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;往前走&lt;/li&gt;
&lt;li&gt;走到相交点的时候：走的总路程都是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L1 + L2 + L&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr)
            return nullptr;
        ListNode* pa = headA;
        ListNode* pb = headB;
        while (pa != pb) {
            if (pa == nullptr)
                pa = headB;
            else 
                pa = pa-&amp;gt;next;
            if (pb == nullptr)
                pb = headA;
            else 
                pb = pb-&amp;gt;next;
        }
        return pa;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;反转链表&#34;&gt;反转链表&lt;/h2&gt;
&lt;h3 id=&#34;迭代&#34;&gt;迭代&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201213170315.png&#34; alt=&#34;image-20201213170315084&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr)
            return nullptr;
        ListNode* p = head;
        ListNode* q = head-&amp;gt;next;
        while (q != nullptr) {
            ListNode* temp = q-&amp;gt;next;
            // 改变指针走向
            q-&amp;gt;next = p;
            // 顺次往后移动
            p = q;
            q = temp;
        }
        head-&amp;gt;next = nullptr;
        return p;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;递归-2&#34;&gt;递归&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        if (head == nullptr || head-&amp;gt;next == nullptr)
            return head;
        ListNode *tail = reverseList(head-&amp;gt;next);
        head-&amp;gt;next-&amp;gt;next = head;
        head-&amp;gt;next = nullptr;
        return tail;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回文链表&#34;&gt;回文链表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要使用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的空间来做：那么我们就不能遍历时候将节点值存储下来去判断&lt;/li&gt;
&lt;li&gt;先统计链表中节点的个数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;half = n/2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;向下取整是链表的一半（向下取整目的为了无需判断奇偶数的影响，跳&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - half&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;步一定是后一半的头结点）&lt;/li&gt;
&lt;li&gt;从头结点开始跳&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - half&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;步找到后一半的头结点&lt;/li&gt;
&lt;li&gt;将后半部分反转&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;half - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;次（反转链表操作）&lt;/li&gt;
&lt;li&gt;双指针判断是否是回文链表&lt;/li&gt;
&lt;li&gt;将后半部分链表恢复（否则过不了LeetCode评测）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 记录链表一共有多少个结点
        int n = 0;
        auto p = head;
        while (p != nullptr) {
            p = p-&amp;gt;next;
            n++;
        }
        if (n &amp;lt;= 1)
            return true;
        int half = n / 2;
        auto a = head;
        // 跳 n - half次到后面一半的头结点
        for (int i = 0; i &amp;lt; n - half; i++)
            a = a-&amp;gt;next;
        auto b = a-&amp;gt;next;
        // 翻转 half - 1 次
        for (int i = 0; i &amp;lt; half - 1; i++) {
            auto c = b-&amp;gt;next;
            b-&amp;gt;next = a;
            a = b;
            b = c;
        }
        // 双指针判断是否回文链表
        p = head;
        auto q = a;
        bool res = true;
        for (int i = 0; i &amp;lt; half; i++) {
            if (p-&amp;gt;val != q-&amp;gt;val) {
                res = false;
                break;
            }
            p = p-&amp;gt;next;
            q = q-&amp;gt;next;
        }
        // 将链表恢复：再次翻转 half - 1 次
        auto tail = a;
        b = a-&amp;gt;next;
        for (int i = 0; i &amp;lt; half - 1; i++) {
            auto c = b-&amp;gt;next;
            b-&amp;gt;next = a;
            a = b;
            b = c;
        }
        tail-&amp;gt;next = nullptr;

        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;奇偶链表&#34;&gt;奇偶链表&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201213193347.png&#34; alt=&#34;image-20201213193345885&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (head == nullptr || head-&amp;gt;next == nullptr)
            return head;
        auto odd = head, evenhead = head-&amp;gt;next, even = evenhead;
        while (even != nullptr &amp;amp;&amp;amp; even-&amp;gt;next != nullptr) {
            odd-&amp;gt;next = odd-&amp;gt;next-&amp;gt;next;
            even-&amp;gt;next = even-&amp;gt;next-&amp;gt;next;
            odd = odd-&amp;gt;next;
            even = even-&amp;gt;next;
        }
        odd-&amp;gt;next = evenhead;
        return head;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两数相加-ii&#34;&gt;两数相加 II&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 高精度加法
     * @param a 
     * @param b 
     * @return vector&amp;lt;int&amp;gt; 
     */
    static vector&amp;lt;int&amp;gt; add(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) {
        vector&amp;lt;int&amp;gt; c;
        int t = 0;
        for (int i = 0; i &amp;lt; a.size() || i &amp;lt; b.size(); i++) {
            if (i &amp;lt; a.size())
                t += a[i];
            if (i &amp;lt; b.size())
                t += b[i];
            c.push_back(t % 10);
            t /= 10;
        }
        if (t &amp;gt; 0)
            c.push_back(1);
        return c;
    }

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        vector&amp;lt;int&amp;gt; v1, v2, res;
        while (l1 != nullptr) {
            v1.push_back(l1-&amp;gt;val);
            l1 = l1-&amp;gt;next;
        }
        while (l2 != nullptr) {
            v2.push_back(l2-&amp;gt;val);
            l2 = l2-&amp;gt;next;
        }
        reverse(v1.begin(), v1.end());
        reverse(v2.begin(), v2.end());
        res = add(v1, v2);
        auto dummy = new ListNode(-1), p = dummy;
        for (int i = res.size() - 1; i &amp;gt;= 0; i--) {
            p-&amp;gt;next = new ListNode(res[i]);
            p = p-&amp;gt;next;
        }
        return dummy-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分隔链表&#34;&gt;分隔链表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;ListNode*&amp;gt; splitListToParts(ListNode* root, int k) {
        vector&amp;lt;ListNode*&amp;gt; res;
        int n = 0;
        auto p = root;
        while (p != nullptr) {
            n++;
            p = p-&amp;gt;next;
        }
        int a = n / k;
        int b = n % k;
        p = root;
        // b个组元素是 a + 1个
        for (int i = 0; i &amp;lt; b; i++) {
            auto dummy = new ListNode(-1), q = dummy;
            for (int i = 0; i &amp;lt; a + 1; i++) {
                q-&amp;gt;next = new ListNode(p-&amp;gt;val);
                q = q-&amp;gt;next;
                p = p-&amp;gt;next;
            }
            res.push_back(dummy-&amp;gt;next);
        }
        // k - b个组元素是 a 个
        for (int i = 0; i &amp;lt; k - b; i++) {
            auto dummy = new ListNode(-1), q = dummy;
            for (int i = 0; i &amp;lt; a; i++) {
                q-&amp;gt;next = new ListNode(p-&amp;gt;val);
                q = q-&amp;gt;next;
                p = p-&amp;gt;next;
            }
            res.push_back(dummy-&amp;gt;next);
        } 
        while (res.size() &amp;lt; k) 
            res.push_back(nullptr);
        
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">【LeetCode专辑 - 3】链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/cong-wei-fen-ji-fen-kan-qian-zhui-he-chai-fen/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;前缀和差分互为逆运算，他们关系很像数学中的微分和积分。这两种算法能有效解决数组某段区间的和以及对某段区间加上一个同一个数的问题，下面介绍其应用场景及模板方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;前缀和&#34;&gt;前缀和&lt;/h2&gt;
&lt;p&gt;原数组A： &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[1], a[2], a[3], ... a[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，前缀和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为数组的前i项和（前缀和的下标一定要从1开始，避免进行下表的转换）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用：快速求出元素组中某段区间的和&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;一维数组前缀和&#34;&gt;一维数组前缀和&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造前缀和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s[i]  = s[i - 1] + a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;求数组A区间&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[l, r]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间的和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s[r] - s[l - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。第二行包含n个整数，表示整数数列。接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共m行，每行输出一个询问的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;列&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;元&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;素&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤l≤r≤n,
1≤n,m≤100000,
−1000≤ 数列中元素的值 ≤1000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;列&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;元&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;素&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 3
2 1 3 6 4
1 2
1 3
2 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
6
10
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
const int N = 100010;
int a[N], S[N];
int n, m;

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    S[0] = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
        cin &amp;gt;&amp;gt; a[i];
        S[i] = S[i - 1] + a[i];
    }
    while (m--) {
        int l, r;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        cout &amp;lt;&amp;lt; S[r] - S[l - 1] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二维数组前缀和&#34;&gt;二维数组前缀和&lt;/h3&gt;
&lt;/br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;求前缀和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S[i] [j] = s[i - 1][j] + s[i] [j - 1] - s[i - 1] [j - 1] + a[i] [j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201209192321.png&#34; alt=&#34;image-20201209192319820&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;求解子矩阵&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(x1, y1), (x2, y2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的和子矩阵中的和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s[x2] [y2] - s[x2] [y1 - 1] - s[x1 - 1] [y2] + s[x1 - 1] [y1 - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201209170925.png&#34; alt=&#34;image-20201209170923955&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个整数n，m，q。接下来n行，每行包含m个整数，表示整数矩阵。接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共q行，每行输出一个询问的结果。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;数据范围&lt;/h4&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;200000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;矩&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;阵&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;内&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;元&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;素&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,m≤1000,
1≤q≤200000,
1≤x1≤x2≤n,
1≤y1≤y2≤m,
−1000≤矩阵内元素的值≤1000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;矩&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;阵&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;内&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;元&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;素&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;17
27
21
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
const int N = 1010;
int a[N][N], s[N][N];
int n, m, q;

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    s[0][0] = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
        for (int j = 1; j &amp;lt;= m; j++) {
            cin &amp;gt;&amp;gt; a[i][j];
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
        }
    }
    
    while (q--) {
        int x1, y1, x2, y2;
        cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2;
        cout &amp;lt;&amp;lt; s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;差分&#34;&gt;差分&lt;/h2&gt;
&lt;p&gt;原数组A： &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[1], a[2], a[3], ... a[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，构造数组B： &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b[1], b[2], b[3], ... b[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 使得&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i] = b[1] + b[2] + b[3] + ... + b[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;应用：&lt;strong&gt;使数组A的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[l ,r]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;区间都加上c，我们只需要使&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b[l] += c, b[r + 1] -= c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，然后通过前缀和再求原数组就完成运算，时间复杂度从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 优化至&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;一维差分&#34;&gt;一维差分&lt;/h3&gt;
&lt;p&gt;输入一个长度为n的整数序列。接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。请你输出进行完所有操作后的序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。第二行包含n个整数，表示整数序列。接下来m行，每行包含三个整数l，r，c，表示一个操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含n个整数，表示最终序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;整&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;列&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;元&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;素&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,m≤100000,
1≤l≤r≤n,
−1000≤c≤1000,
−1000≤整数序列中元素的值≤1000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;整&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;列&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;元&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;素&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4 5 3 4 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;
int s[N], b[N];
int n, m;

int main(){
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1;i &amp;lt;= n;i++) 
        cin &amp;gt;&amp;gt; s[i];

    //构造差分数组
    for(int i = 1;i &amp;lt;= n;i++) 
        b[i] = s[i] - s[i - 1];

    while(m--){
        int l, r, c;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;
        b[l] += c;//将l和以后加c
        b[r + 1] -= c;//将r之后-c
    }

    for(int i = 1;i &amp;lt;= n; i++){
        b[i] = b[i - 1] + b[i];//将差分改为原数组
        cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; &#39; &#39;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二维差分&#34;&gt;二维差分&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b[x1] [y1] += c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b[x2 + 1] [y1] -= c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b[x1] [y2 + 1] -= c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b[x2 + 1] [y2 + 1] += c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201209195119.png&#34; alt=&#34;image-20201209195118222&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上c。请你将进行完所有操作后的矩阵输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n,m,q。接下来n行，每行包含m个整数，表示整数矩阵。接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;矩&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;阵&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;内&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;元&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;素&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,m≤1000,
1≤q≤100000,
1≤x1≤x2≤n,
1≤y1≤y2≤m,
−1000≤c≤1000,
−1000≤矩阵内元素的值≤1000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;矩&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;阵&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;内&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;元&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;素&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 3 4 1
4 3 4 1
2 2 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;

const int N = 1010;
int a[N][N], b[N][N];
int n, m, q;

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    for(int i = 1; i &amp;lt;= n; i++)
        for(int j = 1; j &amp;lt;= m; j++)
            cin &amp;gt;&amp;gt; a[i][j];
    // 计算差分数组
    for(int i = 1; i &amp;lt;= n; i++)
        for(int j = 1; j &amp;lt;= m; j++) {
            b[i][j] += a[i][j];
            b[i + 1][j] -= a[i][j];
            b[i][j + 1] -= a[i][j];
            b[i + 1][j + 1] += a[i][j];
        }

    while(q--) {
        int x1, y1, x2, y2, c;
        cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; c;
        b[x1][y1] += c;
        b[x2 + 1][y1] -= c;
        b[x1][y2 + 1] -= c;
        b[x2 + 1][y2 + 1] += c;
    }
    //对差分求前缀和
     for(int i = 1; i &amp;lt;= n; i++) {
        for(int j = 1; j &amp;lt;= m; j++) {
            b[i][j] += b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];
            cout &amp;lt;&amp;lt; b[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; endl;
     }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">从微分积分看前缀和差分</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/leetcode-zhuan-ji-2-shuang-zhi-zhen-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;LeetCode第二弹：总结了双指针的经典题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;题目列表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/merge-sorted-array/&#34;&gt;88. 合并两个有序数组&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/linked-list-cycle/&#34;&gt;141. 环形链表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/&#34;&gt;167. 两数之和 II - 输入有序数组&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/reverse-vowels-of-a-string/&#34;&gt;345. 反转字符串中的元音字母&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/&#34;&gt;524. 通过删除字母匹配到字典里最长单词&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/sum-of-square-numbers/&#34;&gt;633. 平方数之和&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/valid-palindrome-ii/&#34;&gt;680. 验证回文字符串 Ⅱ&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;合并两个有序数组&#34;&gt;合并两个有序数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int p = m + n - 1;
        while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) {
            if (nums1[p1] &amp;gt; nums2[p2])
                nums1[p--] = nums1[p1--];
            else 
                nums1[p--] = nums2[p2--];
        }
        while (p2 &amp;gt;= 0)
            nums1[p--] = nums2[p2--];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;环形链表&#34;&gt;环形链表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次&lt;/li&gt;
&lt;li&gt;如果有环的存在，则slow指针一定和fast指针相遇&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201206152608.png&#34; alt=&#34;image-20201206152607747&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步(也就是环的⻓度)。&lt;/li&gt;
&lt;li&gt;设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。&lt;/li&gt;
&lt;li&gt;巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。&lt;/li&gt;
&lt;li&gt;所以，&lt;strong&gt;只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速 前进，k - m 步后就会相遇，相遇之处就是环的起点了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head == nullptr || head-&amp;gt;next == nullptr)
            return false;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast-&amp;gt;next != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next-&amp;gt;next != nullptr) {
            slow = slow-&amp;gt;next;
            fast = fast-&amp;gt;next-&amp;gt;next;
            if (slow == fast)
                return true;
        }
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两数之和-ii-输入有序数组&#34;&gt;两数之和 II - 输入有序数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) {
        vector&amp;lt;int&amp;gt; res;
        for (int i = 0, j = numbers.size() - 1; i &amp;lt; numbers.size(); i++) {
            while (i &amp;lt; j &amp;amp;&amp;amp; numbers[i] + numbers[j] &amp;gt; target)
                j--;
            if (i &amp;lt; j &amp;amp;&amp;amp; numbers[i] + numbers[j] == target) {
                res.push_back(i + 1);
                res.push_back(j + 1);
                break;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;反转字符串中的元音字母&#34;&gt;反转字符串中的元音字母&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string str = &amp;quot;aeiou&amp;quot;;

    bool check(char c) {
        return str.find(tolower(c)) != -1;
    }

    string reverseVowels(string s) {
        for (int i = 0, j = s.size() - 1; i &amp;lt; j; i++, j--) {
            while (i &amp;lt; j &amp;amp;&amp;amp; !check(s[i]))
                i++;
            while (i &amp;lt; j &amp;amp;&amp;amp; !check(s[j]))
                j--;
            swap(s[i], s[j]);
        }
        return s;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;通过删除字母匹配到字典里最长单词&#34;&gt;通过删除字母匹配到字典里最长单词&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 比较函数：返回长度最长且字典顺序最小的字符串
     * @param a 
     * @param b 
     * @return true 
     * @return false 
     */
    static bool cmp(string &amp;amp;a, string &amp;amp;b) {
      if (a.size() != b.size())
          return a.size() &amp;gt; b.size();
      else
          return a &amp;lt; b;
    }

    string findLongestWord(string s, vector&amp;lt;string&amp;gt;&amp;amp; d) {
        if (d.empty())
            return &amp;quot;&amp;quot;;
        vector&amp;lt;string&amp;gt; res;
        // 找到所有的情况
        for (string str : d) {
            int i = 0, j = 0;
            while (j &amp;lt; s.size()) {
                if (str[i] == s[j])
                    i++;
                j++;
            }
            if (i == str.size())
                res.push_back(str);
        }
        if (res.empty())
            return &amp;quot;&amp;quot;;
        sort(res.begin(), res.end(), cmp);
        return res[0];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;平方数之和&#34;&gt;平方数之和&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool judgeSquareSum(int c) {
        if (c == 0)
            return true;
        int low = 0;
        int high = (int)sqrt(c);
        while (low &amp;lt;= high) {
            long long temp = (long long)low * low + high * high;
            if (temp == c) 
                return true;
            else if (temp &amp;gt; c)
                high--;
            else 
                low++;
        }
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;验证回文字符串-ii&#34;&gt;验证回文字符串 Ⅱ&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
  public:
    bool validPalindrome(string s) {
        for (int i = 0, j = s.size() - 1; i &amp;lt; j; i++, j--) {
            if (s[i] != s[j])
                // 两种情况求“或”
                return helper(s, i + 1, j) || helper(s, i, j - 1);
        }
        return true;
    }
    /**
     * @brief 判断字符串从i ~ j之间是否是回文串
     * @param s 
     * @param i 
     * @param j 
     * @return true 
     * @return false 
     */
    bool helper(string &amp;amp;s, int i, int j) {
        bool res = true;
        while (i &amp;lt; j) {
            if (s[i] != s[j])
                res = false;
            i++;
            j--;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">【LeetCode专辑 - 2】双指针算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/tuo-bu-pai-xu/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;对一个有向无环图G进行拓扑排序，&lt;strong&gt;是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&amp;lt;u,v&amp;gt; ∈ E(G)，则u在线性序列中出现在v之前&lt;/strong&gt;。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;有向图的拓扑序列&#34;&gt;有向图的拓扑序列&lt;/h2&gt;
&lt;p&gt;给定一个n个点m条边的有向图，点的编号是1到n，图中可能存在重边和自环。请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。接下来m行，每行包含两个整数x和y，表示存在一条从点x到点y的有向边(x, y)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。&lt;/p&gt;
&lt;p&gt;否则输出-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,\ m≤10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 3
1 2
2 3
1 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个有向无环图，一定至少存在一个入度为0的点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201205165635.png&#34; alt=&#34;image-20201205165634316&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;使用BFS思想：开始让所有入度为0的点入队，在循环过程中，枚举队头元素的所有出边，删掉队头元素（枚举的元素入度减1），如果这些元素入度为0，则加入到队列中，这样不断循环&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

const int N = 100010;

int n, m;
// 记录每个点的入度
int d[N];
// 记录拓扑排序
vector&amp;lt;int&amp;gt; res;
vector&amp;lt;int&amp;gt; g[N];

bool topsort() {
    queue&amp;lt;int&amp;gt; q;
    
    for (int i = 1; i &amp;lt;= n; i++) {
        if (d[i] == 0) {
            q.push(i);
            res.push_back(i);
        }
    }
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        for (int i = 0; i &amp;lt; g[t].size(); i++) {
            int j = g[t][i];
            d[j]--;
            if (d[j] == 0) {
                q.push(j);
                res.push_back(j);
            }
        }
    }
    // 如果有环则说明一定没有加到队列中来
    return res.size() == n;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++ ) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        g[a].push_back(b);
        d[b]++;
    }
    
    if (!topsort())
        cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; endl;
    else {
        for (int i = 0; i &amp;lt; res.size(); i++)
            cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;判断拓扑排序序列&#34;&gt;判断拓扑排序序列&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 N 和 M，分别表示有向图的点和边的数量。接下来 M 行，每行给出一条边的起点和终点。点的编号从 1 到 N。再一行包含一个整数 K，表示询问次数。接下来 K 行，每行包含一个所有点的排列。一行中的数字用空格隔开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一行中输出所有不是拓扑序列的询问序列的编号。询问序列编号从 0 开始。行首和行尾不得有多余空格，保证存在至少一个解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤N≤1000,
1≤M≤10000,
1≤K≤100&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8193em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8193em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8193em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 8
1 2
1 3
5 2
5 4
2 3
2 6
3 4
6 4
5
1 5 2 3 6 4
5 1 2 6 3 4
5 1 2 3 6 4
5 2 1 6 3 4
1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用数组存储序列下标&lt;/li&gt;
&lt;li&gt;枚举每条边：判断起点下标是否都小于终点下标&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 1010, M = 10010;
struct Edge {
    int a;
    int b;
} e[M];
int n, m;
// 记录路径中的下标
int pos[N];

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        e[i].a = a;
        e[i].b = b;
    }

    int k;
    cin &amp;gt;&amp;gt; k;
    vector&amp;lt;int&amp;gt; res;
    for (int i = 0; i &amp;lt; k; i++) {
        for (int j = 1; j &amp;lt;= n; j++) {
            int x;
            cin &amp;gt;&amp;gt; x;
            pos[x] = j;
        }

        bool success = true;
        for (int j = 0; j &amp;lt; m; j++) {
            if (pos[e[j].b] &amp;lt; pos[e[j].a]) {
                success = false;
                break;
            }
        }
        if (!success)
            res.push_back(i);
    }
    if (res.size() &amp;gt; 0) {
        cout &amp;lt;&amp;lt; res[0];
        for (int i = 1; i &amp;lt; res.size(); i++)
            cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[i];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">拓扑排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/chong-wen-dfsandbfs/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;深度优先搜索（DFS）和广度优先搜索（BFS）是两种搜索树和图的基本策略。其搜索的思想所引申来的题目也比较多，需要引起足够的重视&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;深度优先搜索dfs&#34;&gt;深度优先搜索DFS&lt;/h2&gt;
&lt;p&gt;深度优先搜索它是从某个状态开始，&lt;strong&gt;不断地转移状态直到无法转移（一层一层往下搜）&lt;/strong&gt;，然后回退到前一步状态，继续转移到其他状态，如此不断重复，直至找到最终的解。&lt;/p&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201204153914.png&#34; alt=&#34;image-20201204153912604&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;邻接矩阵存储图的dfs遍历&#34;&gt;邻接矩阵存储图的DFS遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int INF = 0x3f3f3f3f;
// 邻接矩阵存储图的信息g[i][j]表示顶点 i 到顶点 j 这条边的权值大小
int g[N][N];
bool st[N];
// 初始化
memset(g, 0x3f, sizeof g);

void dfs(int u) {
    // 先标记这个点已经被访问过
    st[u] = true;
    // 递归地去遍历和该点连通的点
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i] &amp;amp;&amp;amp; g[u][i] != INF)
            dfs(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;邻接表存储图的dfs遍历&#34;&gt;邻接表存储图的DFS遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 使用邻接表来存储图
vector&amp;lt;int&amp;gt; g[N];
bool st[N];

void dfs(int u) {
    // st[u] 表示点u已经被遍历过
    st[u] = true;
	// 递归地去遍历和该点连通的点
    for (int i = 0; i &amp;lt; g[u].size(); i++) {
        if (!st[g[u][i]]) 
            dfs(g[u][i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;树的重心&#34;&gt;树的重心&lt;/h3&gt;
&lt;p&gt;给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：&lt;strong&gt;重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数m，表示将重心删除后，剩余各个连通块中点数的最大值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n≤10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201204210032.png&#34; alt=&#34;image-20201204210031426&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;DFS遍历每个结点，记录以每个结点为根的子树中点的数量，不断更新，找到子树连通块中最大数的连通块&lt;/li&gt;
&lt;li&gt;该结点上面一共 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - sum&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个结点，再取最大值&lt;/li&gt;
&lt;li&gt;找到该最大值最小的那一种情况&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 100010;

vector&amp;lt;int&amp;gt; g[N];
bool st[N];
int ans = N;
int n;

// 以u为根的子树中点的数量
int dfs(int u) {
    st[u] = true;
    
    // sum记录子树中所有连通块的结点数量
    int sum = 1;
    // 记录将该点删掉之后，子树中连通块的最大值
    int size = 0;
    for (int i = 0; i &amp;lt; g[u].size(); i++) {
        int j = g[u][i];
        if (!st[j]) {
            // 记录当前子树的结点
            int s = dfs(j);
            size = max(size, s);
            sum += s;    
        }
    }
    // 和非子树的连通块的结点数比较，取最大结点数
    size = max(size, n - sum);
    // 答案取最小的一种情况
    ans = min(ans, size);
    return sum;
}

int main() {
    cin &amp;gt;&amp;gt; n;
    
    for (int i = 0; i &amp;lt; n - 1; i++) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    
    dfs(1);
    
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;枚举排列&#34;&gt;枚举排列&lt;/h3&gt;
&lt;p&gt;给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含一个整数n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按字典序输出所有排列方案，每个方案占一行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n≤7&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这其实是一种DFS搜索的思想，我们构造一颗搜索树：&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlgy1ge7iur6ra1j30y80j04qp.jpg&#34; alt=&#34;image-20200426220829697&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列&lt;/strong&gt;。「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：撤销选择，恢复现场，即为回溯&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 10;

int n;
int path[N];
bool st[N];

void dfs(int u) {
    // 已经做完了全部选择，输出路径
    if (u == n) {
        for(int i = 0; i &amp;lt; n; i++) 
            cout &amp;lt;&amp;lt; path[i] &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; endl;
        return;
    }
    // 还可继续向下递归
    for (int i = 1; i &amp;lt;= n; i++) {
        // 如果该数字没有被用过
        if (!st[i]) {
            path[u] = i;
            st[i] = true;
            dfs(u + 1);
            // 恢复现场
            st[i] = false;
        }
    }
}

int main() {
    cin &amp;gt;&amp;gt; n;
    dfs(0);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;n-皇后问题&#34;&gt;n - 皇后问题&lt;/h3&gt;
&lt;p&gt;n-皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png&#34; alt=&#34;1_597ec77c49-8-queens.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;现在给定整数n，请你输出所有的满足条件的棋子摆法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含整数n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。输出方案的顺序任意，只要不重复且没有遗漏即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n≤9&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;相当于是枚举每一行的皇后放在哪一列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只是多了规则，很多不合理的方案可以提前结束搜索，这就是所谓需要进行剪枝&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 20;

int n;
char g[N][N];

/**
 * 检查第i行和第j列能否放置
 **/
bool isValid(int x, int y) {
    // 检查第y列上是否有冲突
    for (int i = 0; i &amp;lt; n; i++) {
        if (g[i][y] == &#39;Q&#39;)
            return false;
    }
    // 检查右上方是否有皇后冲突（因为我们逐层放，只用考虑斜上方的情形）
    for (int i = x - 1, j = y + 1; i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; n; i--, j++) {
        if (g[i][j] == &#39;Q&#39;)
            return false;
    }
    // 检查左上方是否有皇后冲突
    for (int i = x - 1, j = y - 1; i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0; i--, j--) {
        if (g[i][j] == &#39;Q&#39;)
            return false;
    }
    return true;
}

void dfs(int u) {
    if (u == n) {
        for (int i = 0; i &amp;lt; n; i++)
            puts(g[i]);
        puts(&amp;quot;&amp;quot;);
        return;
    }

    for (int i = 0; i &amp;lt; n; i++) {
        // 这里相当于进行剪枝操作
        if (!isValid(u, i))
            continue;
        // 选择
        g[u][i] = &#39;Q&#39;;
        dfs(u + 1);
        // 撤销选择
        g[u][i] = &#39;.&#39;;
    }
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) 
        for (int j = 0; j &amp;lt; n; j++)
            g[i][j] = &#39;.&#39;;

    dfs(0);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;广度优先搜索-bfs&#34;&gt;广度优先搜索 BFS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索（BFS）与深度优先搜索不同在于搜索的顺序，广度优先搜索总是先搜索距离初始状态近的状态。一层一层往下搜索，使用队列。（开始状态 --&amp;gt; &lt;strong&gt;只需要1次就可以到达的所有状态&lt;/strong&gt; --&amp;gt; ......）对于同一个状态，广度优先搜索只经过一次，因此时间复杂度为O(状态数×转移方式)&lt;/li&gt;
&lt;li&gt;广度优先搜索可以找到最短路&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201204171228.png&#34; alt=&#34;image-20201204171227363&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;邻接矩阵存储图的bfs遍历&#34;&gt;邻接矩阵存储图的BFS遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int INF = 0x3f3f3f3f;
// 邻接矩阵存储图的信息g[i][j]表示顶点 i 到顶点 j 这条边的权值大小
int g[N][N];
bool st[N];
// 初始化
memset(g, 0x3f, sizeof g);
queue&amp;lt;int&amp;gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (!q.empty()) {
    int t = q.front();
    q.pop();
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i] &amp;amp;&amp;amp; g[t][i] != INF) {
            st[i] = true; // 表示点i已经被遍历过
            q.push(i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;邻接表存储图的bfs遍历&#34;&gt;邻接表存储图的BFS遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; g[N];
queue&amp;lt;int&amp;gt; q;
bool st[N];
// 初始化
st[1] = true;
q.push(1);
while (!q.empty()) {
    int t = q.front();
    q.pop();
    for (int i = 0; i &amp;lt; g[t].size(); i++) {
        int j = g[t][i];
        if (!st[j]) {
            st[j] = true;	// 表示点j已经被遍历过
            q.push(j);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;图中点的层次&#34;&gt;图中点的层次&lt;/h3&gt;
&lt;p&gt;给定一个n个点m条边的有向图，图中可能存在重边和自环。所有边的长度都是1，点的编号为1~n。请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数，表示1号点到n号点的最短距离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,\ m≤10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 5
1 2
2 3
3 4
1 3
1 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;我们使用BFS遍历，每一次队列取出元素：更新距离，最后输出&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;
const int N = 100010;

int n, m;
vector&amp;lt;int&amp;gt; g[N];
int d[N];

int bfs() {
    memset(d, -1, sizeof d);
    queue&amp;lt;int&amp;gt; q;
    d[1] = 0;
    q.push(1);
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        for (int i = 0; i &amp;lt; g[t].size(); i++) {
            int j = g[t][i];
            // 如果这个点没有遍历到，更新距离
            if (d[j] == -1) {
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
    }
    return d[n];
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        g[a].push_back(b);
    }
    
    cout &amp;lt;&amp;lt; bfs() &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;走迷宫&#34;&gt;走迷宫&lt;/h3&gt;
&lt;p&gt;给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数，表示从左上角移动至右下角的最少移动次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n,m≤100&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d[i] [j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 记录了搜索到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(i, j)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;所需的最少次数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;
const int N = 110;
int n, m;
int g[N][N], d[N][N];

typedef pair&amp;lt;int, int&amp;gt; PII;

int bfs() {
    queue&amp;lt;PII&amp;gt; q;
    memset(d, -1, sizeof d);
    d[0][0] = 0;
    q.push({0, 0});
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        // 枚举4个方向
        for (int i = 0; i &amp;lt; 4; i++) {
            int x = t.first + dx[i];
            int y = t.second + dy[i];
            // 如果没有越界且没有访问到
            if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; m &amp;amp;&amp;amp; g[x][y] == 0 &amp;amp;&amp;amp; d[x][y] == -1) {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }
    
    return d[n - 1][m - 1];
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; n; i++)
        for (int j = 0; j &amp;lt; m; j++)
            cin &amp;gt;&amp;gt; g[i][j];
    cout &amp;lt;&amp;lt; bfs() &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;八数码&#34;&gt;八数码&lt;/h3&gt;
&lt;p&gt;在一个3×3的网格中，1~8这8个数字和一个“x”恰好不重不漏地分布在这3×3的网格中。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3
x 4 6
7 5 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在游戏过程中，可以把“x”与其上、下、左、右四个方向之一的数字交换（如果存在）。我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3
4 5 6
7 8 x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，示例中图形就可以通过让“x”先后与右、下、右三个方向的数字交换成功得到正确排列。交换过程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3   1 2 3   1 2 3   1 2 3
x 4 6   4 x 6   4 5 6   4 5 6
7 5 8   7 5 8   7 x 8   7 8 x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入占一行，将3×3的初始网格描绘出来。例如，如果初始网格如下所示：&lt;br&gt;
1 2 3&lt;/p&gt;
&lt;p&gt;x 4 6&lt;/p&gt;
&lt;p&gt;7 5 8&lt;/p&gt;
&lt;p&gt;则输入为：1 2 3 x 4 6 7 5 8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出占一行，包含一个整数，表示最少交换次数。如果不存在解决方案，则输出”-1”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2  3  4  1  5  x  7  6  8 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;19
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;求&lt;strong&gt;最少&lt;/strong&gt;交换次数 ==&amp;gt; BFS&lt;/li&gt;
&lt;li&gt;这里是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;3×3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的二维数组，在我们使用BFS时候状态表示就显得不方便，因此我们做一个转换：将二维转换成一维，我们使用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;string&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;来表示每一个状态，最终我们需要找到的状态就是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;12345678&lt;/mn&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;12345678x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在搜索的过程中，一维再换回二维去更新状态并更新距离数组dist&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int bfs(string start) {
    string end = &amp;quot;12345678x&amp;quot;;
    unordered_map&amp;lt;string, int&amp;gt; dist;
    dist[start] = 0;
    queue&amp;lt;string&amp;gt; q;
    q.push(start);
    if (start == end)
        return dist[start];

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        int res = dist[t];
        // 如果找到了结果，直接返回
        if (t == end)
            return res;
        int k = t.find(&#39;x&#39;);
        int x = k / 3, y = k % 3;
        // 找到下一个可以更新的状态
        for (int i = 0; i &amp;lt; 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a &amp;gt;= 0 &amp;amp;&amp;amp; a &amp;lt; 3 &amp;amp;&amp;amp; b &amp;gt;= 0 &amp;amp;&amp;amp; b &amp;lt; 3) {
                // 更新状态
                swap(t[k], t[a * 3 + b]);
                // 如果更新后的状态是之前没有搜到过的状态，更新距离并加入到队列
                if (!dist.count(t)) {
                    dist[t] = res + 1;
                    q.push(t);
                }
                // 恢复状态
                swap(t[k], t[a * 3 + b]);
            }
        }
    }
    
    return -1;
}

int main() {
    string start;
    for (int i = 0; i &amp;lt; 9; i++) {
        char c;
        cin &amp;gt;&amp;gt; c;
        start += c;
    }
    cout &amp;lt;&amp;lt; bfs(start) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">重温DFS&BFS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/zai-tan-shuang-zhi-zhen-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;上一篇双指针算法介绍了堆暴力枚举的优化，其实双指针算法思想在其他部分仍有很多的运用，这篇就双指针归并、子序列问题做一个归纳整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;归并有序序列&#34;&gt;归并有序序列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假设有两个递增序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，要求将他们合并为一个递增序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201130181958.png&#34; alt=&#34;image-20201130181957079&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int merge (int A[], int B[], int C[], int n, int m) {
    int i = 0, j = 0, index = 0;
    while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; m) {
        if (A[i] &amp;lt;= B[i])
            c[index++] = A[i++];
        else
            C[index++] = B[j++];
    }
    while (i &amp;lt; n)
        C[index++] = A[i++];
    while (j &amp;lt; m)
        C[index++] = B[j++];
    return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;判断子序列&#34;&gt;判断子序列&lt;/h3&gt;
&lt;p&gt;给定一个长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的整数序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_{1},a_{2},…,a_{n}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，以及一个长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;m&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的整数序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b_{1},b_{2},…,b_{m}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。请你判断&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;序列是否为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;序列的子序列。子序列指序列的一部分项按原有次序排列而得的序列，例如序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_{1},a_{3},a_{5}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_{1},a_{2},a_{3},a_{4},a_{5}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一个子序列&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201130184318.png&#34; alt=&#34;image-20201130184316886&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool check(int A[], int B[], int n, int m) {
    int i = 0, j = 0;
    while (j &amp;lt; m) {
        if (A[i] == B[j])
            i++;
        j++;
    }
    return i == n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;合并两个有序数组&#34;&gt;合并两个有序数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/merge-sorted-array/description/&#34;&gt;LeetCode84题：合并两个有序数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你两个有序整数数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，请你将&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;合并到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中，使&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;成为一个有序数组。说明：初始化&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的元素数量分别为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;m&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。你可以假设&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;有足够的空间（空间大小大于或等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;m + n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）来保存&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中的元素。示例:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2 = [2,5,6],       n = 3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[1,2,2,3,5,6]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201130185903.png&#34; alt=&#34;image-20201130185307695&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了不造成额外数组开销，我们需要&lt;strong&gt;反向使用双指针算法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;先走到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组还没有归并完，直接将&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组中剩下的覆盖到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;nums1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组中即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;先走到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，那么&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前面已经有序，便可结束无需再归并&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int p = m + n - 1;
        while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) {
            if (nums1[p1] &amp;gt; nums2[p2])
                nums1[p--] = nums1[p1--];
            else 
                nums1[p--] = nums2[p2--];
        }
        while (p2 &amp;gt;= 0)
            nums1[p--] = nums2[p2--];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;通过删除字母匹配到字典里最长单词&#34;&gt;通过删除字母匹配到字典里最长单词&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/&#34;&gt;LeetCode524题：通过删除字母匹配到字典里最长单词&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s = abpcplea,\  d = [ale\ ,apple\ ,monkey\ ,plea]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;apple&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用子序列的模板找到所有符合条件的字符串放进res里面&lt;/li&gt;
&lt;li&gt;写比较函数，对答案进行排序，返回第一个即可&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 比较函数：返回长度最长且字典顺序最小的字符串
     * @param a 
     * @param b 
     * @return true 
     * @return false 
     */
    static bool cmp(string &amp;amp;a, string &amp;amp;b) {
      if (a.size() != b.size())
          return a.size() &amp;gt; b.size();
      else
          return a &amp;lt; b;
    }

    string findLongestWord(string s, vector&amp;lt;string&amp;gt;&amp;amp; d) {
        if (d.empty())
            return &amp;quot;&amp;quot;;
        vector&amp;lt;string&amp;gt; res;
        // 找到所有的情况
        for (string str : d) {
            int i = 0, j = 0;
            while (j &amp;lt; s.size()) {
                if (str[i] == s[j])
                    i++;
                j++;
            }
            if (i == str.size())
                res.push_back(str);
        }
        if (res.empty())
            return &amp;quot;&amp;quot;;
        sort(res.begin(), res.end(), cmp);
        return res[0];
    }
};
&lt;/code&gt;&lt;/pre&gt;
">再谈双指针算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/cong-bao-li-mei-ju-dao-shuang-zhi-zhen-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;双指针算法：双指针是算法编程中一种非常重要的算法思想。所谓双指针算法，就是指的是在遍历的过程中，不是普通的使用单个指针进行循环访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。通常使用双指针算法解决的第一大类问题是：对&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的枚举进行优化到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;暴力枚举模板&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 0; i &amp;lt; n; i++) 
    for (int j = 0; j &amp;lt; n; j++)
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;双指针模板&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双指针的核心在于找题目中找另一个指针的单调性来降低题目的复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 0, j = 0; i &amp;lt; n; i++) {
    while (j &amp;lt; i &amp;amp;&amp;amp; check(i, j))
        j++;
    // 每道题具体逻辑
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;数组元素目标和&#34;&gt;数组元素目标和&lt;/h2&gt;
&lt;p&gt;给定两个升序排序的有序数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，以及一个目标值&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。数组下标从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开始。请你求出满足&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A[i] + B[j] = x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的数对&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(i, j)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。数据保证有唯一解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个整数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n，m，x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;分别表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的长度，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的长度以及目标值&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。第二行包含&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个整数，表示数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。第三行包含&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;m&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个整数，表示数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含两个整数 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组长度不超过&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;100000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。同一数组内元素各不相同。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;元&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;素&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤ 数组元素 ≤10^9&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;元&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;素&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 5 6
1 2 4 7
3 4 6 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;暴力枚举&#34;&gt;暴力枚举&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 0; i &amp;lt; n; i++)
    for (int j = 0; j &amp;lt; m; j++)
        if (a[i] + b[j] == x) 
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;双指针&#34;&gt;双指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;找到单调性&lt;/strong&gt;：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组都是单调上升，因此我们发现针对每一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;都去找一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B[j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，使得&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A[i]+ B[j] &amp;gt;= x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;并且&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是最靠左的那一个下标。那么我们的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;就从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的尾部往前走&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201129210858.png&#34; alt=&#34;image-20201129210857280&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;
int n, m, x;
int a[N], b[N];

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; x;
    for (int i = 0; i &amp;lt; n; i++)
        cin &amp;gt;&amp;gt; a[i];
    for (int i = 0; i &amp;lt; m; i++)
        cin &amp;gt;&amp;gt; b[i];
    for (int i = 0, j = m - 1; i &amp;lt; n; i++) {
        while (j &amp;gt;= 0 &amp;amp;&amp;amp; a[i] + b[j] &amp;gt; x)
            j--;
        if (j &amp;gt;= 0 &amp;amp;&amp;amp; a[i] + b[j] == x) {
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; endl;
            break;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;最长连续不重复子序列&#34;&gt;最长连续不重复子序列&lt;/h2&gt;
&lt;p&gt;给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n。第二行包含n个整数（均在0~100000范围内），表示整数序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n≤100000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5
1 2 2 3 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;暴力枚举-2&#34;&gt;暴力枚举&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 0; i &amp;lt; n; i++)
    for (int j = 0; j &amp;lt;= i; j++)
        if (check(j, i))	// 检查[j, i]这一段是否满足
            res = max(res, i - j + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;双指针算法&#34;&gt;双指针算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遍历数组a中的每一个元素&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，对于每一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，找到j使得双指针&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[j,\ i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;维护的是&lt;strong&gt;以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;结尾的最长连续不重复子序列&lt;/strong&gt;，长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i - j + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;, 将这一长度与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;res&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的较大者更新给&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;res&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单调性&lt;/strong&gt;：对于每一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，如何确定&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的位置：由于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[j,\ i - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是前一步得到的最长连续不重复子序列，所以如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[j,\ i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中有重复元素，一定是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，因此右移&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;直到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不重复为止（&lt;strong&gt;由于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[j,\ i - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;已经是前一步的最优解，此时&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;只可能右移以剔除重复元素&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，不可能左移增加元素，因此，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;具有单调性&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;用数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;记录子序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[j,\  i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中各元素出现次数，遍历过程中对于每一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;有&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;步操作：
&lt;ul&gt;
&lt;li&gt;将&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;出现次数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt[a[i]]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;加&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;重复则右移&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;直到不出现重复（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt[a[j]]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;要减&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;/li&gt;
&lt;li&gt;确定&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;及更新当前长度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i - j + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;给&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;res&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201129220022.png&#34; alt=&#34;image-20201129220021509&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;
int a[N], cnt[N];
int n;

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) 
        cin &amp;gt;&amp;gt; a[i];
    
    int res = 0;
    for (int i = 0, j = 0; i &amp;lt; n; i++) {
        cnt[a[i]]++;
        while (s[a[i]] &amp;gt; 1) {
            cnt[a[j]]--;
            j++;
        }
        res = max(res, i - j + 1);
    }
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">从暴力枚举到双指针算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/leetcode-zhuan-ji-1-er-fen-cha-zhao/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;LeetCode第一弹：二分相关经典题目刷题笔记，这里所有题目都是按照上一篇文章所分享的模板来解题，思路非常清晰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;题目列表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/&#34;&gt;33. 搜索旋转排序数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/&#34;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/sqrtx/description/&#34;&gt;69. x-的平方根&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/search-a-2d-matrix/description/&#34;&gt;74. 搜索二维矩阵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/&#34;&gt;153. 寻找旋转排序数组中的最小值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/first-bad-version/description/&#34;&gt;278. 第一个错误的版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/valid-perfect-square/description/&#34;&gt;367. 有效的完全平方数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/&#34;&gt;540. 有序数组中的单一元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/&#34;&gt;744. 寻找比目标字母大的最小字母&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/description/&#34;&gt;852. 山脉数组的峰顶索引&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;搜索旋转排序数组&#34;&gt;搜索旋转排序数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过二分找到数组旋转的位置&lt;/li&gt;
&lt;li&gt;判断要查找的数位于哪一段&lt;/li&gt;
&lt;li&gt;在段内进行二分查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        if (nums.empty())
            return -1;
        // 先找到旋转的位置
        int l = 0, r = nums.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + r + 1 &amp;gt;&amp;gt; 1;
            if (nums[mid] &amp;gt;= nums[0])
                l = mid;
            else 
                r = mid - 1;
        }
        // 判断位于哪一段
        if (target &amp;gt;= nums[0])
            l = 0;
        else 
            l = r + 1, r = nums.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            if (nums[mid] &amp;gt;= target)
                r = mid;
            else 
                l = mid + 1;
        }
        // 这里写nums[l]的话：[1] 0 这个样例会出现问题，没有进入二分，导致 l = r + 1越界
        if (nums[r] == target)
            return l;
        else 
            return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;在排序数组中查找元素的第一个和最后一个位置&#34;&gt;在排序数组中查找元素的第一个和最后一个位置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        vector&amp;lt;int&amp;gt; res = {-1, -1};
        if (nums.size() == 0)
            return res;
        int l = 0, r = nums.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            if (nums[mid] &amp;gt;= target)
                r = mid;
            else
                l = mid + 1;
        }
        if (nums[l] == target)
            res[0] = l;
        l = 0, r = nums.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + r + 1 &amp;gt;&amp;gt; 1;
            if (nums[mid] &amp;lt;= target)
                l = mid;
            else
                r = mid - 1;
        }
        if (nums[l] == target)
            res[1] = l;
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;x的平方根&#34;&gt;x的平方根&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int mySqrt(int x) {
        if (x &amp;lt;= 1)
            return x;
        int l = 1, r = x;
        while (l &amp;lt; r) {
            // 强行转换成long long类型
            int mid = l + 1ll + r &amp;gt;&amp;gt; 1;
            if (mid &amp;lt;= x / mid)
                l = mid;
            else 
                r = mid - 1;
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;搜索二维矩阵&#34;&gt;搜索二维矩阵&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一维坐标转二维的形式进行二分查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
        if (matrix.empty() || matrix[0].empty())
            return false;
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = n * m - 1;
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            // 一维坐标转换成二维坐标
            if (matrix[mid / m][mid % m] &amp;gt;= target)
                r = mid;
            else 
                l = mid + 1;
        }
        return matrix[l / m][l % m] == target;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;寻找旋转排序数组中的最小值&#34;&gt;寻找旋转排序数组中的最小值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int l = 0, r = nums.size() - 1;
        if (nums[l] &amp;lt; nums[r])
            return nums[0];
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            if (nums[mid] &amp;lt; nums[0])
                r = mid;
            else
                l = mid + 1;
        }
        return nums[l];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第一个错误的版本&#34;&gt;第一个错误的版本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int firstBadVersion(int n) {
        int l = 1, r = n;
        while (l &amp;lt; r) {
            int mid = l + (r - l) / 2;
            if (isBadVersion(mid))
                r = mid;
            else
                l = mid + 1;

        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;有效的完全平方数&#34;&gt;有效的完全平方数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int firstBadVersion(int n) {
        int l = 1, r = n;
        while (l &amp;lt; r) {
            int mid = l + (r - l) / 2;
            if (isBadVersion(mid))
                r = mid;
            else
                l = mid + 1;

        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;有序数组中的单一元素&#34;&gt;有序数组中的单一元素&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将两个元素看作一组进行二分，找到边界即为所求&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int singleNonDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        // 给数组末尾添加一个数：只需要保证和数组最后一位不相同即可
        nums.push_back(nums.back() + 1);
        int l = 0, r = nums.size() / 2 - 1;
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            // 边界一定在mid的左边
            if (nums[mid * 2] != nums[mid * 2 + 1])
                r = mid;
            else
                l = mid + 1;
        }
        return nums[r * 2];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;寻找比目标字母大的最小字母&#34;&gt;寻找比目标字母大的最小字母&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) {
        // 二分出第一个大于target的数
        int l = 0, r = letters.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            if (letters[mid] &amp;gt; target)
                r = mid;
            else
                l = mid + 1;
        }
        // 说明找奥拉恰好大于target的数，返回即可
        if (letters[l] &amp;gt; target)
            return letters[l];
        // 否则返回第一个字符
        return letters[0];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;山脉数组的峰顶索引&#34;&gt;山脉数组的峰顶索引&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int peakIndexInMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; A) {
        int l = 0, r = A.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + (r - l) / 2;
            if (A[mid] &amp;lt;= A[mid + 1])
                l = mid + 1;
            else 
                r = mid;
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">【LeetCode专辑 - 1】二分查找</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/qia-si-xi-jie-shi-mo-gui-de-er-fen/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;二分查找是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。对于浮点数的二分比较简单，但涉及到整数的二分，边界情况的考虑就显得非常重要，思路很简单，细节是魔鬼。这里总结了两套模板对解题有很大的帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;一般而言，当一个题目出现以下特征，就应该联想到要使用二分查找&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;待查找的数组有序或者部分有序&lt;/li&gt;
&lt;li&gt;要求时间复杂度低于O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;整数二分&#34;&gt;整数二分&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;两个模板&#34;&gt;两个模板&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201127162410.png&#34; alt=&#34;image-20201127162409088&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;区间&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[l, r]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;被划分为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[l, mid - 1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[mid, r]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时可用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;这里在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;加&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的原因是：当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l = r - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时，由于C++向下取整：导致死循环，所以要加&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int binarySearch_1 (int l, int r) {
	int l = 0, r = n - 1;
    while (l &amp;lt; r) {
        mid = l + r + 1 &amp;gt;&amp;gt; 1;
        if (check(mid))		// check()判断mid是否满足性质的函数：具体根据题目描述来写
            l = mid;
        else
            r = mid - 1;
    }
    return l;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201127162502.png&#34; alt=&#34;image-20201127162500907&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;区间&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[l, r]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;被划分为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[l, mid]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[mid + 1, r]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时可用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int binarySearch_2 (int l, int r) {
	int l = 0, r = n - 1;
    while (l &amp;lt; r) {
        mid = l + r &amp;gt;&amp;gt; 1;
        if (check(mid))		// check()判断mid是否满足性质的函数：具体根据题目描述来写
            r = mid;
        else
            l = mid + 1;
    }
    return l;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;模板使用技巧&#34;&gt;模板使用技巧&lt;/h3&gt;
&lt;p&gt;在做题的过程中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们只需要先写&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;;&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mid = l + r &amp;gt;&amp;gt; 1;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据具体题目写好&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;check()&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;函数，找到更新方式，确定到底是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l = mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;还是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r = mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;若是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l = mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的情况，我们只需要在第一个步骤里面把二分时&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的取值进行加&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l = mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的情况，另一边就是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r = mid - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;； &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r = mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的情况，另一边就是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l = mid + 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;例题&#34;&gt;例题&lt;/h3&gt;
&lt;p&gt;给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回“-1 -1”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n和q，表示数组长度和询问个数。第二行包含n个整数（均在1~10000范围内），表示完整数组。接下来q行，每行包含一个整数k，表示一个询问元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。如果数组中不存在该元素，则返回“-1 -1”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;100000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤n≤100000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤q≤10000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8304100000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤k≤10000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 3
1 2 2 3 3 4
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4
5 5
-1 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;

int q[N];

int main() {
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; n; i++) 
        cin &amp;gt;&amp;gt; q[i];
    
    while (m--) {
        int x;
        cin &amp;gt;&amp;gt; x;
        
        int l = 0, r = n - 1;
        while (l &amp;lt; r) {
            int mid = l + r &amp;gt;&amp;gt; 1;
            // 找左端点：q[mid] &amp;gt;= x确定要找的左端点一定在[l, mid]之间，更新r = mid
            if (q[mid] &amp;gt;= x)
                r = mid;
            // r = mid,对应l就是mid + 1，对应第二个模板，前面mid不需要修改
            else
                l = mid + 1;
        }
        if (q[l] != x)
            cout &amp;lt;&amp;lt; &amp;quot;-1 -1&amp;quot; &amp;lt;&amp;lt; endl;
        else {
            cout &amp;lt;&amp;lt; l &amp;lt;&amp;lt; &#39; &#39;;
            l = 0, r = n - 1;
            while (l &amp;lt; r) {
            int mid = l + r + 1 &amp;gt;&amp;gt; 1;
            // 找右端点：q[mid] &amp;lt;= x确定要找的右端点一定在[mid, r]之间，更新l = mid
            if (q[mid] &amp;lt;= x)
                l = mid;
            // l = mid,对应r就是mid - 1，对应第一个模板，前面mid修改+1
            else
                r = mid - 1;
        }
        cout &amp;lt;&amp;lt; l &amp;lt;&amp;lt; endl;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;浮点数二分&#34;&gt;浮点数二分&lt;/h2&gt;
&lt;p&gt;给定一个浮点数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，求它的三次方根。&lt;/p&gt;
&lt;p&gt;对于这一类浮点数二分的题目：当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r-l&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;足够小时，我们就假定已经找完，用公式表示为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r - l &amp;gt; 1e-6&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ,此时有个精度问题如果要求保留六位小数则&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r - l &amp;gt; 1e-8&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，总&lt;strong&gt;要比保留的位数多两位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含一个浮点数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，包含一个浮点数，表示问题的解。注意，结果保留6位小数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;10000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;−10000≤n≤10000&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1000.00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10.000000
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int main() {
    double x;
    cin &amp;gt;&amp;gt; x;
    double l = -10000, r = 10000;
    // 通常比要求精度提高2位
    while (r - l &amp;gt; 1e-8) {
        double mid = (l + r) / 2;
        // 浮点数二分不用考虑边界问题
        if (mid * mid * mid &amp;gt;= x)
            r = mid;
        else
            l = mid;
    }
    printf(&amp;quot;%lf\n&amp;quot;, l);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">掐死“细节是魔鬼”的二分</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/gao-jing-du-suan-fa-fen-xi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;高精度运算：是指参与运算的数(加数，减数，因子……）范围大大超出了标准数据类型（整型，实型）能表示的范围的运算。例如，求两个20000位的数的和。这时，就要用到高精度算法了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;高精度加法&#34;&gt;高精度加法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若&lt;code&gt;t1&lt;/code&gt;表示第一个数当前位数的大小，&lt;code&gt;t2&lt;/code&gt;表示第二个数当前位数的大小，&lt;code&gt;t&lt;/code&gt;表示进位数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从个位数开始进行相加，使用&lt;code&gt;t&lt;/code&gt;记录&lt;code&gt;(t1 + t2 + next)&lt;/code&gt;得出的结果，&lt;code&gt;t % 10&lt;/code&gt;为该位数确定好的元素，进行下一个位数操作时，需要&lt;code&gt;t /= 10&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201126165634.png&#34; alt=&#34;image-20201126165633273&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

const int N = 1e6 + 10;

vector&amp;lt;int&amp;gt; add(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B){
    vector&amp;lt;int&amp;gt; C;
    int t = 0;
    for (int i = 0; i &amp;lt; A.size() || i &amp;lt; B.size(); i++) {
        if (i &amp;lt; A.size())
            t += A[i];
        if (i &amp;lt; B.size())
            t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t &amp;gt; 0)
        C.push_back(1);
    return C;
}

int main() {
    string a, b;
    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    // 高精度数据反向存储在数组中
    vector&amp;lt;int&amp;gt; A, B;
    for (int i = a.size() - 1; i &amp;gt;= 0; i--)
        A.push_back(a[i] - &#39;0&#39;);
    for (int i = b.size() - 1; i &amp;gt;= 0; i--) 
        B.push_back(b[i] - &#39;0&#39;);
    vector&amp;lt;int&amp;gt; result = add(A, B);
    
    for (int i = result.size() - 1; i &amp;gt;= 0; i--)
        cout &amp;lt;&amp;lt; result[i];
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;高精度减法&#34;&gt;高精度减法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们先比较A和B的大小，我们始终用大的数减去小的数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于&lt;code&gt; t = A[i] - B[i] - t&lt;/code&gt;； 可以拆为 &lt;code&gt;t = A[i] - t&lt;/code&gt;如果&lt;code&gt;B[i]&lt;/code&gt;合法，再&lt;code&gt;t -= B[i] &lt;/code&gt;这么两步来做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去掉高位中的0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201126171552.png&#34; alt=&#34;image-20201126171551272&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

// 判断A &amp;gt;= B是否满足
bool cmp(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B) {
    if (A.size() != B.size())
        return A.size() &amp;gt; B.size();
    else {
        for (int i = A.size() - 1; i &amp;gt;= 0; i--) 
            if (A[i] != B[i])
                return A[i] &amp;gt; B[i];
    }
    return true;
}

vector&amp;lt;int&amp;gt; sub(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B) {
    vector&amp;lt;int&amp;gt; C;
    // 借位
    int t = 0;
    for (int i = 0; i &amp;lt; A.size(); i++) {
        t = A[i] - t;
        // 如果合法
        if (i &amp;lt; B.size())
            t -= B[i];
        // A[i] 这一位够减，没有产生借位
        if (t &amp;gt;= 0) {
            C.push_back(t);
            t = 0;
        }
        else {
            C.push_back(t + 10);
            t = 1;
        }
    }
    // 去掉高位中的0
    while (C.size() &amp;gt; 1 &amp;amp;&amp;amp; C.back() == 0)
        C.pop_back();
    return C;
}

int main() {
    string a, b;
    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    vector&amp;lt;int&amp;gt; A, B;
    for (int i = a.size() - 1; i &amp;gt;= 0; i--)
        A.push_back(a[i] - &#39;0&#39;);
    for (int i = b.size() - 1; i &amp;gt;= 0; i--)
        B.push_back(b[i] - &#39;0&#39;);
    
    // A &amp;gt;= B的情况
    if (cmp(A, B)) {
        vector&amp;lt;int&amp;gt; C = sub(A, B);
        for (int i = C.size() - 1; i &amp;gt;= 0; i--)
            cout &amp;lt;&amp;lt; C[i];
    }
    else {
        vector&amp;lt;int&amp;gt; C = sub(B, A);
        cout &amp;lt;&amp;lt; &#39;-&#39;;
        for (int i = C.size() - 1; i &amp;gt;= 0; i--)
            cout &amp;lt;&amp;lt; C[i];
    }
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;高精度乘法&#34;&gt;高精度乘法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;模拟乘法规则，从A的个位到高位与B相乘，乘得的结果放入t中，则此位的数为&lt;code&gt;t % 10&lt;/code&gt;。把&lt;code&gt;t / 10&lt;/code&gt;剩余给下一个高位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若遍历完整个&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;t &amp;gt; 0&lt;/code&gt;，则表示还有剩余的数，则需要将剩余的数继续补到下一个高位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除高位出现的&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201126181813.png&#34; alt=&#34;image-20201126181812485&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; mul(vector&amp;lt;int&amp;gt;&amp;amp; A, int b) {
    vector&amp;lt;int&amp;gt; C;
    int t = 0;
    for (int i = 0; i &amp;lt; A.size() || t; i++) {
        // 有可能在乘b之后出现进位要多加一位，因此需要判断
        if (i &amp;lt; A.size())
            t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    // 删除高位0
    while (C.size() &amp;gt; 1 &amp;amp;&amp;amp; C.back() == 0)
        C.pop_back();
    return C;
}

int main() {
    string a;
    int b;
    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    vector&amp;lt;int&amp;gt; A, result;
    
    for (int i = a.size() - 1; i &amp;gt;= 0; i--)
        A.push_back(a[i] - &#39;0&#39;);
    result = mul(A, b);
    
    for (int i = result.size() - 1; i &amp;gt;= 0; i--)
        cout &amp;lt;&amp;lt; result[i];
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;高精度除法&#34;&gt;高精度除法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模拟除法规则，从高位到底位与除数进行相除，除得的余数放入&lt;code&gt;t&lt;/code&gt;中，则此位的数为&lt;code&gt;t / 10&lt;/code&gt;，把剩余的&lt;code&gt;t % 10&lt;/code&gt;给下一个底位&lt;/li&gt;
&lt;li&gt;若遍历完整个&lt;code&gt;A&lt;/code&gt;，需要将最靠左的且为&lt;code&gt;0&lt;/code&gt;的高位全部去除掉&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201126183438.png&#34; alt=&#34;image-20201126183437238&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; div(vector&amp;lt;int&amp;gt;&amp;amp; A, int b, int&amp;amp; r) {
    vector&amp;lt;int&amp;gt; C;
    // 除法是从最高位开始除
    for (int i = A.size() - 1; i &amp;gt;= 0; i--) {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b; 
    }
    // 与我们逆向存储数据相反，为了统一，reverse
    reverse(C.begin(), C.end());
    // 去除高位的0
    while (C.size() &amp;gt; 1 &amp;amp;&amp;amp; C.back() == 0)
        C.pop_back();
    return C;
}


int main() {
    string a;
    int b;
    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    vector&amp;lt;int&amp;gt; A;
    for (int i = a.size() - 1; i &amp;gt;= 0; i--) 
        A.push_back(a[i] - &#39;0&#39;);
    int r = 0;
    vector&amp;lt;int&amp;gt; result = div(A, b, r);
    for (int i = result.size() - 1; i &amp;gt;= 0; i--)
        cout &amp;lt;&amp;lt; result[i];
    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">高精度算法分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/qian-tan-mysql-suo-yin/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在前天的面试中，和面试官聊了聊MySQL索引的部分问题，面试官给我讲了很多，下来后查阅了相关资料并做了一个整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;!-- more --&gt;
&lt;p&gt;Reference：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/Sl0GZeKLJfPOyfWV6iDk1w&#34;&gt;为什么 MySQL 使用 B+ 树？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/XC5T0WnNC0schcuoV8wPxw&#34;&gt;理解MySQL索引底层数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/39293940&#34;&gt;MySQL聚集索引和非聚集索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/s-b-b/p/8334593.html&#34;&gt;聚集索引和非聚集索引的总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;聚集索引非聚集索引&#34;&gt;聚集索引&amp;amp;非聚集索引&lt;/h2&gt;
&lt;p&gt;聚集（clustered）索引，也叫聚簇索引：&lt;strong&gt;数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引&lt;/strong&gt;。通常：如果我们定义id为主键时，建立了聚集索引。数据行的物理顺序与列值得顺序相同。如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列顺序方式与聚集索引的顺序相同，索引也就只能建立一个聚集索引。&lt;/p&gt;
&lt;p&gt;非聚集（unclustered）索引：&lt;strong&gt;该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引&lt;/strong&gt;。其实按照定义，除了聚集索引以外的索引都是非聚集索引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理解聚集索引和非聚集索引可通过对比汉语字典的索引。汉语字典提供了两类检索汉字的方式，第一类是拼音检索（前提是知道该汉字读音），比如拼音为cheng的汉字排在拼音chang的汉字后面，根据拼音找到对应汉字的页码，这就是我们通常所说的字典序；第二类是部首笔画检索，根据笔画找到对应汉字，查到汉字对应的页码。&lt;strong&gt;拼音检索就是聚集索引，因为存储的记录（数据库中是行数据、字典中是汉字的详情记录）是按照该索引排序的；笔画索引，虽然笔画相同的字在笔画索引中相邻，但是实际存储页码却不相邻&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;创建索引&#34;&gt;创建索引&lt;/h3&gt;
&lt;p&gt;如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。&lt;/p&gt;
&lt;p&gt;聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table student (
    `id` INT UNSIGNED AUTO_INCREMENT,
    `name` VARCHAR(255),
    `score` INT UNSIGNED,
    PRIMARY KEY(`id`),
    KEY(`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最好还是在创建表的时候添加聚集索引，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;查找分析&#34;&gt;查找分析&lt;/h3&gt;
&lt;p&gt;该表中主键id是该表的聚集索引、name为非聚集索引；表中的每行数据都是按照聚集索引id排序存储的；比如要查找name=&#39;Arla&#39;和name=&#39;Arle&#39;的两个同学，他们在name索引表中位置可能是相邻的，但是实际存储位置可能差的很远。&lt;strong&gt;name索引表节点按照name排序，检索的是每一行数据的主键。聚集索引表按照主键id排序，检索的是每一行数据的真实内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非聚集索引的二次查询（回表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，&lt;strong&gt;而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from student where name = &#39;Arle&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询name=&#39;Arle&#39;的记录时，score列没有索引覆盖，需要二次查询。&lt;strong&gt;首相通过name索引表查找到Arle的主键id（可能有多个主键id，因为有重名的同学），再根据主键id的聚集索引找到相应的行记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决非聚集索引的二次查询问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复合索引（覆盖索引）&lt;/strong&gt;：建立两列以上的索引，即可查询复合索引里的列的数据而不需要进行回表二次查询，如index(col1, col2)，执行下面的语句&lt;/p&gt;
&lt;h3 id=&#34;查找比较&#34;&gt;查找比较&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from student where id &amp;gt; 5000 and id &amp;lt; 20000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据id进行范围查询，因为(5000, 20000)范围内的记录在磁盘上按顺序存储，顺序读取磁盘很快就能读到这批数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from student where name &amp;gt; &#39;Alie&#39; and name &amp;lt; &#39;John&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询（&#39;Alie&#39;, &#39;John&#39;）范围内的记录，主键id分布可能是离散的1，100，20001，5000.....；增加了随机读取数据页几率；所以普通索引的范围查询效率被聚集索引甩开几条街都不止；非聚集索引的精确查询效率还是可以的，比聚集索引查询只增加了一次IO开销&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。&lt;/li&gt;
&lt;li&gt;非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升。&lt;/li&gt;
&lt;li&gt;不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;索引底层数据结构分析&#34;&gt;索引底层数据结构分析&lt;/h2&gt;
&lt;p&gt;索引（Index）是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构，而且是实现了高级查找算法的数据结构 索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作&lt;/p&gt;
&lt;h3 id=&#34;hash索引&#34;&gt;Hash索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果是等值查询，哈希索引明显有绝对优势。 &lt;strong&gt;前提：键值唯一&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;哈希索引没办法完成范围查询检索&lt;/li&gt;
&lt;li&gt;哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询&lt;/li&gt;
&lt;li&gt;哈希索引也不支持多列联合索引的&lt;/li&gt;
&lt;li&gt;在有大量重复键值情况下，哈希索引的效率也最左前缀原则是极低的，因为存在哈希碰撞问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-tree索引&#34;&gt;B Tree索引&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201125201001.png&#34; alt=&#34;image-20201125201000142&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;度(Degree)-节点的数据存储个数&lt;/li&gt;
&lt;li&gt;叶子节点具有相同的深度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶子节点的指针为空&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;节点中的数据key从左到右递增排列&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201125204922.png&#34; alt=&#34;image-20201125204921591&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先找到根节点也就是页1，&lt;strong&gt;判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8&lt;/li&gt;
&lt;li&gt;将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-tree索引-2&#34;&gt;B+ Tree索引&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201125201038.png&#34; alt=&#34;image-20201125201037623&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非叶子节点不存储data，只存储key，可以增大度&lt;/strong&gt;：之所以这么做是因为在&lt;strong&gt;数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;叶子节点不存储指针&lt;/li&gt;
&lt;li&gt;顺序访问指针，提高区间访问的性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+树索引就是innodb中B+树索引真正的实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;查询分析&#34;&gt;查询分析&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201125210904.png&#34; alt=&#34;image-20201125210903932&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from user where id &amp;gt;= 18 and id &amp;lt; 40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中id是主键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般根节点都是常驻内存的，也就是说页1已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。从内存中读取到页1，要查找这个id&amp;gt;=18 and id &amp;lt;40或者范围值，我们首先需要找到id=18的键值。&lt;strong&gt;从页1中我们可以找到键值18，此时我们需要根据指针p2，定位到页3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;要从页3中查找数据，我们就需要拿着p2指针去磁盘中进行读取页3。从磁盘中读取页3后将页3放入内存中，然后进行查找，&lt;strong&gt;我们可以找到键值18，然后再拿到页3中的指针p1，定位到页8&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;同样的页8页不在内存中，我们需要再去磁盘中将页8读取到内存中。将页8读取到内存中后。因为页中的数据是链表进行连接的，而且&lt;strong&gt;键值是按照顺序存放的，此时可以根据二分查找法定位到键值18&lt;/strong&gt;。此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值18对应的数据。因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，&lt;strong&gt;那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据。我们可以一直找到键值为22的数据，然后页8中就没有数据了，此时我们需要拿着页8中的p指针去读取页9中的数据（叶子结点之间有指针链接）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;因为页9不在内存中，就又会加载页9到内存中，并通过和页8中一样的方式进行数据的查找，直到将页12加载到内存中，发现41大于40，此时不满足条件。那么查找到此终止&lt;/li&gt;
&lt;li&gt;最终我们找到满足条件的所有数据为：(18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。总共12条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201125211405.png&#34; alt=&#34;image-20201125211404609&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;总结-2&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈希虽然能够提供 &lt;code&gt;O(1)&lt;/code&gt; 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；&lt;/li&gt;
&lt;li&gt;B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；&lt;/li&gt;
&lt;/ul&gt;
">浅谈MySQL索引</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/qian-tan-trie-shu/"" data-c="
          &lt;h2 id=&#34;什么是trie树&#34;&gt;什么是Trie树？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Trie树又称单词查找树，是一种树形结构。典型应用是用于统计、排序、保存和查找大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计&lt;/strong&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;根节点不包含字符，&lt;strong&gt;除根节点外每一个节点都只包含一个字符&lt;/strong&gt;； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。&lt;/p&gt;
&lt;p&gt;它的优点是：&lt;strong&gt;利用字符串的公共前缀来减少查询时间&lt;/strong&gt;，最大限度地减少无谓的字符串比较&lt;/p&gt;
&lt;p&gt;例如存储字符串集合：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{b， abc， abd， abcd， abcd， bcd， efg， hij}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align = &#34;center&#34;&gt;
    &lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201018155017.png&#34; width = &#34;400&#34; height = &#34;400&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
&lt;h2 id=&#34;trie树基本操作&#34;&gt;Trie树基本操作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这里以字符串为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解核心数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ：用不同的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;值来记录结点，以下标来记录每一个字符的位置，每次插入一个字符，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx++&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;26&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;son[N] [26]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ：表示当前结点的儿子，其中存放的是子节点对应的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;；&lt;strong&gt;其中第一维是父节点对应的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这里的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;代表字符串的总长度，所以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;永远在这个范围之内。第二维的计数是子节点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(&amp;#x27;a&amp;#x27; - &amp;#x27;0&amp;#x27;)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.001892em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.001892em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的值为二维下标&lt;/strong&gt;，对于字母而言最多有&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;26&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;26&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个子结点。比如：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;son[1] [0]=2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;结点的一个值为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的子结点为结点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;；如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;son[1] [0]= 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，则意味着没有值为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;子结点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt[N]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt[p]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;标记以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;结尾的字符串的个数。以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;“&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;”&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;“abc”&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;“&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;字符串为例，最后一个字符&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;‘&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;’&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;‘c’&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;‘&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;’&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;对应的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;作为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组的下标。数组的值是该&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;对应的个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入&#34;&gt;插入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遍历字符串的每一个字符
&lt;ul&gt;
&lt;li&gt;将字符映射到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;25&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0 - 25&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;子节点没有该字符，则添加进来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历结束，将字符串最后一个位置对应的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;trie&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;树结点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;对应的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组计数++&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

// N受字符串总长度的限制
const int N = 100010;

int son[N][26];
int idx;
int cnt[N];
char str[N];

/**
 * @brief 将字符串添加到Trie树中
 * @param str 
 */
void insert (char* str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        // 将字符映射到0-25
        int u = str[i] - &#39;a&#39;;
        // 没有该字符，添加进来
        if (!son[p][u])
            son[p][u] = ++idx;
        p = son[p][u];
    }
    // 此时的p就是str中最后一个字符对应的trie树的位置idx
    cnt[p]++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查找&#34;&gt;查找&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遍历字符串的每一个字符，如果其中任一个字符没有在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Trie&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;树中找到相应结点则返回&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;遍历结束，返回该字符串最后一个字符对应&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cnt&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 查找字符串str出现的次数
 * @param str 
 * @return int 
 */
int query (char* str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u])
            return 0;
        p = son[p][u];
    }
    return cnt[p];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最大异或对&#34;&gt;最大异或对&lt;/h2&gt;
&lt;p&gt;在给定的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个整数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A_{1}，A_{2}……A_{N}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中选出两个进行&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;xor&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（异或）运算，得到的结果最大是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输入一个整数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二行输入&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个整数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;～&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A_{1}～A_{N}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;～&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数表示答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;31&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1≤ N ≤10^5,
0≤ A_{i}&amp;lt;2^{31}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.78041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8193em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;暴力枚举&#34;&gt;暴力枚举&lt;/h3&gt;
&lt;p&gt;算法时间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 100010;

int a[N];
int n;

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i  = 0; i &amp;lt; n; i++) 
        cin &amp;gt;&amp;gt; a[i];
    
    int res = 0;
    for (int i = 0; i &amp;lt; n; i++) 
        for (int j = 0; j &amp;lt; n; j++)
            res = max(res, a[i] ^ a[j]);
   	
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用trie树优化&#34;&gt;使用Trie树优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优化目标：当我们去枚举每一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A_{i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的时候，我们相当于要从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A_{1} - A_{n}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间选出一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A_{j}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.969438em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;使得异或值最大，那么就相当于在我们选的时候，用Trie树进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于每一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A_{i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;我们都可以写成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;32&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进制的形式  &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;munder&gt;&lt;munder&gt;&lt;mn&gt;11010101010...0101110&lt;/mn&gt;&lt;mo stretchy=&#34;true&#34;&gt;⎵&lt;/mo&gt;&lt;/munder&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;/munder&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\underbrace{11010101010...0101110}_{32}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.943548em;vertical-align:-1.299108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord munder&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.6444400000000001em;&#34;&gt;&lt;span style=&#34;top:-1.700892em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0000000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord munder&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.64444em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-2.352em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;stretchy&#34; style=&#34;height:0.548em;min-width:1.6em;&#34;&gt;&lt;span class=&#34;brace-left&#34; style=&#34;height:0.548em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;0.548em&#39; viewBox=&#39;0 0 400000 548&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;span class=&#34;brace-center&#34; style=&#34;height:0.548em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;0.548em&#39; viewBox=&#39;0 0 400000 548&#39; preserveAspectRatio=&#39;xMidYMin slice&#39;&gt;&lt;path d=&#39;M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;span class=&#34;brace-right&#34; style=&#34;height:0.548em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;0.548em&#39; viewBox=&#39;0 0 400000 548&#39; preserveAspectRatio=&#39;xMaxYMin slice&#39;&gt;&lt;path d=&#39;M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.648em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.299108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，然后将每个数加进Trie树里面，  我们要做的就是&lt;strong&gt;从最高位开始尽可能找到不同的那个结点往下走&lt;/strong&gt;，每走一步，就会减去一半的规模，所以最后的时间复杂度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n log_{2} n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div align = &#34;center&#34;&gt;
    &lt;image src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20201112163612.png&#34; width = &#34;300&#34; height = &#34;300&#34;&gt;&lt;/image&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010, M = 3100010;

int son[M][2], idx;
int n;
int a[N];

void insert(int x) {
    int p = 0;
    for (int i = 30; i &amp;gt;= 0; i--) {
        // x &amp;gt;&amp;gt; i &amp;amp; 1：从高位开始取
        int u = son[p][x &amp;gt;&amp;gt; i &amp;amp; 1];
        if (!u)
            son[p][x &amp;gt;&amp;gt; i &amp;amp; 1] = ++idx;
        p = son[p][x &amp;gt;&amp;gt; i &amp;amp; 1];
    }
}

int query(int x) {
    int p = 0, res = 0; 
    for (int i = 30; i &amp;gt;= 0; i--) {
        // 从高位开始尽量寻找不同，这样异或出来是最大的
        int u = x &amp;gt;&amp;gt; i &amp;amp; 1;
        if (son[p][!u]) {
            res += 1 &amp;lt;&amp;lt; i;
            p = son[p][!u];
        }
        else
            p = son[p][u];
    }
    return res;
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; a[i];
        insert(a[i]);
    }
    
    int res = 0;
    for (int i = 0; i &amp;lt; n; i++) 
        res = max(res, query(a[i]));
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">浅谈Trie树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/zhan-dui-lie/"" data-c="
          &lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;栈是一种先进后出的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200907152616.png&#34; width = &#34;400&#34; height = &#34;400&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

const int N = 100010;

int stk[N], tt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;入栈&#34;&gt;入栈&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void push(int x) {
    stk[++tt] = x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;出栈&#34;&gt;出栈&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void pop() {
    tt--;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;判断栈是否为空&#34;&gt;判断栈是否为空&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool empty() {
    return tt &amp;lt;= 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;取栈顶元素&#34;&gt;取栈顶元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int getTop() {
    return stk[tt];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;队列是一种先进先出的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200907162120.png&#34; width = &#34;600&#34; height = &#34;300&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;h3 id=&#34;初始化-2&#34;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;

int q[N], hh, tt = -1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;入队&#34;&gt;入队&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 将x入队（入队元素放队尾）
 * @param x 
 */
void push (int x) {
    q[++tt] = x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;出队&#34;&gt;出队&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 对头元素出队
 */
void pop () {
    hh++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;判断队列是否为空&#34;&gt;判断队列是否为空&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 判断队列是否为空
 * @return true 
 * @return false 
 */
bool empty () {
    return hh &amp;gt; tt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获得队首元素&#34;&gt;获得队首元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 获得队首元素
 * @return int 
 */
int front () {
    return q[hh];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获得队尾元素&#34;&gt;获得队尾元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 获得队首元素
 * @return int 
 */
int front () {
    return q[hh];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;单调栈&#34;&gt;单调栈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单调栈：就是在操作栈的时候保持栈内元素保持单调（单调递增或单调递减）&lt;/li&gt;
&lt;li&gt;主要针对的问题：&lt;strong&gt;在一个数组中找到每个数左边比它小的最近的那个数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5
3 4 2 7 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-1 3 -1 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;暴力枚举&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 0; i &amp;lt; n; i++) {
    bool flag = false;
	for (int j = i - 1; j &amp;gt;= 0; j--) {
        if (a[j] &amp;lt; a[i]) {
            cout &amp;lt;&amp;lt; a[j] &amp;lt;&amp;lt; &#39; &#39;;
            flag = true;
        }
    }
    if (!flag)
        cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; &#39; &#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用单调栈&lt;/strong&gt;&lt;/p&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200907221354.png&#34; width = &#34;600&#34; height = &#34;350&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file monotoneStack.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-09-07 23:44:59
 * @brief 单调栈
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;

using namespace std;

int n;
stack&amp;lt;int&amp;gt; stk;

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        int x;
        cin &amp;gt;&amp;gt; x;
        while (!stk.empty() &amp;amp;&amp;amp; stk.top() &amp;gt;= x)
            stk.pop();
        // 说明找到了当前合适的元素
        if (!stk.empty())
            cout &amp;lt;&amp;lt; stk.top() &amp;lt;&amp;lt; &#39; &#39;;
        // 没有找到
        else
            cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; &#39; &#39;;
        stk.push(x);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;单调队列&#34;&gt;单调队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单调队列：就是在操作队列的时候保持队列内元素保持单调（单调递增或单调递减）&lt;/li&gt;
&lt;li&gt;主要针对的问题：&lt;strong&gt;固定滑动窗口中求最值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;deque&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：双端队列，队头队尾都可加入元素和删除元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一个大小为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的滑动窗口，它从数组的最左边移动到最右边。每次滑动窗口向右移动一个位置，您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;窗口位置&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最小值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最大值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[1 3 -1] -3 5 3 6 7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 [3 -1 -3] 5 3 6 7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 3 [-1 -3 5] 3 6 7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 3 -1 [-3 5 3] 6 7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 3 -1 -3 [5 3 6] 7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 3 -1 -3 5 [3 6 7]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200907233255.png&#34; width = &#34;600&#34; height = &#34;600&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file monotoneQueue.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-09-07 23:48:29
 * @brief 单调队列
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;deque&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 1000010;
// 序列长度为n、滑动窗口长度为k
int n, k;
int nums[N];
// 使用双端队列：队头和队尾都可加入元素和删除元素
deque&amp;lt;int&amp;gt; qu;

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;

    for (int i = 0; i &amp;lt; n; i++)
        cin &amp;gt;&amp;gt; nums[i];

    for (int i = 0; i &amp;lt; n; i++) {
        // 判断队头是否已经滑出窗口
        if (!qu.empty() &amp;amp;&amp;amp; i - k + 1 &amp;gt; qu.front())
            qu.pop_front();
        // 加入队列中的元素要满足单调
        while (!qu.empty() &amp;amp;&amp;amp; nums[qu.back()] &amp;gt;= nums[i])
            qu.pop_back();
        // 队列中存的是元素下标
        qu.push_back(i);
        // 队头是最小值
        if (i &amp;gt;= k - 1)
            cout &amp;lt;&amp;lt; nums[qu.front()] &amp;lt;&amp;lt; &#39; &#39;;
    }
    cout &amp;lt;&amp;lt; endl;
    qu.clear();

    for (int i = 0; i &amp;lt; n; i++) {
        if (!qu.empty() &amp;amp;&amp;amp; i - k + 1 &amp;gt; qu.front())
            qu.pop_front();
        while (!qu.empty() &amp;amp;&amp;amp; nums[qu.back()] &amp;lt;= nums[i])
            qu.pop_back();
        qu.push_back(i);
        if (i &amp;gt;= k - 1)
            cout &amp;lt;&amp;lt; nums[qu.front()] &amp;lt;&amp;lt; &#39; &#39;;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;栈实现队列&#34;&gt;栈实现队列&lt;/h2&gt;
&lt;p&gt;队列是一种先进先出的数据结构，栈是一种先进后出的数据结构。我们使用两个栈 &lt;code&gt;s1, s2&lt;/code&gt; 就能实现一个队列的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当调用 &lt;code&gt;push&lt;/code&gt; 让元素入队时，只要把元素压入 &lt;code&gt;s1&lt;/code&gt; 即可，比如说 &lt;code&gt;push&lt;/code&gt; 进 3 个元素分别是 1,2,3&lt;/li&gt;
&lt;/ul&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200908170247.png&#34; width = &#34;600&#34; height = &#34;250&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;那么如果这时候使用 &lt;code&gt;peek&lt;/code&gt; 查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在 &lt;code&gt;s1&lt;/code&gt; 中 1 被压在栈底，&lt;strong&gt;现在就要轮到 &lt;code&gt;s2&lt;/code&gt; 起到一个中转的作用&lt;/strong&gt;了：当 &lt;code&gt;s2&lt;/code&gt; 为空时，可以把 &lt;code&gt;s1&lt;/code&gt; 的所有元素取出再添加进 &lt;code&gt;s2&lt;/code&gt;，&lt;strong&gt;这时候 &lt;code&gt;s2&lt;/code&gt; 中元素就是先进先出顺序了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200908165825.png&#34; width = &#34;600&#34; height = &#34;300&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;pop&lt;/code&gt; 操作，只要操作 &lt;code&gt;s2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果两个栈都为空的话，就说明队列为空&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file MyQueue.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-09-08 15:53:57
 * @brief 使用栈实现队列
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;

using namespace std;

class MyQueue {
  private:
    stack&amp;lt;int&amp;gt; s1, s2;

  public:
    /**
     * @brief 添加元素到队尾
     * @param x 
     */
    void push(int x) {
        s1.push(x);
    }

    /**
     * @brief 返回队头元素
     * @return int 
     */
    int peek() {
        // s2为空的时候，把s1全部导入s2中
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        return s2.top();
    }

    /**
     * @brief 删除队头元素
     */
    void pop() {
        // 保证s2非空
        peek();
        s2.pop();
    }

    /**
     * @brief 判断队列是否为空
     * @return true 
     * @return false 
     */
    bool empty() {
        return s1.empty() &amp;amp;&amp;amp; s2.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;队列实现栈&#34;&gt;队列实现栈&lt;/h2&gt;
&lt;p&gt;如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt; ：直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200908180424.png&#34; width = &#34;400&#34; height = &#34;400&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;每次 &lt;code&gt;pop&lt;/code&gt;：把&lt;strong&gt;队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200908181011.png&#34; width = &#34;600&#34; height = &#34;350&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file MyStack.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-09-08 17:16:37
 * @brief 使用队列实现栈
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

class MyStack {
    private:
        queue&amp;lt;int&amp;gt; q;
        int top_element;
    public:
        /**
         * @brief 添加元素到栈顶
         * @param x 
         */
        void push(int x) {
            q.push(x);
            top_element = x;
        }

        /**
         * @brief 返回栈顶元素
         * @return int 
         */
        int top() {
            return top_element;
        }

        /**
         * @brief 删除栈顶元素 (把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头)
         */
        void pop() {
            int size = q.size();
            while (size &amp;gt; 1) {
                q.push(q.front());
                q.pop();
                size--;
            }
            // 删除栈顶元素
            q.pop();
            // 更新栈指针为队尾
            top_element = q.back();
        }

        /**
         * @brief 判断栈是否为空
         * @return true 
         * @return false 
         */
        bool empty() {
            return q.empty();
        }
};
&lt;/code&gt;&lt;/pre&gt;
">栈、队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/ni-huan-zai-yong-jie-gou-ti-cao-zuo-lian-biao-ma/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在算法考试中遇到链表的题目时，我们通常都不会使用结构体的方法来操作链表，对于C++而言，我们会频繁申请内存空间非常费时，因此我们可以考虑使用数组来实现链表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;单链表&#34;&gt;单链表&lt;/h2&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906152538.png&#34; width = &#34;500&#34; height = &#34;200&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e[N]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：存储节点值&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;value&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ne[N]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：存储某个节点的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针（下个值在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组中的下标）&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;head&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示头结点的下标&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示已经用到了哪个点&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;

int e[N], ne[N], idx, head;

/**
 * @brief 初始化
 */
void init () {
    head = -1;
    idx = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;插入到头节点&#34;&gt;插入到头节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;初始化当前节点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当前节点的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针指向头结点&lt;/li&gt;
&lt;li&gt;头结点重新指向当前结点，并使&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx++&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906153216.png&#34; width = &#34;600&#34; height = &#34;200&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 将x插到头结点
 * @param x 
 */
void add_to_head (int x) {
    // 初始化当前节点
    e[idx] = x;
    // 当前节点的next指针指向头节点
    ne[idx] = head;
    // 头节点重新指向当前节点，并使idx++（当前节点用过）
    head = idx++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;插入结点&#34;&gt;插入结点&lt;/h3&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906154145.png&#34; width = &#34;600&#34; height = &#34;250&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;初始化当前结点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当前节点的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针指向下标为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的结点的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针&lt;/li&gt;
&lt;li&gt;下标为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的结点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针指向当前结点，并使&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx++&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 将节点 x 插入到下标为 k 的节点的后面
 * @param k 
 * @param x 
 */
void add (int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;删除节点&#34;&gt;删除节点&lt;/h3&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906155030.png&#34; width = &#34;600&#34; height = &#34;300&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 将下标是k的点后面的点删除
 * @param k 
 */
void remove (int k) {
    ne[k] = ne[ne[k]];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;遍历&#34;&gt;遍历&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = head; i != -1; i = ne[i])
        cout &amp;lt;&amp;lt; e[i] &amp;lt;&amp;lt; &#39; &#39;;
    cout &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;双链表&#34;&gt;双链表&lt;/h2&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906164449.png&#34; width = &#34;600&#34; height = &#34;200&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e[N]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：存储节点值&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;value&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r[N]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：存储某个节点右边的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针（右边的值在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组中的下标）&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l[N]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：存储某个节点左边的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;next&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;指针（左边的值在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组中的下标）&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示已经用到了哪个点&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;初始化-2&#34;&gt;初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;初始化的时候一开始相当于就有两个结点，左端点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;head&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;右端点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;tail&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开始&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 100010;

int e[N], l[N], r[N], idx;

/**
 * @brief 初始化
 */
void init() {
    // 左端点head为0
    l[1] = 0;
    // 右端点tail为1
    r[0] = 1;
    idx = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;插入节点&#34;&gt;插入节点&lt;/h3&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906171043.png&#34; width = &#34;600&#34; height = &#34;300&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;初始化当前节点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当前节点的左指针指向节点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当前节点的右指针指向节点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;原来的右节点&lt;/li&gt;
&lt;li&gt;结点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;原来的右节点的左指针指向当前节点&lt;/li&gt;
&lt;li&gt;结点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的右指针指向当前节点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，并使&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;idx++&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 在节点a的右边插入一个数x
 * @param a 
 * @param x 
 */
void insert (int a, int x) {
    e[idx] = x;
    l[idx] = a;
    r[idx] = r[a];
    l[r[a]] = idx;
    r[a] = idx++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;删除节点-2&#34;&gt;删除节点&lt;/h3&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200906172604.png&#34; width = &#34;650&#34; height = &#34;300&#34;&gt;&lt;/img&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 删除节点a
 * @param a 
 */
void remove (int a) {
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;遍历-2&#34;&gt;遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;初始化是以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为两个空点加入双链表，所以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的右边就是第一个点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r[0]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的左边就是最后一个点&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l[1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = r[0]; i != 1; i = r[i]) 
    cout &amp;lt;&amp;lt; e[i] &amp;lt;&amp;lt; &#39; &#39;;
cout &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
">你还在用结构体操作链表吗？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/yi-wen-gao-ding-pai-xu-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;对于排序算法，网上有很多文章，也有很多种不同风格的实现，这里就所有的排序算法做一个汇总，部分代码参考了网上的博客，精选出一些优质答案，方便理解和记忆，并且所有的代码均在OJ平台上测试通过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;这里的所有排序算法的实现，均统一了方法调用的接口：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;...Sort(array, n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;array&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为待排序数组，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为数组长度&lt;/p&gt;
&lt;/br&gt;
&lt;p&gt;排序动图可参考&lt;a href=&#34;https://www.runoob.com/w3cnote/ten-sorting-algorithm.html&#34;&gt;十大经典排序算法&lt;/a&gt;&lt;/p&gt;
&lt;div align = &#34;center&#34;&gt;&lt;img src = &#34;https://kay-rick.oss-cn-beijing.aliyuncs.com/img/image-20200816112230352.png&#34; width = 650 height = 500&gt;&lt;/img&gt;&lt;/div&gt;
&lt;/br&gt;
&lt;h2 id=&#34;排序算法复杂度&#34;&gt;排序算法复杂度&lt;/h2&gt;
&lt;/br&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;排序方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;平均时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最坏时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最好时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;空间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冒泡排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;插入排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;选择排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;希尔排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;1.3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^{1.3})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;归并排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;快速排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;堆排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog_{2}n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;计数排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基数排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n × k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n × k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n × k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;桶排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;基数排序、基数排序、桶排序中：n表示数据个数，k表示数据位数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定&lt;/strong&gt;：如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;原本在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前面，而&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a = b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，排序之后&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;仍然在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不稳定&lt;/strong&gt;：如果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;原本在&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的前面，而&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a=b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，排序之后&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可能会出现在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的后面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：对排序数据的总的操作次数。反映当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;变化时，操作次数呈现什么规律。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;辅助记忆&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度记忆
&lt;ul&gt;
&lt;li&gt;冒泡、选择、直接 排序需要两个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;for&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;循环，每次只关注一个元素，平均时间复杂度为（一遍找元素，一遍找位置）&lt;/li&gt;
&lt;li&gt;快速、归并、希尔、堆基于二分思想，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;log&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为底，平均时间复杂度为（一遍找元素，一遍找位置）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;稳定性记忆
&lt;ul&gt;
&lt;li&gt;“快希选堆”（快牺牲稳定性）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换它们两个&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个&lt;/li&gt;
&lt;li&gt;重复步骤1~3，直到排序完成&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
/**
 * @brief 冒泡排序(从小到大)
 * @param array 
 * @param n 
 */
void bubbleSort (int array[], int n) {
    // 开始进行遍历 ==&amp;gt;控制判断的次数
    for (int i = 0; i &amp;lt; n; i++) {
        bool flag = false;  // 记录有无数据交换
        // 内循环 ==&amp;gt; 相邻数字的比较和移动
        for (int j = 0; j &amp;lt; n - 1 - i; j++) {
            // j &amp;lt; n - 1 - i这里 -i 是因为后面已经排好
            if (array[j] &amp;gt; array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                flag = true;
            }
        }
        if (!flag)
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;
&lt;p&gt;首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个记录的直接选择排序可经过 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;趟直接选择排序得到有序结果。具体算法描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始状态：无序区为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1..&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1..n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，有序区为空&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;趟排序&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(i = 1,2,3…n - 1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开始时，当前有序区和无序区分别为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1..&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1..i - 1] 和 R(i..n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。该趟排序&lt;strong&gt;从当前无序区中选出关键字最小的记录 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[k]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，将它与无序区的第1个记录R交换&lt;/strong&gt;，使&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1..&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1..&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1..i] 和R[i+1..n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;趟结束，数组有序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
/**
 * @brief 选择排序
 * @param array 
 * @param n 
 */
void selectSort (int array[], int n) {
    // 进行 n - 1轮比较
    for (int i = 0;i &amp;lt; n - 1; i++) {
        int min = i;
        // 找最小的元素
        for (int j = i + 1; j &amp;lt; n; j++) {
            // 记录目前能找最小元素值的下标
            if (array[j] &amp;lt; array[min]) 
                min = j;
        }
        // 将找到的最小元素和i下标的最小元素进行交换
        if (i != min) {
            int temp = array[i];
            array[i] = array[min];
            array[min] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;表现最稳定的排序算法之一&lt;/strong&gt;，因为无论什么数据进去都是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;插入排序&#34;&gt;插入排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从第一个元素开始，&lt;strong&gt;该元素可以认为已经被排序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;取出下一个元素，&lt;strong&gt;在已经排序的元素序列中从后向前扫描&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3，&lt;strong&gt;直到找到已排序的元素小于或者等于新元素的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;重复步骤2~5&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
/**
 * @brief 插入排序
 * @param array 
 * @param n 
 */
void insertSort (int array[], int n) {
    for (int i = 1; i &amp;lt; n; i++) {
        // 记录当前元素
        int temp = array[i];
        int j = i;
        // 在有序序列中从后往前找到空位
        while (j &amp;gt;= 1 &amp;amp;&amp;amp; array[j - 1] &amp;gt; temp) {
            array[j] = array[j - 1];
            j--;
        }
        // 插入
        array[j] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h2&gt;
&lt;p&gt;1959年Shell发明，第一个突破&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于：&lt;strong&gt;它会优先比较距离较远的元素&lt;/strong&gt;。希尔排序又叫&lt;strong&gt;缩小增量排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择一个增量序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t1，t2，…，tk&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ti&amp;gt;tj，tk=1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69862em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;按增量序列个数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，对序列进行&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;趟排序；&lt;/li&gt;
&lt;li&gt;每趟排序，根据对应的增量&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ti&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，将待排序列分割成若干长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;m&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的子序列，分别对各子表进行直接插入排序。仅增量因子为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
/**
 * @brief 希尔排序 ==&amp;gt; 增量序列 + 插入排序(插入排序的高效改进算法)
 * @param array 
 * @param n 
 */
void shellSort(int array[], int n) {
    int d = n / 2;
    int j, temp;
    // 引入增量 d
    while (d &amp;gt; 0) {
        // 每一趟相当于以 d 为步数的插入排序
        for (int i = d; i &amp;lt; n; i++) {
            temp = array[i];
            j = i;
            // 查找插入的位置，这里j &amp;gt;= d放在前面，短路运算会直接跳出循环
            while (j &amp;gt;= d &amp;amp;&amp;amp; array[j - d] &amp;gt; temp) {
                array[j] = array[j - d];
                j -= d;
            }
            // 插入排序
            array[j] = temp;
        }
        d /= 2;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;p&gt;归并排序是建立在归并操作上的一种有效的排序算法。&lt;strong&gt;该算法是采用分治法（Divide and Conquer）的一个非常典型的应用&lt;/strong&gt;。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的输入序列分成两个长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n/2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的子序列；&lt;/li&gt;
&lt;li&gt;对这两个子序列分别采用归并排序；&lt;/li&gt;
&lt;li&gt;将两个排序好的子序列合并成一个最终的排序序列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
/**
 * @brief 一次归并
 * @param array 一次需要归并的数组
 * @param temp 临时数组
 * @param start 数组起始位置
 * @param mid 数组中间位置
 * @param end 数组末尾位置
 */
void _merge(int array[], int temp[], int start, int mid, int end) {
    int i = start;
    int j = mid + 1;
    int k = 0;
    // 归并操作
    while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end) {
        if (array[i] &amp;lt;= array[j])
            temp[k++] = array[i++];
        else
            temp[k++] = array[j++];
    }
    while (i &amp;lt;= mid) 
        temp[k++] = array[i++];
    while (j &amp;lt;= end)
        temp[k++] = array[j++];
    // 将排好序的存回 array 中 start 到 end 这区间
    for (int i = start, k = 0; i &amp;lt;= end; i++, k++) {
        array[i] = temp[k];
    }
}
/**
 * @brief 归并排序核心递归函数 ==&amp;gt; 分类比武,不断进行归并 
 * @param array 
 * @param temp 
 * @param start 
 * @param end 
 */
void mSort (int array[], int temp[], int start, int end) {
    if (start &amp;lt; end) {
        int mid = (start + end) / 2;
        mSort(array, temp, start, mid);
        mSort(array, temp, mid + 1, end);
        _merge(array, temp, start, mid, end);
    }
}
/**
 * @brief 归并排序
 * @param array 
 * @param n 
 */
void mergeSort (int array[], int n) {
    // 将temp数组声明在外部是为了防止在merge函数里面频繁申请释放空间带来的开销
    int* temp = new int[n];
    if (temp != NULL) {
        mSort(array, temp, 0, n - 1);
        delete []temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。&lt;/p&gt;
&lt;p&gt;快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从数列中挑出一个元素，称为 “基准”（pivot）；&lt;/li&gt;
&lt;li&gt;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；&lt;/li&gt;
&lt;li&gt;递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
/**
 * @brief 快速排序核心递归函数
 * @param array 
 * @param left 
 * @param right 
 */
void qSort (int array[], int left, int right) {
    if (left &amp;gt;= right)
        return;
    // 一般我们选用中间的元素为基准
    int pivot = array[left + right &amp;gt;&amp;gt; 1];
    // 指针都先从边界开始
    int low = left - 1, high = right + 1;
    // 将序列中比基准小的移到基准左边，大的移到右边
    while (low &amp;lt; high) {
        while (array[++low] &amp;lt; pivot);
        while (array[--high] &amp;gt; pivot);
        if (low &amp;lt; high)
            swap(array[low], array[high]);
    }
    qSort(array, left, high);
    qSort(array, high + 1, right);
}
/**
 * @brief 快速排序 ==&amp;gt; 时间复杂度O(nlog n), 空间复杂度O(log n)
 * @param array 
 * @param n 
 */
void quickSort (int array[], int n) {
    qSort(array, 0, n - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;堆排序&#34;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：&lt;strong&gt;即子结点的键值或索引总是小于（或者大于）它的父节点&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将初始待排序关键字序列&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(R1,R2….Rn)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;构建成大顶堆，此堆为初始的无序区&lt;/li&gt;
&lt;li&gt;将堆顶元素&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与最后一个元素&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;交换，此时得到新的无序区&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(R1,R2,……Rn-1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和新的有序区&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(Rn)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,且满足&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1,2…n-1]&amp;lt;=R[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;由于交换后新的堆顶&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可能违反堆的性质，因此需要对当前无序区&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(R1,R2,……Rn-1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;调整为新堆，然后再次将&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R[1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与无序区最后一个元素交换，得到新的无序区&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(R1,R2….Rn-2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和新的有序区&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(Rn-1,Rn)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。不断重复此过程直到有序区的元素个数为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，则整个排序过程完成&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 向下过滤，将N个元素的数组中以array[p]为根的子堆调整为最大堆
 * @param array 待过滤数组
 * @param p 根节点编号
 * @param N 数组长度
 */
void PercDown(int array[], int p, int N) {
    int parent, child;
    // 取出根结点存放的值
    int X = array[p];
    for (parent = p; (parent * 2 + 1) &amp;lt; N; parent = child) {
        // 从0开始，不同之前堆是从 1 开始
        child = parent * 2 + 1;
        // child指向左右子结点的较大者
        if ((child != N - 1) &amp;amp;&amp;amp; (array[child] &amp;lt; array[child + 1]))
            child++;
        // 找到了合适位置，跳出循环
        if (X &amp;gt;= array[child])
            break; 
        else       /* 下滤X */
            array[parent] = array[child];
    }
    array[parent] = X;
}

/**
 * @brief 堆排序 时间复杂度 O(nlog n) 空间复杂度
 * @param array 待排序数组
 * @param N 数组长度
 */
void HeapSort(int array[], int N) {
    int i;
    // 从第一个非叶子节点开始，从右至左调整结构，建立最大堆
    for (i = N / 2; i &amp;gt;= 0; i--) 
        PercDown(array, i, N);
    // 调整堆结构 + 交换堆顶元素与末尾元素
    for (i = N - 1; i &amp;gt; 0; i--) {
        // 不断删除堆顶元素
        swap(array[0], array[i]);
        PercDown(array, 0, i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;桶排序&#34;&gt;桶排序&lt;/h2&gt;
&lt;p&gt;桶排序是计数排序的升级版。&lt;strong&gt;它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定&lt;/strong&gt;。桶排序 (Bucket sort)的工作的原理：&lt;strong&gt;假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序&lt;/strong&gt;（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置一个定量的数组当作空桶，桶排序的思想近乎彻底的&lt;strong&gt;分治思想&lt;/strong&gt;。桶排序假设待排序的一组数均匀独立的分布在一个范围中，&lt;strong&gt;并将这一范围划分成几个子范围&lt;/strong&gt;（桶）&lt;/li&gt;
&lt;li&gt;遍历输入数据，并且把数据一个一个放到对应的桶里去&lt;/li&gt;
&lt;li&gt;对每个不是空的桶进行排序&lt;/li&gt;
&lt;li&gt;从不是空的桶里把排好序的数据拼接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
// 桶的默认数量
int DEFAULT_BUCKET_SIZE = 5;

void bucketSort(int array[], int n) {
    if (n &amp;lt; 1)
        return;
    int max_element = array[0];
    int min_element = array[0];

    // 找出数组的最大值和最小值
    for (int i = 0; i &amp;lt; n; i++) {
        if (array[i] &amp;gt; max_element)
            max_element = array[i];
        if (array[i] &amp;lt; min_element)
            min_element = array[i];
    }
    int bucketSize = DEFAULT_BUCKET_SIZE;
    int bucketCount = ((max_element - min_element) / bucketSize) + 1;

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; buckets(bucketCount);
    vector&amp;lt;int&amp;gt; res;
    // 利用映射函数将数据分配到各个桶中
    for (int i = 0; i &amp;lt; n; i++)
        buckets[(array[i] - min_element) / bucketSize].push_back(array[i]);
    
    for (int i = 0; i &amp;lt; buckets.size(); i++) {
        // 每个桶内部进行排序
        sort(buckets[i].begin(), buckets[i].end());
        for (int j = 0; j &amp;lt; buckets[i].size(); j++)
            res.push_back(buckets[i][j]);
    }

    // 将vector中数据覆盖到原数组
    for (int i = 0; i &amp;lt; res.size(); i++)
        array[i] = res[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;计数排序&#34;&gt;计数排序&lt;/h2&gt;
&lt;p&gt;计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，&lt;strong&gt;计数排序要求输入的数据必须是有确定范围的整数，计数排序其实是特殊的桶排序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找出待排序的数组中最大和最小的元素&lt;/li&gt;
&lt;li&gt;统计数组中每个值为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的元素出现的次数，存入数组&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对所有的计数累加（从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;中的第一个元素开始，每一项和前一项相加，为了使排序稳定的一种策略）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;反向填充目标数组：将每个元素&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;放在新数组的第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C(i)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;项，每放一个元素就将&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C(i)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;减去&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
/**
 * @brief 计数排序
 * @param array 
 * @param n 
 */
void countSort(int array[], int n) {
    if (n &amp;lt; 1)
        return;
    // 1. 得到数组的最大值和最小值，算出差值
    int max_element = array[0];
    int min_element = array[0];
    for (int i = 1; i &amp;lt; n; i++) {
        max_element = max(max_element, array[i]);
        min_element = min(min_element, array[i]);
    }
    int d = max_element - min_element;
    // 2. 创建统计数组并计算统计对应元素个数
    int* count = new int[d + 1];
    for (int i = 0; i &amp;lt; n; i++)
        count[array[i] - min_element]++;
    // 3. 统计数组变形，后面的元素等于前面的元素之和 ==&amp;gt; 使排序稳定的一种策略
    int sum = 0;
    for (int i = 0; i &amp;lt; d + 1; i++) {
        sum += count[i];
        count[i] = sum;
    }
    // 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组
    int *sortedArray = new int[n];
    for (int i = n - 1; i &amp;gt;= 0; i--)
        sortedArray[--count[array[i] - min_element]] = array[i];

    for (int i = 0; i &amp;lt; n; i++)
        array[i] = sortedArray[i];
    delete[] sortedArray;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计数排序是一个稳定的排序算法&lt;/strong&gt;。当输入的元素是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 之间的整数时，时间复杂度是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n+k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，空间复杂度也是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n+k)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，其排序速度快于任何比较排序算法。当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;基数排序&#34;&gt;基数排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位&lt;/strong&gt;。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取得数组中的最大数，并取得位数&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;array&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为原始数组，从最低位开始取每个位组成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;radix&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数组&lt;/li&gt;
&lt;li&gt;对&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;radix&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进行计数排序（利用计数排序适用于小范围数的特点）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

/**
 * @brief 获取数组array中数据最大位数
 * @param array 
 * @param n 
 * @return int 
 */
int maxbit(int array[], int n) {
    if (n &amp;lt; 1)
        return 0;
    int max_element = array[0];
    for (int i = 1; i &amp;lt; n; i++) 
        max_element = max(max_element, array[i]);
    int d = 0;
    while(max_element &amp;gt; 0) {
        max_element /= 10;
        d++;
    }
    return d;
}

/**
 * @brief 基数排序
 * @param array 
 * @param n 
 */
void radixSort(int array[], int n) {
    int d = maxbit(array, n);
    int* temp = new int[n];
    // 计数器
    int* count = new int[10];
    int radix = 1;
    // 进行d次排序
    for (int i = 0; i &amp;lt; d; i++) {
        // 每次分配前清空计数器
        for (int j = 0; j &amp;lt; 10; j++) 
            count[j] = 0;
        for (int j = 0; j &amp;lt; n; j++) {
            int k = (array[j] / radix) % 10;
            count[k]++;
        }
        // 将temp中位置依次分配给每个桶
        for (int j = 1; j &amp;lt; 10; j++)
            count[j] = count[j] + count[j - 1];
        // 将所有桶中记录依次收集到temp中
        for (int j = n - 1; j &amp;gt;= 0; j--) {
            int k = (array[j] / radix) % 10;
            temp[count[k] - 1] = array[j];
            count[k]--;
        }
        // 将临时数组的内容复制到原数组
        for (int j = 0; j &amp;lt; n; j++)
            array[j] = temp[j];
        
        radix *= 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;桶排序基数排序计数排序&#34;&gt;桶排序&amp;amp;基数排序&amp;amp;计数排序&lt;/h2&gt;
&lt;p&gt;这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基数排序：根据键值的每位数字来分配桶&lt;/li&gt;
&lt;li&gt;计数排序：每个桶只存储单一键值&lt;/li&gt;
&lt;li&gt;桶排序：每个桶存储一定范围的数值&lt;/li&gt;
&lt;/ul&gt;
">一文搞定排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/tu-lun-shi-zhan-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇就PAT上图论相关习题做一个总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;dijkstra&#34;&gt;Dijkstra&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376&#34;&gt;紧急情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392&#34;&gt;旅行计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984&#34;&gt;条条大路通罗马&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856&#34;&gt;在线地图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072&#34;&gt;加油站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;紧急情况&#34;&gt;紧急情况&lt;/h3&gt;
&lt;p&gt;作为城市的紧急救援团队负责人，你将获得一张你所在国家的特殊地图。&lt;/p&gt;
&lt;p&gt;该地图显示了一些通过道路连接的分散城市，&lt;strong&gt;道路是双向的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;地图上标出了每个城市的救援队数量以及每对城市之间的每条道路的长度。&lt;/p&gt;
&lt;p&gt;当其他城市发出紧急求援信息时，你的工作是尽快带领你的士兵前往该地点，同时，在途中尽可能多地调动救援帮手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含四个整数 N，表示城市数量（城市编号从 0 到 N−1），M 表示道路数量，C1 表示你当前所在的城市编号，C2 表示发出紧急求援信息的城市编号。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个整数，其中第 i 个整数表示城市 i 的救援队数量。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含三个整数 c1,c2,Li，表示城市 c1 和城市 c2 之间存在一条道路相连，道路长度为 Li。&lt;/p&gt;
&lt;p&gt;数据保证 C1 和 C2 之间至少存在一条路径相连。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，两个整数，第一个整数表示 C1 和 C2 之间最短路的数量，第二个整数表示走最短路的情况下，能聚集到的救援队最大数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2≤N≤500,&lt;br&gt;
1≤M≤600,&lt;br&gt;
1≤Li≤200,&lt;br&gt;
每个城市包含的救援人员数量不超过 200。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;

const int N = 510;
const int M = 610;

int g[N][N];
bool st[N];
int dist[N], cnt[N], sum[N];
int w[N];

int n, m, S, T;

void dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[S] = 0;
    cnt[S] = 1;
    sum[S] = w[S];
    
    for (int i = 0; i &amp;lt; n; i++) {
        int t = -1;
        // 在未加入的集合S中
        for (int j = 0; j &amp;lt; n; j++) {
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        }
        st[t] = true;
        
        for (int j = 0; j &amp;lt; n; j++) {
            // 如果被t更新，最短路径数量等于t的路径数量
            if (dist[j] &amp;gt; dist[t] + g[t][j]) {
                dist[j] = dist[t] + g[t][j];
                cnt[j] = cnt[t];
                sum[j] = sum[t] + w[j];
            }
            // 多条相同路径相同，把路径数量累加，并记录最大的救援人数
            else if (dist[j] == dist[t] + g[t][j]) {
                cnt[j] += cnt[t];
                sum[j] = max(sum[j], sum[t] + w[j]);
            }
        }
    }
    
}


int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; S &amp;gt;&amp;gt; T;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; w[i];
    }
    memset(g, 0x3f, sizeof g);
    while (m--) {
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        // 无向图 + 消除重复边
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    
    dijkstra();
    cout &amp;lt;&amp;lt; cnt[T] &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; sum[T] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;旅行计划&#34;&gt;旅行计划&lt;/h3&gt;
&lt;p&gt;给定一张地图，包含 N 个城市，M 条高速公路。&lt;/p&gt;
&lt;p&gt;城市之间都能相互连通。&lt;/p&gt;
&lt;p&gt;每条高速公路的长度和走该条公路的花费都是已知的，高速公路都是&lt;strong&gt;双向&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;现在要从地图中的某个城市前往另一个城市。&lt;/p&gt;
&lt;p&gt;请你确定最短路径，当最短路径不唯一时，请你选取花费最小的路径（保证唯一）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含四个整数 N,M,S,D，分别表示城市数量，公路数量，起点城市编号，终点城市编号。&lt;/p&gt;
&lt;p&gt;城市编号从 0 到 N−1。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含四个整数 a,b,c,d，表示城市 a 和城市 b 之间存在一条公路，长度为 c，花费为 d。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，首先输出从起点城市到终点城市的最短路径（花费最少的）经过的所有城市，然后输出最短路径的距离以及最小的花费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤500,&lt;br&gt;
1≤M≤600,&lt;br&gt;
1≤c,d≤500&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 5 0 3
0 1 1 20
1 3 2 30
0 3 4 10
0 2 2 20
2 3 1 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 2 3 3 40
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

const int N = 510;

int g[N][N], w[N][N];
int dist[N], cost[N];
int pre[N];
bool st[N];
vector&amp;lt;int&amp;gt; path;

int n, m , S, D;

void dijkstra () {
    memset(dist, 0x3f, sizeof dist);
    memset(cost, 0x3f, sizeof cost);
    dist[S] = 0, cost[S] = 0;
    for (int i = 0; i &amp;lt; n; i++) {
        int t = -1;
        for (int j = 0; j &amp;lt; n; j++) {
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        }
        st[t] = true;
        
        for (int j = 0; j &amp;lt; n; j++) {
            // 每次更新j的时候，pre[j]记录前驱结点为t，最后将pre逆序输出就是路径
            if (dist[j] &amp;gt; dist[t] + g[t][j]) {
                dist[j] = dist[t] + g[t][j];
                cost[j] = cost[t] + w[t][j];
                pre[j] = t;
            }
            // 路径相等情况下，记录最小的开销
            else if (dist[j] == dist[t] + g[t][j] &amp;amp;&amp;amp; cost[j] &amp;gt; cost[t] + w[t][j]) {
                cost[j] = cost[t] + w[t][j];
                pre[j] = t;
            }
        }
    }
}


int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; S &amp;gt;&amp;gt; D;
    memset(g, 0x3f, sizeof g);
    memset(w, 0x3f, sizeof w);
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b, c, d;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;
        g[a][b] = g[b][a] = min(g[a][b], c);
        w[a][b] = w[b][a] = min(w[a][b], d);
    }
    
    dijkstra();
    // 输出路径
    for (int i = D; i != S; i = pre[i]) 
        path.push_back(i);
    cout &amp;lt;&amp;lt; S;
    for (int i = path.size() - 1; i &amp;gt;= 0; i--) {
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; path[i];
    }
    cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; dist[D] &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; cost[D] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;条条大路通罗马&#34;&gt;条条大路通罗马&lt;/h3&gt;
&lt;h3 id=&#34;在线地图&#34;&gt;在线地图&lt;/h3&gt;
&lt;p&gt;输入我们的当前位置和目的地，在线地图就可以推荐一些行进路线。&lt;/p&gt;
&lt;p&gt;现在你的工作是向用户推荐两条路线：一条是最短路线，另一条是最快路线。&lt;/p&gt;
&lt;p&gt;保证任何询问的两地之间都存在至少一条路线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 N 和 M，表示地图中共有 N 个路口（编号 0∼N−1）和 M 个街道。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行描述一条街道，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;V1 V2 one-way length time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;V1&lt;/code&gt; 和 &lt;code&gt;V2&lt;/code&gt; 是两个路口的编号，表示这两个路口之间存在一条街道，&lt;code&gt;one-way&lt;/code&gt; 如果为 1 则表示这条街道是单行道，只能从 &lt;code&gt;V1&lt;/code&gt; 前往 &lt;code&gt;V2&lt;/code&gt;。如果为 0 表示是双行道，可随意通行。 &lt;code&gt;length&lt;/code&gt; 是街道的长度，&lt;code&gt;time&lt;/code&gt; 是通过这条街道花费的时间。&lt;/p&gt;
&lt;p&gt;最后一行，将给出起点和终点路口的编号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输出路程最短的路线，并输出最短路程 D，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Distance = D: source -&amp;gt; v1 -&amp;gt; ... -&amp;gt; destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二行输出用时最快的路线，并输出最短用时 T，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Time = T: source -&amp;gt; w1 -&amp;gt; ... -&amp;gt; destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果最短路线不唯一，则输出用时最短的那条路线（保证唯一）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果最快路线不唯一，则输出经过路口最少的那条路线（保证唯一）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果最短路线和最快路线是同一条路线，则以如下格式将两个信息输出在一行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Distance = D; Time = T: source -&amp;gt; u1 -&amp;gt; ... -&amp;gt; destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2≤N≤500,&lt;br&gt;
1≤M≤N(N−1)2,&lt;br&gt;
每条道路的长度和用时都不超过 1000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 15
0 1 0 1 1
8 0 0 1 1
4 8 1 1 1
3 4 0 3 2
3 9 1 4 1
0 6 0 1 1
7 5 1 2 1
8 5 1 2 1
2 3 0 2 2
2 1 1 1 1
1 3 0 3 1
1 4 0 1 1
9 7 1 3 1
5 1 0 5 2
6 5 1 1 2
3 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Distance = 6: 3 -&amp;gt; 4 -&amp;gt; 8 -&amp;gt; 5
Time = 3: 3 -&amp;gt; 1 -&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7 9
0 4 1 1 1
1 6 1 1 3
2 6 1 1 1
2 5 1 2 2
3 0 0 1 1
3 1 1 1 3
3 2 1 1 2
4 5 0 2 2
6 5 1 1 2
3 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Distance = 3; Time = 4: 3 -&amp;gt; 2 -&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
const int N = 510;

int g1[N][N], g2[N][N];
int dist1[N], dist2[N], pre[N];
bool st[N];
int S, D;
int n, m;

pair&amp;lt;int, string&amp;gt; dijkstra(int d1[][N], int d2[][N], int type) {
    memset(dist1, 0x3f, sizeof dist1);
    memset(dist2, 0x3f, sizeof dist2);
    memset(st, 0, sizeof st);
    dist1[S] = 0;
    dist2[S] = 0;

    for (int i = 0; i &amp;lt; n; i++) {
        int t = -1;
        // 找到一个最小权值
        for (int j = 0; j &amp;lt; n; j++) {
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist1[t] &amp;gt; dist1[j]))
                t = j;
        }
        st[t] = true;
        for (int j = 0; j &amp;lt; n; j++) {
            int w;
            // 区分是哪种类型
            if (type == 0)
                w = d2[t][j];
            else
                w = 1;

            if (dist1[j] &amp;gt; dist1[t] + d1[t][j]) {
                dist1[j] = dist1[t] + d1[t][j];
                dist2[j] = dist2[t] + w;
                pre[j] = t;
            } else if (dist1[j] == dist1[t] + d1[t][j]) {
                if (dist2[j] &amp;gt; dist2[t] + w) {
                    dist2[j] = dist2[t] + w;
                    pre[j] = t;
                }
            }
        }
    }

    pair&amp;lt;int, string&amp;gt; results;
    vector&amp;lt;int&amp;gt; path;

    for (int i = D; i != S; i = pre[i])
        path.push_back(i);

    results.first = dist1[D];
    results.second = to_string(S);
    for (int i = path.size() - 1; i &amp;gt;= 0; i--) {
        results.second += &amp;quot; -&amp;gt; &amp;quot; + to_string(path[i]);
    }

    return results;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    memset(g1, 0x3f, sizeof g1);
    memset(g2, 0x3f, sizeof g2);

    while (m--) {
        int v1, v2, way, length, times;
        cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2 &amp;gt;&amp;gt; way &amp;gt;&amp;gt; length &amp;gt;&amp;gt; times;
        if (way == 1) {
            g1[v1][v2] = min(g1[v1][v2], length);
            g2[v1][v2] = min(g2[v1][v2], times);
        } else {
            g1[v1][v2] = g1[v2][v1] = min(g1[v1][v2], length);
            g2[v1][v2] = g2[v2][v1] = min(g2[v1][v2], times);
        }
    }

    cin &amp;gt;&amp;gt; S &amp;gt;&amp;gt; D;
    auto A = dijkstra(g1, g2, 0);
    auto B = dijkstra(g2, g1, 1);

    if (A.second == B.second) {
        cout &amp;lt;&amp;lt; &amp;quot;Distance = &amp;quot; &amp;lt;&amp;lt; A.first &amp;lt;&amp;lt; &amp;quot;; &amp;quot;
             &amp;lt;&amp;lt; &amp;quot;Time = &amp;quot; &amp;lt;&amp;lt; B.first &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; B.second &amp;lt;&amp;lt; endl;
    } else {
        cout &amp;lt;&amp;lt; &amp;quot;Distance = &amp;quot; &amp;lt;&amp;lt; A.first &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; A.second &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;Time = &amp;quot; &amp;lt;&amp;lt; B.first &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; B.second &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;加油站&#34;&gt;加油站&lt;/h3&gt;
&lt;p&gt;加油站的建造位置必须使加油站与距离它最近的房屋的距离尽可能远。&lt;/p&gt;
&lt;p&gt;与此同时，它还必须保证所有房屋都在其服务范围内。&lt;/p&gt;
&lt;p&gt;现在，给出了城市地图和加油站的几个候选位置，请你提供最佳建议。&lt;/p&gt;
&lt;p&gt;如果有多个解决方案，请输出选取位置与所有房屋的平均距离最小的解决方案。&lt;/p&gt;
&lt;p&gt;如果这样的解决方案仍然不是唯一的，请输出选取位置编号最小的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含四个整数 N，房屋总数，M，加油站的候选位置总数，K，连接房屋或加油站的道路总数，Ds 加油站的最大服务范围。&lt;/p&gt;
&lt;p&gt;所有房屋的编号从 1 到 N，所有加油站侯选位置编号从 &lt;code&gt;G1&lt;/code&gt; 到 &lt;code&gt;GM&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来 K 行，每行格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;P1 P2 Dist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;P1&lt;/code&gt; 和 &lt;code&gt;P2&lt;/code&gt; 表示一条 &lt;strong&gt;无向&lt;/strong&gt; 道路连接的两个房屋或加油站侯选位置的编号，&lt;code&gt;Dist&lt;/code&gt; 是道路长度，这是一个整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输出所选位置的编号。&lt;/p&gt;
&lt;p&gt;第二行输出加油站与距离其最近的房屋之间的距离以及与所有房屋之间的平均距离，&lt;strong&gt;精确到小数后一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果解决方案不存在，则输出 &lt;code&gt;No Solution&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤103,&lt;br&gt;
1≤M≤10,&lt;br&gt;
1≤K≤104,&lt;br&gt;
1≤Ds≤200,&lt;br&gt;
1≤Dist≤5000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 3 11 5
1 2 2
1 4 2
1 G1 4
1 G2 3
2 3 2
2 G2 1
3 4 2
3 G3 2
4 G1 3
G2 G1 1
G3 G2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;G1
2.0 3.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 1 2 10
1 G1 9
2 G1 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;No Solution
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 1020;
const int INF = 0x3f3f3f3f;
int n, m, k, D;
int g[N][N];
int dist[N];
bool st[N];

// 对两种编号进行处理
int get(string s) {
    if (s[0] == &#39;G&#39;)
        return n + stoi(s.substr(1));
    else
        return stoi(s);
}

void dijkstra(int start, int&amp;amp; min_dist, int&amp;amp; sum_dist) {
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[start] = 0;
    for (int i = 0; i &amp;lt; n + m; i++) {
        int t = -1;
        for (int j = 1; j &amp;lt;= n + m; j++) {
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        }
        st[t] = true;
        
        for (int j = 1; j &amp;lt;= n + m; j++) 
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    
    // 判断是否都在服务范围内
    for (int i = 1; i &amp;lt;= n; i++) {
        if (dist[i] &amp;gt; D) {
            min_dist = -INF;
            return;
        }
    }
    min_dist = INF;
    sum_dist = 0;
    // 找到最近距离和总距离
    for (int i = 1; i &amp;lt;= n; i++) {
        min_dist = min(min_dist, dist[i]);
        sum_dist += dist[i];
    }
    
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k &amp;gt;&amp;gt; D;
    memset(g, 0x3f, sizeof g);
    while (k--) {
        string a, b;
        int c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        int x = get(a);
        int y = get(b);
        g[x][y] = g[y][x] = min(g[x][y], c); 
    }
    
    // 枚举每个加油站
    
    // 记录加油站是否合适
    int res = -1;
    // 记录加油站距离最近房屋的最大值
    int min_dist = 0;
    // 记录总距离的最小值
    int sum_dist = INF;
    
    for (int i = n + 1; i &amp;lt;= n + m; i++) {
        int d1, d2;
        dijkstra(i, d1, d2);
        if (d1 &amp;gt; min_dist) {
            res = i;
            min_dist = d1;
            sum_dist = d2;
        }
        else if (min_dist == d1 &amp;amp;&amp;amp; sum_dist &amp;gt; d2) {
            res = i;
            sum_dist = d2;
        }
    }
    
    if (res == -1) {
        cout &amp;lt;&amp;lt; &amp;quot;No Solution&amp;quot; &amp;lt;&amp;lt; endl;
    }else{
        cout &amp;lt;&amp;lt; &amp;quot;G&amp;quot; &amp;lt;&amp;lt; res - n &amp;lt;&amp;lt; endl;
        printf(&amp;quot;%.1f %.1f\n&amp;quot;, (double)min_dist, (double)sum_dist / n + 1e-8);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dfsbfs&#34;&gt;DFS/BFS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624&#34;&gt;团伙头目&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736&#34;&gt;微博转发&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;团伙头目&#34;&gt;团伙头目&lt;/h3&gt;
&lt;p&gt;警察找到团伙头目的一种方法是检查人们的通话。&lt;/p&gt;
&lt;p&gt;如果 A 和 B 之间有通话，我们就说 A 和 B 是相关的。并且关联具有传递性，即如果 A 与 B 关联，B 与 C 关联，那么 A 与 C 也是关联的。&lt;/p&gt;
&lt;p&gt;关联权重定义为两人之间所有通话的总时间长度。&lt;/p&gt;
&lt;p&gt;一个“帮派”是一个由&lt;strong&gt;至少3个&lt;/strong&gt;相互关联的人组成的群体，并且其总关联权重大于给定的阈值 K。&lt;/p&gt;
&lt;p&gt;在每个帮派中，总权重最大的就是头目，数据保证每个帮派中总权重最大的人是唯一的。&lt;/p&gt;
&lt;p&gt;你需要确定各个帮派以及帮派头目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 N 和 K，表示通话数量以及权重阈值。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行采用如下形式描述通话：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name1 Name2 Time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Name1&lt;/code&gt; 和 &lt;code&gt;Name2&lt;/code&gt; 是通话的两人的名字，&lt;code&gt;Time&lt;/code&gt; 是通话时间。&lt;/p&gt;
&lt;p&gt;名字的长度固定为 3，且只包含大写字母。&lt;/p&gt;
&lt;p&gt;时间是一个不超过 1000 的正整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输出帮派数量。&lt;/p&gt;
&lt;p&gt;接下来每行输出一个帮派的信息，包括帮派头目名字以及帮派人数。&lt;/p&gt;
&lt;p&gt;帮派信息按头目名字字典序输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N,K≤1000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 59
AAA BBB 10
BBB AAA 20
AAA CCC 40
DDD EEE 5
EEE DDD 70
FFF GGG 30
GGG HHH 20
HHH FFF 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2
AAA 3
GGG 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 70
AAA BBB 10
BBB AAA 20
AAA CCC 40
DDD EEE 5
EEE DDD 70
FFF GGG 30
GGG HHH 20
HHH FFF 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;unordered_map&amp;gt;

using namespace std;

int n, k;
// 使用哈希表来存储图
unordered_map&amp;lt;string, vector&amp;lt;pair&amp;lt;string, int&amp;gt; &amp;gt; &amp;gt; g;
// 记录每个节点的总通话时间
unordered_map&amp;lt;string, int&amp;gt; total;
unordered_map&amp;lt;string, bool&amp;gt; st;

int dfs (string ver, vector&amp;lt;string&amp;gt;&amp;amp; nodes) {
    st[ver] = true;
    nodes.push_back(ver);
    int sum = 0;
    for (auto edge : g[ver]) {
        sum += edge.second;
        string cur = edge.first;
        if (!st[cur])
            sum += dfs(cur, nodes);
    }
    return sum;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    while (n--) {
        string a, b;
        int c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        g[a].push_back({b, c});
        g[b].push_back({a, c});
        total[a] += c;
        total[b] += c;
    }
    // 存储结果
    vector&amp;lt;pair&amp;lt;string, int&amp;gt; &amp;gt; res;
    // 遍历
    for (auto item : total) {
        string ver = item.first;
        vector&amp;lt;string&amp;gt; nodes;
        // 无向图我们使用的是两条有向边来存
        // dfs遍历出来的权重我们需要 / 2
        int sum = dfs(ver, nodes) / 2;
        // 满足是团伙的要求
        if (nodes.size() &amp;gt; 2 &amp;amp;&amp;amp; sum &amp;gt; k) {
            // 找出团队头目
            string boss = nodes[0];
            for (string node : nodes) {
                if (total[node] &amp;gt; total[boss]) 
                    boss = node;
            }
            res.push_back({boss, nodes.size()});
        }
    }
    // 按字典序排序
    sort(res.begin(), res.end());
    
    cout &amp;lt;&amp;lt; res.size() &amp;lt;&amp;lt; endl;
    for (int i = 0; i &amp;lt; res.size(); i++) {
        cout &amp;lt;&amp;lt; res[i].first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[i].second &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;微博转发&#34;&gt;微博转发&lt;/h3&gt;
&lt;p&gt;微博被称为中文版的 Twitter。&lt;/p&gt;
&lt;p&gt;微博上的用户既可能有很多关注者，也可能关注很多其他用户。&lt;/p&gt;
&lt;p&gt;因此，形成了一种基于这些关注关系的社交网络。&lt;/p&gt;
&lt;p&gt;当用户在微博上发布帖子时，他/她的所有关注者都可以查看并转发他/她的帖子，然后这些人的关注者可以对内容再次转发…&lt;/p&gt;
&lt;p&gt;现在给定一个社交网络，假设只考虑 L 层关注者，请你计算某些用户的帖子的最大可能转发量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 B 是 A 的关注者，C 是 B 的关注者，那么 A 的第一层关注者是 B，第二层关注者是 C。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数，N 表示用户数量，L 表示需要考虑的关注者的层数。&lt;/p&gt;
&lt;p&gt;假设，所有的用户的编号为 1∼N。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行包含一个用户的关注信息，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;M[i] user_list[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;M[i]&lt;/code&gt; 是第 i 名用户关注的总人数，&lt;code&gt;user_list[i]&lt;/code&gt; 是第 i 名用户关注的 &lt;code&gt;M[i]&lt;/code&gt; 个用户的编号列表。&lt;/p&gt;
&lt;p&gt;最后一行首先包含一个整数 K，表示询问次数，然后包含 K 个用户编号，表示询问这些人的帖子的最大可能转发量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按顺序，每行输出一个被询问人的帖子最大可能转发量。&lt;/p&gt;
&lt;p&gt;假设每名用户初次看到帖子时，都会转发帖子，只考虑 L 层关注者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤1000,&lt;br&gt;
1≤L≤6,&lt;br&gt;
1≤M[i]≤100,&lt;br&gt;
1≤K≤N&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

const int N = 1010;
vector&amp;lt;int&amp;gt; g[N];
int u[N];
int n, level;
bool st[N];

int bfs(int a) {
    queue&amp;lt;int&amp;gt; q;
    memset(st, 0, sizeof st);
    q.push(a);
    st[a] = true;
    int cnt = 0;
    int sum = 0;
    // 限定层次的bfs搜索，sum记录人数
    while(cnt &amp;lt; level) {
        int sz = q.size();
        sum += sz;
        for (int i = 0; i &amp;lt; sz; i++) {
            int t = q.front();
            q.pop();
            for (int j = 0; j &amp;lt; g[t].size(); j++) {
                if (!st[g[t][j]]) {
                    st[g[t][j]] = true;
                    q.push(g[t][j]);
                }
            }
        }
        cnt++;
    }
    return q.size() + sum - 1;
}


int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; level;
    for (int i = 1; i &amp;lt;= n; i++) {
        int k;
        cin &amp;gt;&amp;gt; k;
        while (k--) {
            int a;
            cin &amp;gt;&amp;gt; a;
            g[a].push_back(i);  
        }
    }
    
    int k;
    cin &amp;gt;&amp;gt; k;
    while (k--) {
        int query;
        cin &amp;gt;&amp;gt; query;
        cout &amp;lt;&amp;lt; bfs(query) &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;模拟&#34;&gt;模拟&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088&#34;&gt;顶点覆盖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552&#34;&gt;最大团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384&#34;&gt;旅行商问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552&#34;&gt;顶点着色&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;顶点覆盖&#34;&gt;顶点覆盖&lt;/h3&gt;
&lt;p&gt;如果图中的一个顶点集合能够满足图中的每一条边都至少有一个端点在该集合内，那么这个顶点集合就是图的顶点覆盖。&lt;/p&gt;
&lt;p&gt;现在给定一张图，以及若干个顶点集合，请你判断这些顶点集合是否是图的顶点覆盖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 N 和 M，表示图中点和边的数量。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含两个整数 a,b，表示点 a 和点 b 之间存在一条边。&lt;/p&gt;
&lt;p&gt;点编号 0∼N−1。&lt;/p&gt;
&lt;p&gt;然后包含一个整数 K，表示询问的顶点集合数量。&lt;/p&gt;
&lt;p&gt;接下来 K 行，每行描述一组询问顶点集合，格式如下：&lt;/p&gt;
&lt;p&gt;Nv V[1] V[2] … V[Nv]&lt;/p&gt;
&lt;p&gt;Nv 是集合中点的数量，V[i] 是点的编号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每组询问输出一行结果，如果是顶点覆盖则输出 &lt;code&gt;Yes&lt;/code&gt;，否则输出 &lt;code&gt;No&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N,M≤104,&lt;br&gt;
1≤K≤100,&lt;br&gt;
1≤Nv≤N&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 0
2 4
5
4 0 3 8 4
6 6 1 7 5 4 9
3 1 8 4
2 2 8
7 9 8 7 6 5 4 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;No
Yes
Yes
No
No
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 10010;
int n, m;
bool st[N];
// 不存在图的遍历，我们只需要用结构体存储边
struct Edge {
    int a, b;
}e[N];

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) 
        cin &amp;gt;&amp;gt; e[i].a &amp;gt;&amp;gt; e[i].b;
    int k;
    cin &amp;gt;&amp;gt; k;
    while (k--) {
        int cnt;
        cin &amp;gt;&amp;gt; cnt;
        memset(st, 0, sizeof st);
        while (cnt--) {
            int x;
            cin &amp;gt;&amp;gt; x;
            st[x] = true;
        }
        int index = 0;
        while (index &amp;lt; m) {
            if (!st[e[index].a] &amp;amp;&amp;amp; !st[e[index].b])
                break;
            index++;
        }
        if (index == m)
            cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else
            cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最大团&#34;&gt;最大团&lt;/h3&gt;
&lt;p&gt;在一个无向图中，如果一个顶点子集满足子集内的任意两个不同顶点之间都是相连的，那么这个顶点子集就被称为一个团。&lt;/p&gt;
&lt;p&gt;如果一个团不能通过加入某个新的顶点来扩展成一个更大的团，那么该团就被称为最大团。&lt;/p&gt;
&lt;p&gt;现在，你需要判断给定顶点子集能否构成一个最大团。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 Nv 和 Ne，分别表示无向图中点和边的数量。&lt;/p&gt;
&lt;p&gt;接下来 Ne 行，每行包含两个整数 a,b，表示点 a 和点 b 之间存在一条边。&lt;/p&gt;
&lt;p&gt;所有点的编号从 1 到 Nv。&lt;/p&gt;
&lt;p&gt;再一行，包含整数 M，表示询问次数。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行描述一个询问顶点子集，首先包含一个整数 K，表示子集包含点的数量，然后包含 K 个整数，表示 K 个不同顶点的编号。&lt;/p&gt;
&lt;p&gt;一行中所有数字之间用一个空格隔开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每组询问在一行中输出一个结论。&lt;/p&gt;
&lt;p&gt;如果给定子集是最大团，则输出 &lt;code&gt;Yes&lt;/code&gt;，如果是一个团，但不是最大团，则输出 &lt;code&gt;Not Maximal&lt;/code&gt;，如果根本不是团，则输出 &lt;code&gt;Not a Clique&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤Nv≤200,&lt;br&gt;
1≤Ne≤Nv(Nv−1)2,&lt;br&gt;
1≤M≤100,&lt;br&gt;
1≤K≤Nv&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 10
5 6
7 8
6 4
3 6
4 5
2 3
8 2
2 7
5 3
3 4
6
4 5 4 3 6
3 2 8 7
2 2 3
1 1
3 4 3 6
3 3 2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yes
Yes
Yes
Yes
Not Maximal
Not a Clique
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 210;
bool g[N][N], st[N];
int n, m;
int nodes[N];

bool check_cli (int k) {
    // 注意这里枚举的方法
    for (int i = 0; i &amp;lt; k; i++) {
        for (int j = 0; j &amp;lt; i; j++)
            if (!g[nodes[i]][nodes[j]])
                return false;
    }
    return true;
}

bool check_max (int k) {
    memset(st, 0, sizeof st);
    for (int i = 0 ; i &amp;lt; k; i++) {
        st[nodes[i]] = true;
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i]) {
            bool success = true;
            // 检查团能不能被继续扩展，如果可以继续扩展就不是最大团
            for (int j = 0; j &amp;lt; k; j++) {
                if (!g[i][nodes[j]]) {
                    success = false;
                    break;
                }
            }
            if (success)
                return false;
        }
    }
    return true;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    memset(g, 0, sizeof g);
    while (m--) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        g[a][b] = g[b][a] = true;
    }
    
    int cnt;
    cin &amp;gt;&amp;gt; cnt;
    while (cnt--) {
        int k;
        cin &amp;gt;&amp;gt; k;
        for (int i = 0; i &amp;lt; k; i++) 
            cin &amp;gt;&amp;gt; nodes[i];
        if (check_cli(k)) {
            if (check_max(k))
                cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
            else
                cout &amp;lt;&amp;lt; &amp;quot;Not Maximal&amp;quot; &amp;lt;&amp;lt; endl;
        }else
            cout &amp;lt;&amp;lt; &amp;quot;Not a Clique&amp;quot; &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;旅行商问题&#34;&gt;旅行商问题&lt;/h3&gt;
&lt;p&gt;“旅行商问题”是这样一个问题：“给出一个城市列表以及每对城市之间的距离，访问每个城市并返回原城市的最短路线是什么？”&lt;/p&gt;
&lt;p&gt;这是组合优化中的一个 NP 难题，在运筹学和理论计算机科学中十分重要。&lt;/p&gt;
&lt;p&gt;在此问题中，请你从给定的路径列表中找到最接近旅行商问题的解的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 N 和 M，分别表示城市数量以及 &lt;strong&gt;无向图&lt;/strong&gt; 中边的数量。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行以 &lt;code&gt;City1 City2 Dist&lt;/code&gt; 格式描述一条边，其中城市编号从 1 到 N，&lt;code&gt;Dist&lt;/code&gt; 为正且不超过 100。&lt;/p&gt;
&lt;p&gt;再一行包含一个整数 K，表示给定路径的数量。&lt;/p&gt;
&lt;p&gt;接下来 K 行描述路径，格式为：&lt;/p&gt;
&lt;p&gt;n C1 C2 … Cn&lt;/p&gt;
&lt;p&gt;n 表示给定路径经过的城市的数目，Ci 是路径中经过的城市的编号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每个路径，在一行中输出 &lt;code&gt;Path X: TotalDist (Description)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;X&lt;/code&gt; 是路径编号（从 1 开始），&lt;code&gt;TotalDist&lt;/code&gt; 表示路径总距离（如果距离不存在，则输出 &lt;code&gt;NA&lt;/code&gt;），&lt;code&gt;Description&lt;/code&gt; 是下列中的一项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TS simple cycle&lt;/code&gt;，如果这是一个访问每个城市的简单回路。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TS cycle&lt;/code&gt;，如果这是一个访问每个城市的回路，但不是简单回路。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Not a TS cycle&lt;/code&gt;，如果这不是一个访问了每个城市的回路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一行，输出 &lt;code&gt;Shortest Dist(X) = TotalDist&lt;/code&gt;，&lt;code&gt;X&lt;/code&gt; 是最接近旅行商问题解决方案的回路编号，&lt;code&gt;TotalDist&lt;/code&gt; 是其总距离。&lt;/p&gt;
&lt;p&gt;保证有唯一解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2&amp;lt;N≤200,&lt;br&gt;
N−1≤M≤N(N−1)2，&lt;br&gt;
1≤K≤1000,&lt;br&gt;
1≤n≤300&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 10
6 2 1
3 4 1
1 5 1
2 5 1
3 1 8
4 1 6
1 6 1
6 3 1
1 2 1
4 5 1
7
7 5 1 4 3 6 2 5
7 6 1 3 4 5 2 6
6 5 1 4 3 6 2
9 6 2 1 6 3 4 5 2 6
4 1 2 5 1
7 6 1 2 5 4 3 1
7 6 3 2 5 4 1 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Path 1: 11 (TS simple cycle)
Path 2: 13 (TS simple cycle)
Path 3: 10 (Not a TS cycle)
Path 4: 8 (TS cycle)
Path 5: 3 (Not a TS cycle)
Path 6: 13 (Not a TS cycle)
Path 7: NA (Not a TS cycle)
Shortest Dist(4) = 8
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 210;
const int INF = 0x3f3f3f3f;
int g[N][N];
bool st[N];
int vers[310];
int n, m;

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    memset(g, 0x3f3f3f3f, sizeof g);
    while (m--) {
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    
    int k;
    cin &amp;gt;&amp;gt; k;
    
    int min_dist = INF;
    int min_id;
    for (int m = 1; m &amp;lt;= k; m++) {
        int cnt;
        cin &amp;gt;&amp;gt; cnt;
        for (int i = 1; i &amp;lt;= cnt; i++)
            cin &amp;gt;&amp;gt; vers[i];
        
        int sum = 0;
        bool success = true;
        memset(st, 0, sizeof st);
        
        // 判断距离是否存在，不存在就是fasle，总距离距离表示为-1
        for (int i = 1; i + 1 &amp;lt;= cnt; i++) {
            int a = vers[i], b = vers[i + 1];
            if (g[a][b] == INF) {
                sum = -1;
                success = false;
                break;
            }else
                sum += g[a][b];
            st[a] = true;
        }
        
        // 判断每个点是否都能到
        for (int i = 1; i &amp;lt;= n; i++) {
            if (!st[i]) {
                success = false;
                break;
            }
        }
        
        // 判断是否是回路
        if (vers[1] != vers[cnt])
            success = false;
        
        if (sum == -1)
            cout &amp;lt;&amp;lt; &amp;quot;Path &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; &amp;quot; NA (Not a TS cycle)&amp;quot; &amp;lt;&amp;lt; endl;
        else {
            if (!success)
                cout &amp;lt;&amp;lt; &amp;quot;Path &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; &amp;quot; (Not a TS cycle)&amp;quot; &amp;lt;&amp;lt; endl;
            else {
                if (cnt == n + 1)
                    cout &amp;lt;&amp;lt; &amp;quot;Path &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; &amp;quot; (TS simple cycle)&amp;quot; &amp;lt;&amp;lt; endl;
                else
                    cout &amp;lt;&amp;lt; &amp;quot;Path &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; &amp;quot; (TS cycle)&amp;quot; &amp;lt;&amp;lt; endl;
                
                if (min_dist &amp;gt; sum) {
                    min_dist = sum;
                    min_id = m;
                }
            }
                
        }
    }
    cout &amp;lt;&amp;lt; &amp;quot;Shortest Dist&amp;quot; &amp;lt;&amp;lt; &#39;(&#39; &amp;lt;&amp;lt; min_id &amp;lt;&amp;lt; &amp;quot;) = &amp;quot; &amp;lt;&amp;lt; min_dist &amp;lt;&amp;lt; endl;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;顶点着色&#34;&gt;顶点着色&lt;/h3&gt;
&lt;p&gt;一个合适的顶点着色是指用各种颜色标记图中各个顶点，使得每条边的两个端点的颜色都不相同。&lt;/p&gt;
&lt;p&gt;如果一种合适的顶点着色方案使用了一共 k 种不同的颜色，则称其为合适的 k 着色（&lt;code&gt;k-coloring&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;现在，你需要判断给定的着色方案是否是合适的 k 着色方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 N 和 M，分别表示点和边的数量。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含两个整数 a,b，表示点 a 和点 b 之间存在一条边。&lt;/p&gt;
&lt;p&gt;所有点的编号从 0 到 N−1。&lt;/p&gt;
&lt;p&gt;再一行包含一个整数 K，表示你需要判断的着色方案。&lt;/p&gt;
&lt;p&gt;接下来 K 行，每行包含 N 个颜色，其中第 i 个颜色表示第 i 个点的颜色。&lt;/p&gt;
&lt;p&gt;颜色用非负整数表示，不超过 &lt;strong&gt;int&lt;/strong&gt; 范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每种着色方案，如果是一种合适的 k 着色方案，则输出一行 &lt;code&gt;k-coloring&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不是合适的着色方案，则输出一行 &lt;code&gt;No&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N,M≤104,&lt;br&gt;
1≤K≤100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 0
2 4
4
0 1 0 1 4 1 0 1 3 0
0 1 0 1 4 1 0 1 0 0
8 1 0 1 4 1 0 5 3 0
1 2 3 4 5 6 7 8 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4-coloring
No
6-coloring
No
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;unordered_set&amp;gt;

using namespace std;

const int M = 10010;
int n, m;
struct Edge {
    int a;
    int b;
}e[M];
int vers[M];

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 1; i &amp;lt;= m; i++) {
        cin &amp;gt;&amp;gt; e[i].a &amp;gt;&amp;gt; e[i].b;
    }
    
    int k;
    cin &amp;gt;&amp;gt; k;
    while (k--) {
        for (int i = 0; i &amp;lt; n; i++) {
            cin &amp;gt;&amp;gt; vers[i];
        }
        bool success = true;
        // 枚举每一条边
        for (int i = 1; i &amp;lt;= m; i++) {
            // 边的两个端点颜色相同就不是合适的着色方案
            if (vers[e[i].a] == vers[e[i].b]) {
                success = false;
                break;
            }
        }
        
        if (success) {
            unordered_set&amp;lt;int&amp;gt; ss;
            for (int i = 0; i &amp;lt; n; i++) 
                ss.insert(vers[i]);
            cout &amp;lt;&amp;lt; ss.size() &amp;lt;&amp;lt; &amp;quot;-coloring&amp;quot; &amp;lt;&amp;lt; endl;
        }else
            cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">图论(实战篇)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/tu-lun-ji-chu-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇内容属于图论基础篇内容，省去了最基础的概念，对于一些容易遗忘的概念和重要的基础算法做了梳理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;图相关概念&#34;&gt;图相关概念&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;连通图和连通分量&#34;&gt;连通图和连通分量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连通图：若图中&lt;strong&gt;任意两个顶点&lt;/strong&gt;都连通，则称为&lt;strong&gt;连通图&lt;/strong&gt;， 否则称为非连通图&lt;/li&gt;
&lt;li&gt;无向图G中的极大连通子图称为G的连通分量。任何连通图的连通分量只有一个，非连通图有多个连通分量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvg081p4j30sb0a1td3.jpg&#34; alt=&#34;image-20200607100850914&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/br&gt;
&lt;h3 id=&#34;强连通图和强连通分量&#34;&gt;强连通图和强连通分量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有向图：若从定点i到顶点j有路径，则称从顶点i到j是连通的。若图G中任意两个顶点i和j都连通，即从顶点i到j和从顶点j到i都存在路径，则称图G是&lt;strong&gt;强连通图&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有向图G中的极大强连通子图称为G的强连通分量。非强连通图有多个强连通分量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvgah3s5j30l20bvn0d.jpg&#34; alt=&#34;image-20200607101417696&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/br&gt;
&lt;h2 id=&#34;图的存储&#34;&gt;图的存储&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;邻接矩阵存储&#34;&gt;邻接矩阵存储&lt;/h3&gt;
&lt;h4 id=&#34;定义&#34;&gt;定义&lt;/h4&gt;
&lt;p&gt;邻接矩阵时表示顶点之间相邻关系的矩阵。设&lt;code&gt;G=（V, E）&lt;/code&gt;是具有n(n &amp;gt; 0)个顶点的图，顶点的编号依次为&lt;code&gt;0 ~ n - 1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无向图中若&lt;code&gt;(i, j) &lt;/code&gt;连通：&lt;code&gt;A[i] [j] = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有向图中若i到j有边：&lt;code&gt;A[i] [j] = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带权无向图，A[i] [j] = w&lt;sub&gt;ij&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;带权有向图，A[i] [j] = w&lt;sub&gt;ij&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvgpzhovj30qi0hcjx5.jpg&#34; alt=&#34;image-20200607103340476&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;存储类型&#34;&gt;存储类型&lt;/h4&gt;
&lt;p&gt;使用二维数组来进行存储&lt;/p&gt;
&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵唯一&lt;/li&gt;
&lt;li&gt;适合稠密图的存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;邻接表存储&#34;&gt;邻接表存储&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;每个单链表上添加一个表头节点（表示顶点信息）。并将所有表头节点构成一个数组，下标为i的元素表示顶点i的表头节点
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvh0bxl8j30sn0d3437.jpg&#34; alt=&#34;image-20200607120257195&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;存储类型-2&#34;&gt;存储类型&lt;/h4&gt;
&lt;p&gt;使用vector边长数组来存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若只用存储重点编号，则可以直接定义为int类型	&lt;code&gt;vector &amp;lt;int&amp;gt; Adj[N]  &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; Adj[N];
// 添加一条从1号顶点到达3号顶点的有向边
Adj[1].push_back(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;若要存储重点编号和边权，那么可以使用结构体Node来存储&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Node {
    int v;	// 边的终点编号
    int w;	// 边权
    Node (int _v, int _w) : v(_v), w(_w) {}		// 构造函数
}

vector&amp;lt;Node&amp;gt; Adj[N];
// 添加一条从1号顶点到达3号顶点的有向边，边权为4
Adj[1].push_back(Node(3, 4));
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;图的遍历&#34;&gt;图的遍历&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;图的遍历这一部分一定要熟记DFS和BFS的算法模板，很多题目就是在这些模板上做一些处理就可以解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/br&gt;
&lt;h3 id=&#34;深度优先搜索-dfs&#34;&gt;深度优先搜索 DFS&lt;/h3&gt;
&lt;h4 id=&#34;邻接矩阵存储遍历&#34;&gt;邻接矩阵存储遍历&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int INF = 0x3f3f3f3f;
// 邻接矩阵存储图的信息g[i][j]表示顶点 i 到顶点 j 这条边的权值大小
int g[N][N];
bool st[N];
// 初始化
memset(g, 0x3f, sizeof g);

void dfs(int u) {
    // 先标记这个点已经被访问过
    st[u] = true;
    // 递归地去遍历和该点连通的点
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i] &amp;amp;&amp;amp; g[u][i] != INF)
            dfs(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;邻接表存储遍历&#34;&gt;邻接表存储遍历&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 使用邻接表来存储图
vector&amp;lt;int&amp;gt; g[N];
bool st[N];

void dfs(int u) {
    // st[u] 表示点u已经被遍历过
    st[u] = true;
	// 递归地去遍历和该点连通的点
    for (int i = 0; i &amp;lt; g[u].size(); i++) {
        if (!st[g[u][i]]) 
            dfs(g[u][i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;广度优先搜索-bfs&#34;&gt;广度优先搜索 BFS&lt;/h3&gt;
&lt;h4 id=&#34;邻接矩阵存储遍历-2&#34;&gt;邻接矩阵存储遍历&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;节点编号为 1 ~ n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int INF = 0x3f3f3f3f;
// 邻接矩阵存储图的信息g[i][j]表示顶点 i 到顶点 j 这条边的权值大小
int g[N][N];
bool st[N];
// 初始化
memset(g, 0x3f, sizeof g);

queue&amp;lt;int&amp;gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);
while (!q.empty()) {
    int t = q.front();
    q.pop();
    
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i] &amp;amp;&amp;amp; g[t][i] != INF) {
            st[i] = true; // 表示点i已经被遍历过
            q.push(i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;最短路径&#34;&gt;最短路径&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvhdi5erj310n0dkmyz.jpg&#34; alt=&#34;image-20200708231809330&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/br&gt;
&lt;h3 id=&#34;dijkstra算法&#34;&gt;Dijkstra算法&lt;/h3&gt;
&lt;p&gt;Dijkstra算法用来解决&lt;strong&gt;单源最短路问题，不存在负边权&lt;/strong&gt;，给定图G和起点s，通过算法得到S到其他任何顶点的最短距离&lt;/p&gt;
&lt;h4 id=&#34;朴素dijkstra&#34;&gt;朴素Dijkstra&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;dist[1] = 0, dist[i] = MAX;
集合S：当前已确定最短距离的点
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;for i : 1 ~ n
	不在集合S中，距离最近的点  --&amp;gt; t;
	t  --&amp;gt; 集合S
	用t更新其他点的距离 (当dist[x] &amp;gt; dist[t] + w 就更新dist[x])
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvhqylkxj3090066jrd.jpg&#34; alt=&#34;image-20200607161658126&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;代码模板&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file Dijkstra.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-06-07 18:10:32
 * @brief Dijkstra算法
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */

#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

const int N = 510;

int n, m;
// 使用邻接矩阵来存储
int g[N][N];
// 保存最短距离
int dist[N];
// 用来判断是否有加入到集合中
bool st[N];

int dijkstra() {
    // 先初始化为正无穷
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i &amp;lt; n; i++) {
        int t = -1;
        // 找到不在集合S中距离最近的点
        for (int j = 1; j &amp;lt;= n; j++) {
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        }
        // 将t加入到集合
        st[t] = true;
        // 用t来更新其他点距离
        for (int j = 1; j &amp;lt;= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;堆优化版dijkstra&#34;&gt;堆优化版Dijkstra&lt;/h4&gt;
&lt;p&gt;核心思想：集合中找最近的点的操作可以&lt;strong&gt;使用堆来实现&lt;/strong&gt;，C++中可以使用优先队列&lt;code&gt;priority_queue&lt;/code&gt;来实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
const int N = 1000010;
// 第一个存放边权，第二个存放节点编号(方便heap按边权排序)
typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m;
// 使用邻接表来存储
vector&amp;lt;PII&amp;gt; g[N];

// 保存最短距离
int dist[N];
// 用来判断是否有加入到集合中
bool st[N];

int dijkstra() {
    // 先置为正无穷
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    // 使用小根堆
    priority_queue&amp;lt;PII, vector&amp;lt;PII&amp;gt;, greater&amp;lt;PII&amp;gt; &amp;gt; heap;
    // pair排序时是先根据first，再根据second，这里显然要根据距离排序
    heap.push({0, 1});
    while (!heap.empty()) {
        auto t = heap.top();
        heap.pop();
        int ver = t.second;
        if (st[ver])
            continue;
        st[ver] = true;
        
        // 更新节点
        for (int i = 0; i &amp;lt; g[ver].size(); i++) {
            int j = g[ver][i].second;
            if (dist[j] &amp;gt; dist[ver] + g[ver][i].first) {
                dist[j] = dist[ver] + g[ver][i].first;
                heap.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n]; 
}

int main() {
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    while (m--) {
        int a, b, c;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        // a到b之间有一条边权为c的边
        g[a].push_back({c, b});
    }
    
    int t = dijkstra();
    printf(&amp;quot;%d\n&amp;quot;, t);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;bellman-ford算法&#34;&gt;Bellman-Ford算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适合存在负边权的最短路，而且最短路不一定存在（例如存在负权回路）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;for 1 ~ n
	for 所有边 a, b, w
		dist[b] = min(dist[b], dist[a] + w);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;求有边数限制的最短路&#34;&gt;求有边数限制的最短路&lt;/h4&gt;
&lt;p&gt;给定一个n个点m条边的有向图，图中可能存在重边和自环， &lt;strong&gt;边权可能为负数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。&lt;/p&gt;
&lt;p&gt;注意：图中可能 &lt;strong&gt;存在负权回路&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个整数n，m，k。&lt;/p&gt;
&lt;p&gt;接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。&lt;/p&gt;
&lt;p&gt;如果不存在满足条件的路径，则输出“impossible”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤n,k≤500,&lt;br&gt;
1≤m≤10000,&lt;br&gt;
任意边长的绝对值不超过10000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 3 1
1 2 1
2 3 1
1 3 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file Bellman-Ford.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-07-08 21:30:56
 * @brief Bellman-Ford算法求有边数限制的最短路
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 510, M = 10010;

int n, m, k;
int dist[N], backup[N];

struct Edge {
    int a;
    int b;
    int w;
} edge[M];

int bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &amp;lt; k; i++) {
        // 做数组拷贝，防止在下面的更新操作中被串联更新
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j &amp;lt; m; j++) {
            auto e = edge[j];
            dist[e.b] = min(dist[e.b], backup[e.a] + e.w);
        }
    }
    // 这里不直接写等于无穷：是因为有可能距离无穷的那个节点在里层的for循环会更新下一个无穷的节点
    if (dist[n] &amp;gt; 0x3f3f3f3f / 2)
        return -1;
    else
        return dist[n];
}

int main() {

    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
    // 读入m条边
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b, w;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; w;
        edge[i] = {a, b, w};
    }

    int t = bellman_ford();
    if (t == -1)
        cout &amp;lt;&amp;lt; &amp;quot;impossible&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;spfa算法&#34;&gt;SPFA算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;spfa求最短路算法其实是对Bellman-Ford算法改进，在Bellman-Ford算法中&lt;code&gt;dist[b] = min(dist[b], dist[a] + w);&lt;/code&gt;，如果dist[a]没有变小，那么这个操作一定会是无效的操作，spfa算法就是在这里利用BFS进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;queue &amp;lt;-- 1;
while queue 不空
	t = q.front();
	q.pop();
	更新t的所有出边(如果被更新，就再加到队列去更新别人)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;spfa求最短路&#34;&gt;SPFA求最短路&lt;/h4&gt;
&lt;p&gt;给定一个n个点m条边的有向图，图中可能存在重边和自环， &lt;strong&gt;边权可能为负数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出impossible。&lt;/p&gt;
&lt;p&gt;数据保证不存在负权回路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n和m。&lt;/p&gt;
&lt;p&gt;接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数，表示1号点到n号点的最短距离。&lt;/p&gt;
&lt;p&gt;如果路径不存在，则输出”impossible”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤n,m≤105,&lt;br&gt;
图中涉及边长绝对值均不超过10000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 3
1 2 5
2 3 -3
1 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file SPFA.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-07-08 21:07:47
 * @brief SPFA算法求最短路
 *          在Bellman-Ford算法中dist[b] = min(dist[b], dist[a] + w);
 *          如果dist[a]没有变小，那么这个操作一定会是无效的操作
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 100010;
// 第一个位置存储编号，第二个位置存储边权
typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m;
vector&amp;lt;PII&amp;gt; g[N];
int dist[N];
bool st[N];

int spfa() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue&amp;lt;int&amp;gt; q;
    q.push(1);
    st[1] = true;
    // 利用BFS的思想优化Bellman-Ford算法就是SPFA
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        st[t] = false;

        for (int i = 0; i &amp;lt; g[t].size(); i++) {
            int j = g[t][i].first;
            int w = g[t][i].second;
            // 队列中存的就是那些变小的节点：更新过谁，我再拿谁更新别人
            if (dist[j] &amp;gt; dist[t] + w) {
                dist[j] = dist[t] + w;
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        // 加一条从a到b的边，边权为c
        g[a].push_back({b, c});
    }

    int t = spfa();

    if (t == 0x3f3f3f3f)
        cout &amp;lt;&amp;lt; &amp;quot;impossible&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;spfa判断负环&#34;&gt;SPFA判断负环&lt;/h4&gt;
&lt;p&gt;给定一个n个点m条边的有向图，图中可能存在重边和自环， &lt;strong&gt;边权可能为负数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请你判断图中是否存在负权回路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数n和m。&lt;/p&gt;
&lt;p&gt;接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果图中&lt;strong&gt;存在&lt;/strong&gt;负权回路，则输出“Yes”，否则输出“No”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤n≤2000,&lt;br&gt;
1≤m≤10000,&lt;br&gt;
图中涉及边长绝对值均不超过10000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 3
1 2 -1
2 3 4
3 1 -4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yes
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;更新dist[x]时候，同时记录cnt[x]，记录每个节点最短路的边数 cnt[x] &amp;gt;= n 表示经过了n + 1个点，说明有环的存在&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file SPFA-hasCircle.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-07-08 22:28:12
 * @brief SPFA判断回路里面是否有负环
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

const int N = 2010, M = 10010;
typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m;
vector&amp;lt;PII&amp;gt; g[N];
int dist[N];
// 记录最短路的边数，cnt[x] &amp;gt;= n 表示有环
int cnt[N];
bool st[N];

bool spfa() {
    queue&amp;lt;int&amp;gt; q;
    // 将所有点都入队：因为以前只是求固定一个点
    // 但存在负权回路的时候，不一定所有点都能经过负权回路
    for (int i = 1; i &amp;lt;= n; i++) {
        st[i] = true;
        q.push(i);
    }
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        // 出队了进行标记，没有在队列里面
        st[t] = false;

        for (int i = 0; i &amp;lt; g[t].size(); i++) {
            int j = g[t][i].first;
            int w = g[t][i].second;
            // 当前需要更新
            if (dist[j] &amp;gt; dist[t] + w) {
                dist[j] = dist[t] + w;
                cnt[j] = cnt[t] + 1;
                // 最短路的边数 &amp;gt;= n 表示存在环
                if (cnt[j] &amp;gt;= n)
                    return true;
                if (!st[j]) {
                    st[j] = true;
                    q.push(j);
                }
            }
        }
    }

    return false;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        g[a].push_back({b, c});
    }

    if (spfa())
        cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;floyd算法&#34;&gt;Floyd算法&lt;/h3&gt;
&lt;p&gt;对于一个各边权值均大于零的有向图，对于每一个顶点 i ≠ j，求出顶点i与顶点j之间最短路径和最短路径长度&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvia5i8cj30lj0boq6i.jpg&#34; alt=&#34;image-20200708230636736&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file Floyd.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-06-30 00:42:40
 * @brief Floyd算法：多源最短路算法：动态规划思想
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 210;

int n, m;
// d[i][j] 存储所有边，执行完floyd算法存的就是i到j的最短距离
int d[N][N];

// 求多源汇最短路floyd算法
void floyd() {
    for (int k = 1; k &amp;lt;= n; k++) {
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 1; j &amp;lt;= n; j++)
                // 上一层：从i出发只经过i ~ k - 1 到j的距离
                // d[i][k] + d[k][j] 经过k的距离
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对于带权连通图G（每条边上的权值为大于零的实数），可能有多颗不同的生成树&lt;/p&gt;
&lt;p&gt;每棵生成树的所有边的权值之和可能不同&lt;/p&gt;
&lt;p&gt;其中权值之和最小的生成树称为图的最小生成树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;prim算法适合稠密图&#34;&gt;Prim算法(适合稠密图)&lt;/h3&gt;
&lt;p&gt;给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。&lt;/p&gt;
&lt;p&gt;求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。&lt;/p&gt;
&lt;p&gt;给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。&lt;/p&gt;
&lt;p&gt;由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。&lt;/p&gt;
&lt;p&gt;接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤n≤500,&lt;br&gt;
1≤m≤10^5,&lt;br&gt;
图中涉及边的边权的绝对值均不超过10000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvimiw0oj30oi0j0wnt.jpg&#34; alt=&#34;image-20200709150633120&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：让一棵小树长大&lt;/li&gt;
&lt;li&gt;从顶点开始，找距离树最近的边的点加进来（贪心思想）&lt;/li&gt;
&lt;li&gt;从未加到树中的顶点选一个距离树最小距离的点加进来，直到所有点都加进来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度O(n^2)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;S：当前连通块的点集
dist[i]:表示点i到最集合的距离

dist初始化为正无穷
for 1 ~ n
	t = 集合外距离最近的点
	用 t 来更新其他点到集合的距离
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file Prim.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-06-29 22:02:16
 * @brief Prim算法
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;

const int N = 510;
const int M = 100010;
const int INF = 0x3f3f3f3f;

int n, m;
int dist[N];
bool st[N];
int g[N][N];

int prim() {
    // prim算法中dist[j]表示当前点到集合的距离
    memset(dist, 0x3f, sizeof dist);
    int res = 0;
    for (int i = 0; i &amp;lt; n; i++) {
        // 找到距离集合最近的点
        int t = -1;
        for (int j = 1; j &amp;lt;= n; j++) {
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        }
        st[t] = true;
        // 不是第一个点且dist[t]为正无穷的情况,说明没有找到
        if (i != 0 &amp;amp;&amp;amp; dist[t] == INF)
            return INF;
        // 放在前面，防止有环的出现
        if (i != 0)
            res += dist[t];
        // 用t更新其他点到集合的距离
        for (int j = 1; j &amp;lt;= n; j++) {
            // Dijkstra算法找的是距起点的距离
            // Prim算法找的是距离集合的距离
            dist[j] = min(dist[j], g[t][j]);
        }
    }
    return res;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    memset(g, 0x3f, sizeof g);

    while (m--) {
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    int t = prim();
    if (t == INF)
        cout &amp;lt;&amp;lt; &amp;quot;impossible&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;kruskal算法适合边稀疏图&#34;&gt;Kruskal算法(适合边稀疏图)&lt;/h3&gt;
&lt;p&gt;给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。&lt;/p&gt;
&lt;p&gt;求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。&lt;/p&gt;
&lt;p&gt;给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。&lt;/p&gt;
&lt;p&gt;由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m。&lt;/p&gt;
&lt;p&gt;接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤n≤10^5,&lt;br&gt;
1≤m≤2∗10^5,&lt;br&gt;
图中涉及边的边权的绝对值均不超过1000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvizuablj30nd08a425.jpg&#34; alt=&#34;image-20200709150942941&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：将森林合并成树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将所有边从小到大排序（最慢的一步O(mlog m)）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;枚举每一条边，a -&amp;gt; b，权重c，a和b不连通，将这条边加到集合当中(并查集)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 200010;

int n ,m;
int p[N];

struct Edge {
    int a, b, w;
    // 重载小于号，方便排序
    bool operator&amp;lt; (const Edge&amp;amp; e) const {
        return w &amp;lt; e.w;
    }
}edges[N];

// 并查集找祖宗节点
int find(int x) {
    if (p[x] != x) 
        p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        edges[i] = {a, b, c};
    }
    // 对边按权值大小排序
    sort(edges, edges + m);
    
    // 初始化并查集
    for (int i = 1; i &amp;lt;= n; i++) 
        p[i] = i;
    
    int res = 0, cnt = 0;
    // 枚举每一条边
    for (int i = 0; i &amp;lt; m; i++) {
        int a = edges[i].a;
        int b = edges[i].b;
        int w = edges[i].w;
        
        // 找是否在一个集合中
        a = find(a);
        b = find(b);
        
        // 没有在一个集合当中，要再a和b之间加一条边, 边权已经排序，直接加入权值
        if (a != b) {
            p[a] = b;
            res += w;
            cnt++;
        }
    }
    
    if (cnt &amp;lt; n - 1)
        cout &amp;lt;&amp;lt; &amp;quot;impossible&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;拓扑排序&#34;&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760&#34;&gt;拓扑排序&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对一个&lt;strong&gt;有向无环图G&lt;/strong&gt;进行拓扑排序，&lt;strong&gt;是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&amp;lt;u,v&amp;gt;∈E(G)，则u在线性序列中出现在v之前&lt;/strong&gt;。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 NN 和 MM，分别表示有向图的点和边的数量。&lt;/p&gt;
&lt;p&gt;接下来 MM 行，每行给出一条边的起点和终点。&lt;/p&gt;
&lt;p&gt;点的编号从 11 到 NN。&lt;/p&gt;
&lt;p&gt;再一行包含一个整数 KK，表示询问次数。&lt;/p&gt;
&lt;p&gt;接下来 KK 行，每行包含一个所有点的排列。&lt;/p&gt;
&lt;p&gt;一行中的数字用空格隔开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一行中输出所有不是拓扑序列的询问序列的编号。&lt;/p&gt;
&lt;p&gt;询问序列编号从 00 开始。&lt;/p&gt;
&lt;p&gt;行首和行尾不得有多余空格，保证存在至少一个解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤1000,&lt;br&gt;
1≤M≤10000,&lt;br&gt;
1≤K≤100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 8
1 2
1 3
5 2
5 4
2 3
2 6
3 4
6 4
5
1 5 2 3 6 4
5 1 2 6 3 4
5 1 2 3 6 4
5 2 1 6 3 4
1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file Test.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-06-14 21:11:37
 * @brief 判断拓扑排序
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 1010, M = 10010;
struct Edge {
    int a;
    int b;
} e[M];
int n, m;
// 记录路径中的下标
int pos[N];

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        e[i].a = a;
        e[i].b = b;
    }

    int k;
    cin &amp;gt;&amp;gt; k;
    vector&amp;lt;int&amp;gt; res;
    for (int i = 0; i &amp;lt; k; i++) {
        for (int j = 1; j &amp;lt;= n; j++) {
            int x;
            cin &amp;gt;&amp;gt; x;
            pos[x] = j;
        }

        bool success = true;
        for (int j = 0; j &amp;lt; m; j++) {
            if (pos[e[j].b] &amp;lt; pos[e[j].a]) {
                success = false;
                break;
            }
        }
        if (!success)
            res.push_back(i);
    }
    if (res.size() &amp;gt; 0) {
        cout &amp;lt;&amp;lt; res[0];
        for (int i = 1; i &amp;lt; res.size(); i++)
            cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[i];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;特殊图&#34;&gt;特殊图&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二分图&#34;&gt;二分图&lt;/h3&gt;
&lt;p&gt;二分图，是图论中的一种特殊模型。设&lt;code&gt;G=(V,E)&lt;/code&gt;是一个&lt;strong&gt;无向图&lt;/strong&gt;，如果顶点V可分割为两个互不相交的子集&lt;code&gt;(A,B)&lt;/code&gt;，并且图中的每条边&lt;code&gt;（i，j）&lt;/code&gt;所关联的两个顶点i和j分别属于这两个不同的顶点集&lt;code&gt;(i in A,j in B)&lt;/code&gt;，则称图G为一个二分图。简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说**：把一个图的顶点划分为两个不相交子集 ，使得每一条边都分别连接两个集合中的顶点。如果存在这样的划分，则此图为一个二分图**&lt;/p&gt;
&lt;h4 id=&#34;染色法判定二分图&#34;&gt;染色法判定二分图&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;充要条件：&lt;strong&gt;一个图是二分图当且仅当图中不含奇数环&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;判定是否是一个二分图：染色法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvjioqcxj30pt09fwf9.jpg&#34; alt=&#34;image-20200709153406616&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 100010;

int n, m;
vector&amp;lt;int&amp;gt; g[N];
int color[N];

bool dfs(int u, int c) {
    color[u] = c;
    // 遍历所有的点
    for (int i = 0; i &amp;lt; g[u].size(); i++) {
        int j = g[u][i];
        // 没有染色就去dfs染色
        if (!color[j]) {
            // 递归调用：1变2, 2变1的过程
            if (!dfs(j, 3 - c))
                return false;
        }
        // 染色且颜色相同，就表示不是二分图
        else if (color[j] == c)
            return false;
    }
    
    return true;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    
    while (m--) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        // 无向图：两条边都要加
        g[a].push_back(b);
        g[b].push_back(a);
    }
    
    bool flag = true;
    for(int i = 1; i &amp;lt;= n; i++) {
        // 该点没有染色，就开始dfs开始染色
        if (!color[i]) {
            if (!dfs(i, 1)) {
                flag = false;
                break;
            }
        }
    }
    
    if (flag) 
        cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;匈牙利算法求二分图最大匹配&#34;&gt;匈牙利算法求二分图最大匹配&lt;/h4&gt;
&lt;p&gt;给定一个二分图，其中左半部包含n1个点（编号1&lt;sub&gt;n1），右半部包含n2n2个点（编号1&lt;/sub&gt;n2），二分图共包含m条边。&lt;/p&gt;
&lt;p&gt;数据保证任意一条边的两个端点都不可能在同一部分中。&lt;/p&gt;
&lt;p&gt;请你求出二分图的最大匹配数。&lt;/p&gt;
&lt;p&gt;二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。&lt;/p&gt;
&lt;p&gt;二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个整数 n1、 n2和 m。&lt;/p&gt;
&lt;p&gt;接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数，表示二分图的最大匹配数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤n1,n2≤500,&lt;br&gt;
1≤u≤n1,&lt;br&gt;
1≤v≤n2,&lt;br&gt;
1≤m≤10^5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 2 4
1 1
1 2
2 1
2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/96229700&#34;&gt;如何理解匈牙利算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 510;

int n1, n2, m;
vector&amp;lt;int&amp;gt; g[N];
bool st[N];
// match[j]表示右边集合匹配左边集合点的编号
int match[N];

bool find(int x) {
    
    for(int i = 0; i &amp;lt; g[x].size(); i++) {
        int j = g[x][i];
        if (!st[j]) {
            st[j] = true;
            // 当没有任何匹配的时候或者匹配到左边集合的点可以匹配到别的节点
            if (match[j] == 0 || find(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    
    return false;
}

int main() {
    cin &amp;gt;&amp;gt; n1 &amp;gt;&amp;gt; n2 &amp;gt;&amp;gt; m;
    while (m--) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        // 只用存一条有向边
        g[a].push_back(b);
    }
    
    int res = 0;
    
    // 只用枚举左边的集合
    for (int i = 1; i &amp;lt;= n1; i++) {
        // 每次都要清空：目的是针对左边不同的节点我们需要尝试去匹配所有和他相连的节点，即使匹配的节点已经被匹配过
        memset(st, false, sizeof st);
        if (find(i))
            res++;
    }
    
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;欧拉图&#34;&gt;欧拉图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;欧拉路径是图中的一条路径，该&lt;strong&gt;路径满足恰好访问每个边一次&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;欧拉回路是&lt;strong&gt;一条在同一顶点处开始和结束的欧拉路径&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如果一个连通图的所有顶点的度数都为偶数，那么这个连通图具有欧拉回路，且这个图被称为欧拉图&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个连通图中有两个顶点的度数为奇数，其他顶点的度数为偶数，那么所有欧拉路径都从其中一个度数为奇数的顶点开始，并在另一个度数为奇数的顶点结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;具有欧拉路径但不具有欧拉回路的图被称为半欧拉图&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;欧拉路径&#34;&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805349851185152&#34;&gt;欧拉路径&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;br&gt;
第一行包含两个整数 N 和 M，表示无向图的点和边的数量。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含两个整数 a,b，表示点 a 和 b 之间存在一条边。&lt;/p&gt;
&lt;p&gt;所有点的编号从 1∼N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;br&gt;
首先，在第一行按顺序输出点 1∼N 中每个点的度数。&lt;/p&gt;
&lt;p&gt;第二行输出对该图的判断，Eulerian（欧拉图），Semi-Eulerian（半欧拉图），Non-Eulerian（非欧拉图）。&lt;/p&gt;
&lt;p&gt;行尾不得有多余空格。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvk15x08j30wr0bxdh6.jpg&#34; alt=&#34;image-20200709222355944&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;
const int N = 510;

int n, m;
//
bool g[N][N];
// 记录每个点的度数
int d[N];
bool st[N];

// dfs遍历所有点，返回点的个数
int dfs(int u) {
    st[u] = true;
    
    // 先将自己计算，所以置为1
    int res = 1;
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i] &amp;amp;&amp;amp; g[u][i])
            res += dfs(i);
    }
    
    return res;
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    
    for (int i = 0; i &amp;lt; m; i++) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        g[a][b] = g[b][a] = true;
        d[a]++;
        d[b]++;
    }
    
    int cnt = dfs(1);
    cout &amp;lt;&amp;lt; d[1];
    
    for (int i = 2; i &amp;lt;= n; i++)
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; d[i];
    cout &amp;lt;&amp;lt; endl;
    
    if (cnt == n) {
        int s = 0;
        for (int i = 1; i &amp;lt;= n; i++) 
            if (d[i] % 2)
                s++;
        if (s == 0)
            cout &amp;lt;&amp;lt; &amp;quot;Eulerian&amp;quot; &amp;lt;&amp;lt; endl;
        else if (s == 2)
            cout &amp;lt;&amp;lt; &amp;quot;Semi-Eulerian&amp;quot; &amp;lt;&amp;lt; endl;
        else
            cout &amp;lt;&amp;lt; &amp;quot;Non-Eulerian&amp;quot; &amp;lt;&amp;lt; endl;
        
    }else
        cout &amp;lt;&amp;lt; &amp;quot;Non-Eulerian&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;哈密顿图&#34;&gt;哈密顿图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈密顿回路问题是包含图中每个顶点的简单回路&lt;/li&gt;
&lt;li&gt;哈密顿图是一个无向图，由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。在图论中是指含有哈密顿回路的图，闭合的&lt;strong&gt;哈密顿路径称作哈密顿回路&lt;/strong&gt;（Hamiltonian cycle），&lt;strong&gt;含有图中所有顶点的路径称作哈密顿路径（Hamiltonian path）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;哈密顿回路&#34;&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805351814119424&#34;&gt;哈密顿回路&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;哈密顿回路问题是找到一个包含图中每个顶点的简单回路。&lt;/p&gt;
&lt;p&gt;这样的回路称为“哈密顿回路”。&lt;/p&gt;
&lt;p&gt;在本题中，你需要做的是判断给定路径是否为哈密顿回路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含一个整数 N 表示顶点数，一个整数 M 表示给定&lt;strong&gt;无向图&lt;/strong&gt;中的边数。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含两个整数 a,b，表示点 a和 b之间存在一条边。&lt;/p&gt;
&lt;p&gt;所有顶点编号从 1 到 N。&lt;/p&gt;
&lt;p&gt;再一行给出整数 KK，表示询问次数。&lt;/p&gt;
&lt;p&gt;接下来 KK 行，每行包含一个询问，格式如下：&lt;/p&gt;
&lt;p&gt;n V1 V2 … Vn&lt;/p&gt;
&lt;p&gt;n 表示给定路径经过的点的数目，Vi 是路径中经过的点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每个询问，如果是哈密顿回路则在一行输出 &lt;code&gt;YES&lt;/code&gt;，否则输出 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2&amp;lt;N≤200,&lt;br&gt;
N−1≤M≤N(N−1)/2,&lt;br&gt;
1≤K≤1000,&lt;br&gt;
1≤n≤410&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 10
6 2
3 4
1 5
2 5
3 1
4 1
1 6
6 3
1 2
4 5
6
7 5 1 4 3 6 2 5
6 5 1 4 3 6 2
9 6 2 1 6 3 4 5 2 6
4 1 2 5 1
7 6 1 3 4 5 2 6
7 6 1 2 5 4 3 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;YES
NO
NO
NO
YES
NO
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvkc20vmj30jz0didgh.jpg&#34; alt=&#34;image-20200709222610967&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;
const int N = 210;

bool g[N][N];
int n, m;
bool st[N];
int nodes[N * 2];

bool check(int cnt) {
    // 起点和终点不一样或者点数小于n + 1
    if (nodes[0] != nodes[cnt - 1] || cnt != n + 1)
        return false;
    memset(st, 0, sizeof st);
    for (int i = 0; i &amp;lt; cnt - 1; i++) {
        st[nodes[i]] = true;
        // 边不存在
        if (!g[nodes[i]][nodes[i + 1]])
            return false;
    }
    // 所有点都走到了
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!st[i])
            return false;
    }
    
    return true;
}


int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while (m--) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        g[a][b] = g[b][a] = true;
    }
    int k;
    cin &amp;gt;&amp;gt; k;
    while (k--) {
        int cnt;
        cin &amp;gt;&amp;gt; cnt;
        for (int i = 0; i &amp;lt; cnt; i++) {
            cin &amp;gt;&amp;gt; nodes[i];
        }
        
        if (check(cnt))
            cout &amp;lt;&amp;lt; &amp;quot;YES&amp;quot; &amp;lt;&amp;lt; endl;
        else
            cout &amp;lt;&amp;lt; &amp;quot;NO&amp;quot; &amp;lt;&amp;lt; endl;
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;补充&#34;&gt;补充&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;数组模拟链表&#34;&gt;数组模拟链表&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gglvkosggnj30ev06h0sw.jpg&#34; alt=&#34;image-20200607192609858&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e[N]&lt;/code&gt;：存储节点值value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ne[N]&lt;/code&gt;：存储某个节点的next指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt;表示头结点的下标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idx&lt;/code&gt;表示已经用到了哪个点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @file LinkList.cpp
 * @author Rick (Kay_Rick@outlook.com)
 * @version 1.0
 * @date 2020-06-07 19:36:30
 * @brief 数组模拟链表实现
 * 
 * @copyright Copyright (c) 2020 Rick, All Rights Reserved.
 * 
 */

#include &amp;lt;iostream&amp;gt;
using namespace std;

const int N = 100010;

// head表示头结点的下标
// e[i]表示节点i的值
// ne[i]表示节点i的next指针是多少
// idx表示已经用到了哪个点
int e[N], ne[N], idx, head;

void init () {
    head = -1;
    idx = 0;
}

/**
 * @brief 将x插到头结点
 * @param x 
 */
void add_to_head (int x) {
    e[idx] = x;
    ne[idx] = head;
    head = idx++;
}

/**
 * @brief 将节点 x 插入到下标为 k 的节点的后面
 * @param k 
 * @param x 
 */
void add (int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx++;
}

/**
 * @brief 将下标是k的点后面的点删除
 * @param k 
 */
void remove (int k) {
    ne[k] = ne[ne[k]];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;树与图的存储&#34;&gt;树与图的存储&lt;/h3&gt;
&lt;p&gt;树是一种特殊的图，与图的存储方式相同。&lt;br&gt;
对于无向图中的边ab，存储两条有向边a-&amp;gt;b, b-&amp;gt;a。&lt;br&gt;
因此我们可以只考虑有向图的存储。&lt;/p&gt;
&lt;p&gt;(1) 邻接矩阵：&lt;code&gt;g[a] [b]&lt;/code&gt; 存储边a-&amp;gt;b&lt;/p&gt;
&lt;p&gt;(2) 邻接表：可以使用vector来存储 &lt;code&gt;vector &amp;lt;int&amp;gt; g[N]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a-&amp;gt;b
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;并查集&#34;&gt;并查集&lt;/h3&gt;
&lt;h4 id=&#34;解决什么问题&#34;&gt;解决什么问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;将两个集合合并&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;询问两个元素是否在一个集合当中&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基本原理&#34;&gt;基本原理&lt;/h4&gt;
&lt;p&gt;每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何判断树根？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (p[x] == x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何求x的集合编号？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;while (p[x] != x)
    x = p[x];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优化：路径压缩，第一次求祖先节点的时候把所有遍历的点的父节点都设为祖先节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 返回x的祖宗节点 + 路径压缩
int find (int x) {
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何合并两个集合？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// p[x]是x的集合编号，p[y]是y的集合编号
p[x] = y;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">图论(基础篇)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/shu-shi-zhan-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;基础篇部分和进阶篇部分介绍了树相关章节的基础知识和基础算法，本篇就PAT上相关习题做一个总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;dfs遍历相关&#34;&gt;DFS遍历相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184&#34;&gt;树叶子结点&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805359372255232&#34;&gt;完全二叉树&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805424153280512&#34;&gt;等重路径&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805388447170560&#34;&gt;供应链总销售额&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805376476626944&#34;&gt;供应链最高价格&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805362341822464&#34;&gt;供应链最低价格&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552&#34;&gt;堆路径&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312&#34;&gt;中缀表达式&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;数叶子结点&#34;&gt;数叶子结点&lt;/h3&gt;
&lt;p&gt;家庭关系可以用家谱树来表示，给定一个家谱树，你的任务是找出其中没有孩子的成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含一个整数 N 表示树中结点总数以及一个整数 M 表示非叶子结点数。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行的格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ID K ID[1] ID[2] ... ID[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ID 是一个两位数字，表示一个非叶子结点编号，K 是一个整数，表示它的子结点数，接下来的 K 个 ID[i] 也是两位数字，表示一个子结点的编号。&lt;/p&gt;
&lt;p&gt;为了简单起见，我们将根结点固定设为 01。&lt;/p&gt;
&lt;p&gt;所有结点的编号即为 01,02,03,…,31,32,33,…,N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出从根结点开始，自上到下，树的&lt;strong&gt;每一层级&lt;/strong&gt;分别包含多少个叶子节点。&lt;/p&gt;
&lt;p&gt;输出占一行，整数之间用空格隔开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0&amp;lt;N&amp;lt;100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 1
01 1 02
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;样例解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该样例表示一棵只有 2 个结点的树，其中 01 结点是根，而 02 结点是其唯一的子节点。&lt;/p&gt;
&lt;p&gt;因此，在根这一层级上，存在 0 个叶结点；在下一个级别上，有 1 个叶结点。&lt;/p&gt;
&lt;p&gt;所以，我们应该在一行中输出0 1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

const int N = 110;
int n, m;
int cnt[N];
int max_depth;
vector&amp;lt;int&amp;gt; g[N];

/*
 * DFS搜索，加上depth参数为了记录每一层的叶子结点个数
 */
void dfs(int u, int depth) {
    // 说明u是叶子结点
    if (g[u].size() == 0) {
        cnt[depth]++;
        max_depth = max(max_depth, depth);
        return;
    }
    for (int i = 0; i &amp;lt; g[u].size(); i++) {
        dfs(g[u][i], depth + 1);
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    // 读入数据建树
    for (int i = 0; i &amp;lt; m; i++) {
        int id, k;
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; k;
        while(k--) {
            int son;
            cin &amp;gt;&amp;gt; son;
            g[id].push_back(son);
        }
    }
    dfs(1, 0);
    cout &amp;lt;&amp;lt; cnt[0];
    for (int i = 1; i &amp;lt;= max_depth; i++) {
        cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; cnt[i];
    }
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;完全二叉树&#34;&gt;完全二叉树&lt;/h3&gt;
&lt;p&gt;给定一个树，请你判断它是否是完全二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示树的结点个数。&lt;/p&gt;
&lt;p&gt;树的结点编号为 0∼N−1。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行对应一个结点，并给出该结点的左右子结点的编号，如果某个子结点不存在，则用 &lt;code&gt;-&lt;/code&gt; 代替。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是完全二叉树，则输出 &lt;code&gt;YES&lt;/code&gt; 以及最后一个结点的编号。&lt;/p&gt;
&lt;p&gt;如果不是，则输出 &lt;code&gt;NO&lt;/code&gt; 以及根结点的编号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤20&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9
7 8
- -
- -
- -
0 1
2 3
4 5
- -
- -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;YES 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
- -
4 5
0 6
- -
2 3
- 7
- -
- -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NO 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int N = 30;

int n;
int l[N], r[N];
int level[N];
bool st[N];
int key, id;

// 判断是完全二叉树，我们根节点开始编号为1
void dfs(int root, int k) {
    if (root == -1) 
        return;
    if (key &amp;lt; k) {
        key = k;
        id = root;
    }
    // 左儿子 2 * k
    dfs(l[root], k * 2);
    // 右儿子  2 * k + 1
    dfs(r[root], k * 2 + 1);
}

int main() {
    cin &amp;gt;&amp;gt; n;
    // 左右儿子全部先初始化为 -1
    memset(l, -1, sizeof l);
    memset(r, -1, sizeof r);
    for (int i = 0; i &amp;lt; n; i++) {
        string a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        if (a != &amp;quot;-&amp;quot;) {
            l[i] = stoi(a);
            st[l[i]] = true;
        }
        if (b != &amp;quot;-&amp;quot;) {
            r[i] = stoi(b);
            st[r[i]] = true;
        }
    }
    // 不是任何结点的左右儿子就是根节点
    int root = 0;
    while(st[root])
        root++;
    dfs(root, 1);
    // 全部按完全二叉树能填充进去，说明满足完全二叉树
    if (key == n)
        cout &amp;lt;&amp;lt; &amp;quot;YES&amp;quot; &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; id;
    else
        cout &amp;lt;&amp;lt; &amp;quot;NO&amp;quot; &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; root;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;等重路径&#34;&gt;等重路径&lt;/h3&gt;
&lt;p&gt;给定一个非空的树，树根为 R。&lt;/p&gt;
&lt;p&gt;树中每个节点 Ti 的权重为 Wi。从 R 到 L 的路径权重定义为从&lt;strong&gt;根节点&lt;/strong&gt;R 到任何&lt;strong&gt;叶节点&lt;/strong&gt;L 的路径中包含的所有节点的权重之和。&lt;/p&gt;
&lt;p&gt;现在给定一个加权树以及一个给定权重数字，请你找出树中所有的权重等于该数字的路径（必须从根节点到叶节点）。&lt;/p&gt;
&lt;p&gt;例如，我们考虑下图的树，对于每个节点，上方的数字是节点 &lt;code&gt;ID&lt;/code&gt;，它是两位数字，而下方的数字是该节点的权重。&lt;/p&gt;
&lt;p&gt;假设给定数为 24，则存在 4 个具有相同给定权重的不同路径：&lt;code&gt;{10 5 2 7}，{10 4 10}，{10 3 3 6 2}，{10 3 3 6 2}&lt;/code&gt;， 已经在图中用红色标出。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/03/27/19_0f9e40686f-212.jpg&#34; alt=&#34;212.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个整数 N,M,S，分别表示树的总节点数量，非叶子节点数量，给定权重数字。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个整数 Wi，表示每个节点的权重。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行的格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ID K ID[1] ID[2] ... ID[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ID 是一个两位数字，表示一个非叶子结点编号，K 是一个整数，表示它的子结点数，接下来的 K 个 ID[i] 也是两位数字，表示一个子结点的编号。&lt;/p&gt;
&lt;p&gt;出于方便考虑，根节点固定为 00，且树中所有节点的编号为 00∼N−1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;单调递减&lt;/strong&gt;的顺序输出所有权重为S的路径。&lt;/p&gt;
&lt;p&gt;每个路径占一行，从根节点到叶节点按顺序输出每个节点的权重。&lt;/p&gt;
&lt;p&gt;注意：我们称 A 序列 {A1,A2,…,An} 大于 B 序列 {B1,B2,…,Bm}，当且仅当存在一个整数 k，1≤k&amp;lt;min(n,m)，对于所有 1≤i≤k，Ai=Bi 成立，并且 Ak+1&amp;gt;Bk+1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤100,&lt;br&gt;
0≤M&amp;lt;N,&lt;br&gt;
0&amp;lt;S&amp;lt;230,&lt;br&gt;
0&amp;lt;Wi&amp;lt;1000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;20 9 24
10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2
00 4 01 02 03 04
02 1 05
04 2 06 07
03 3 11 12 13
06 1 09
07 2 08 10
16 1 15
13 3 14 16 17
17 2 18 19
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 5 2 7
10 4 10
10 3 3 6 2
10 3 3 6 2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;计算所有叶结点到根节点路径权值和&lt;/li&gt;
&lt;li&gt;等于目标值，存下来&lt;/li&gt;
&lt;li&gt;vctor排序，默认字典序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

const int N = 110;

int n, m, S;
int w[N];
bool g[N][N];
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;

void dfs(int u, int s, vector&amp;lt;int&amp;gt;&amp;amp; path) {
    bool is_leaf = true;
    // 判断是否为叶子节点
    for (int i = 0; i &amp;lt; n; i++) {
        if (g[u][i]) {
            is_leaf = false;
            break;
        }
    }
    // 是叶子结点
    if (is_leaf) {
        // 权值等于目标权值S
        if (s == S)
            res.push_back(path);
    }
    else {
        for (int i = 0; i &amp;lt; n; i++) {
            if (g[u][i]) {
                path.push_back(w[i]);
                dfs(i, s + w[i], path);
                // 恢复现场
                path.pop_back();
            }
        }
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; S;
    for (int i = 0; i &amp;lt; n; i++) 
        cin &amp;gt;&amp;gt; w[i];
    
    while (m--) {
        int id, k;
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; k;
        while (k--) {
            int son;
            cin &amp;gt;&amp;gt; son;
            g[id][son] = true;
        }
    }
    
    vector&amp;lt;int&amp;gt; path({w[0]});
    // 从根节点开始搜
    dfs(0, w[0], path);
    
    sort(res.begin(), res.end(), greater&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;());
    for (auto a : res) {
        cout &amp;lt;&amp;lt; a[0];
        for (int i = 1; i &amp;lt; a.size(); i++)
            cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; a[i];
        cout &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;供应链总销售额&#34;&gt;供应链总销售额&lt;/h3&gt;
&lt;p&gt;供应链是由零售商，经销商和供应商构成的销售网络，每个人都参与将产品从供应商转移到客户的过程。&lt;/p&gt;
&lt;p&gt;整个销售网络可以看作一个树形结构，从根部的供应商往下，每个人从上一级供应商中买入商品后，假定买入价格为 P，则会以高出买入价 r% 的价格向下出售。&lt;/p&gt;
&lt;p&gt;只有零售商（即叶节点）可以直接将产品销售给顾客。&lt;/p&gt;
&lt;p&gt;现在，给定整个销售网络，请你计算所有零售商的总销售额。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个数，N 表示供应链总成员数（所有成员编号从 0 到 N−1，根部供应商编号为 0），P 表示根部供应商的&lt;strong&gt;每件产品&lt;/strong&gt;的售卖价格，r，溢价百分比。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行包含一个成员的信息，格式如下：&lt;/p&gt;
&lt;p&gt;Ki ID[1] ID[2] … ID[Ki]&lt;/p&gt;
&lt;p&gt;其中第 i 行，Ki 表示从供应商 i 直接进货的成员数，接下来 Ki 个整数是每个进货成员的编号。&lt;/p&gt;
&lt;p&gt;如果某一行的 Kj 为 0，则表示这是零售商，那么后面只会跟一个数字，表示卖给客户的产品总件数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出总销售额，保留一位小数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤105,&lt;br&gt;
0&amp;lt;P≤1000,&lt;br&gt;
0&amp;lt;r≤50&lt;br&gt;
每个零售商手中的产品不超过 100 件。&lt;br&gt;
最终答案保证不超过 1010。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 1.80 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;42.4
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题的本质是求叶子结点的层数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;记忆化搜索&#34;&gt;记忆化搜索&lt;/h4&gt;
&lt;p&gt;求各个结点到根节点的距离：存储节点的时候，只存储每个结点的父节点信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;

const int N = 100010;

int n;
double P, R;
// 存所有节点
int p[N];
int f[N];
// 记录销售量
int c[N];
// 记忆化搜索过程，求每个结点到根节点的距离
int dfs(int u) {
    // f[u]已经被计算出来，直接返回
    if (f[u] != -1)
        return f[u];
    // 根节点
    if (p[u] == -1) {
        f[u] = 0;
        return 0;
    }
    // 当前结点层数 = 父节点层数 + 1
    f[u] = dfs(p[u]) + 1;
    return f[u];
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; P &amp;gt;&amp;gt; R;
    memset(p, -1, sizeof p);
    for (int i = 0; i &amp;lt; n; i++) {
        int k;
        cin &amp;gt;&amp;gt; k;
        for (int j = 0; j &amp;lt; k; j++) {
            int son;
            cin &amp;gt;&amp;gt; son;
            p[son] = i;
        }
        // 节点是叶子节点，输入销售量
        if (k == 0) {
            cin &amp;gt;&amp;gt; c[i];
        }
    }
    
    memset(f, -1, sizeof f);
    double res = 0;
    for (int i = 0; i &amp;lt; n; i++) {
        if (c[i] != 0)
            res += c[i] * P * pow(1 + R / 100, dfs(i));
    }
    
    printf(&amp;quot;%.1lf\n&amp;quot;, res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;dfs解法&#34;&gt;DFS解法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
using namespace std;

const int N = 100010;

int n;
double P, R;
// 记录销售量
int c[N];
// 使用邻接表来存树
vector&amp;lt;int&amp;gt; g[N];
double total = 0;

// 返回节点到根节点的距离
void dfs(int u, double p) {
    if (c[u] &amp;gt; 0) {
        total += c[u] * p;
    }
    else {
        for (int i = 0; i &amp;lt; g[u].size(); i++) {
            dfs(g[u][i], p * (1 + R / 100.0));
        }
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; P &amp;gt;&amp;gt; R;
    for (int i = 0; i &amp;lt; n; i++) {
        int k;
        cin &amp;gt;&amp;gt; k;
        for (int j = 0; j &amp;lt; k; j++) {
            int son;
            cin &amp;gt;&amp;gt; son;
            g[i].push_back(son);
        }
        // 节点是叶子节点，输入销售量
        if (k == 0) {
            cin &amp;gt;&amp;gt; c[i];
        }
    }
    
    dfs(0, P);
    
    printf(&amp;quot;%.1lf\n&amp;quot;, total);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;供应链最高价格&#34;&gt;供应链最高价格&lt;/h3&gt;
&lt;p&gt;供应链是由零售商，经销商和供应商构成的销售网络，每个人都参与将产品从供应商转移到客户的过程。&lt;/p&gt;
&lt;p&gt;整个销售网络可以看作一个树形结构，从根部的供应商往下，每个人从上一级供应商中买入商品后，假定买入价格为 P，则会以高出买入价 r% 的价格向下出售。&lt;/p&gt;
&lt;p&gt;只有零售商（即叶节点）可以直接将产品销售给顾客。&lt;/p&gt;
&lt;p&gt;现在，给定整个销售网络，请你计算零售商能达到的最高销售价格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个数，N 表示供应链总成员数（所有成员编号为 0 到 N−1)；P 表示根部供应商的产品销售价格；r，表示溢价百分比。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个数字，第 i 个数字 Si 是编号为 i 的成员的上级供应商的编号。根部供应商的 Sroot 为 -1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出零售商可达到的最高销售价格，保留两位小数，以及可达到最高销售价格的零售商的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤105,&lt;br&gt;
0&amp;lt;P≤1000,&lt;br&gt;
0&amp;lt;r≤50,&lt;br&gt;
最终答案保证不超过 1010。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9 1.80 1.00
1 5 4 4 -1 4 5 3 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.85 2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;问题本质是求最大深度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;cmath&amp;gt;

using namespace std;

const int N = 100010;

int n;
double P, R;
vector&amp;lt;int&amp;gt; g[N];
int max_depth = 0;
int cnt = 0;

void dfs(int u, int depth) {
    
    if (g[u].size() == 0) {
        if (depth &amp;gt; max_depth) {
            max_depth = depth;
            cnt = 1;
        }
        else if (depth == max_depth)
            cnt++;
        return;
    }
    else {
        for (int i = 0; i &amp;lt; g[u].size(); i++)
            dfs(g[u][i], depth + 1);
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; P &amp;gt;&amp;gt; R;
    int root;
    for (int i = 0; i &amp;lt; n; i++) {
        int a;
        cin &amp;gt;&amp;gt; a;
        if (a != -1)
            g[a].push_back(i);
        else {
            root = i;
        }
    }
    
    dfs(root, 0);
    
    printf(&amp;quot;%.2lf %d\n&amp;quot;, P * pow(1 + R / 100, max_depth), cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;供应链最低价格&#34;&gt;供应链最低价格&lt;/h3&gt;
&lt;p&gt;供应链是由零售商，经销商和供应商构成的销售网络，每个人都参与将产品从供应商转移到客户的过程。&lt;/p&gt;
&lt;p&gt;整个销售网络可以看作一个树形结构，从根部的供应商往下，每个人从上一级供应商中买入商品后，假定买入价格为 P，则会以高出买入价 r% 的价格向下出售。&lt;/p&gt;
&lt;p&gt;只有零售商（即叶节点）可以直接将产品销售给顾客。&lt;/p&gt;
&lt;p&gt;现在，给定整个销售网络，请你计算零售商能达到的最低销售价格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含三个数，N 表示供应链总成员数（所有成员编号从 0 到 N−1，根部供应商编号为 0），P 表示根部供应商的产品售卖价格，r，溢价百分比。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行包含一个成员的信息，格式如下：&lt;/p&gt;
&lt;p&gt;Ki ID[1] ID[2] … ID[Ki]&lt;/p&gt;
&lt;p&gt;其中第 i 行，Ki 表示从供应商 i 直接进货的成员数，接下来 Ki 个整数是每个进货成员的编号。&lt;/p&gt;
&lt;p&gt;如果 Kj 为 0 则表示第 j 名成员是零售商。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出零售商可达到的最低销售价格，保留四位小数，以及可达到最低销售价格的零售商的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤105,&lt;br&gt;
0&amp;lt;P≤1000,&lt;br&gt;
0&amp;lt;r≤50,&lt;br&gt;
最终答案保证不超过 1010&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 1.80 1.00
3 2 3 5
1 9
1 4
1 7
0
2 6 1
1 8
0
0
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.8362 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;ul&gt;
&lt;li&gt;问题本质是求最低深度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;cmath&amp;gt;

using namespace std;

const int N = 100010;

int n;
double P, R;
vector&amp;lt;int&amp;gt; g[N];
int min_depth = -1;
int cnt;

void dfs (int u, int depth) {
    if (g[u].size() == 0) {
        if (depth &amp;lt; min_depth || min_depth == -1) {
            min_depth = depth;
            cnt = 1;
        }
        else if (depth == min_depth)
            cnt++;
    }
    else {
        for (int i = 0; i &amp;lt; g[u].size(); i++)
            dfs(g[u][i], depth + 1);
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; P &amp;gt;&amp;gt; R;
    for (int i = 0; i &amp;lt; n; i++) {
        int k;
        cin &amp;gt;&amp;gt; k;
        while (k--) {
            int a;
            cin &amp;gt;&amp;gt; a;
            g[i].push_back(a);
        }
    }
    
    dfs(0, 0);
    
    printf(&amp;quot;%.4lf %d\n&amp;quot;, P * pow(1 + R / 100.0, min_depth), cnt);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;堆路径&#34;&gt;堆路径&lt;/h3&gt;
&lt;p&gt;在计算机科学中，堆是一种的基于树的专用数据结构，它具有堆属性：&lt;/p&gt;
&lt;p&gt;如果 P 是 C 的父结点，则在大顶堆中 P 结点的权值大于或等于 C 结点的权值，在小顶堆中 P 结点的权值小于或等于 C 结点的权值。&lt;/p&gt;
&lt;p&gt;一种堆的常见实现是二叉堆，它是由完全二叉树来实现的。&lt;/p&gt;
&lt;p&gt;可以肯定的是，在大顶/小顶堆中，任何从根到叶子的路径都必须按非递增/非递减顺序排列。&lt;/p&gt;
&lt;p&gt;你的任务是检查给定完全二叉树中的每个路径，以判断它是否是堆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示树中结点数量。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个 &lt;strong&gt;不同&lt;/strong&gt; 的整数，表示给定完全二叉树的层序遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于给定的树，首先输出所有从根到叶子的路径。&lt;/p&gt;
&lt;p&gt;每条路径占一行，数字之间用空格隔开，行首行尾不得有多余空格。&lt;/p&gt;
&lt;p&gt;必须以如下顺序输出路径：对于树中的每个结点都必须满足，其右子树中的路径先于其左子树中的路径输出。&lt;/p&gt;
&lt;p&gt;最后一行，如果是大顶堆，则输出 &lt;code&gt;Max Heap&lt;/code&gt;，如果是小顶堆，则输出 &lt;code&gt;Min Heap&lt;/code&gt;，如果不是堆，则输出 &lt;code&gt;Not Heap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&amp;lt;N≤1000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
98 72 86 60 65 12 23 50
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;98 86 23
98 86 12
98 72 65
98 72 60 50
Max Heap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
8 38 25 58 52 82 70 60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 25 70
8 25 82
8 38 52
8 38 58 60
Min Heap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
10 28 15 12 34 9 8 56
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 15 8
10 15 9
10 28 34
10 28 12 56
Not Heap
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大顶堆：从根节点往下路径严格下降&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小顶堆：从根节点往上路径严格上升&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFS搜到所有路径，进行判断是否满足大顶堆或小顶堆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 1010;

int n;
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
int h[N];
bool min_heap, max_heap;

void dfs(int u, vector&amp;lt;int&amp;gt;&amp;amp; path) {
    path.push_back(h[u]);
    // 是叶子结点的情况
    if (2 * u &amp;gt; n) {
        res.push_back(path);
    }
    if (2 * u + 1 &amp;lt;= n)
        dfs(2 * u + 1, path);
    if (2 * u &amp;lt;= n)
        dfs(2 * u, path);
    path.pop_back();
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) {
        cin &amp;gt;&amp;gt; h[i];
    }
    vector&amp;lt;int&amp;gt; path;
    dfs(1, path);
    
    for (auto p : res) {
        cout &amp;lt;&amp;lt; p[0];
        for (int i = 1; i &amp;lt; p.size(); i++) {
            cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; p[i];
            if (p[i] &amp;gt; p[i - 1])
                min_heap = true;
            else if (p[i] &amp;lt; p[i - 1]) 
                max_heap = true;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    
    if (min_heap &amp;amp;&amp;amp; max_heap)
        cout &amp;lt;&amp;lt; &amp;quot;Not Heap&amp;quot; &amp;lt;&amp;lt; endl;
    else if (min_heap)
        cout &amp;lt;&amp;lt; &amp;quot;Min Heap&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; &amp;quot;Max Heap&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;中缀表达式&#34;&gt;中缀表达式&lt;/h3&gt;
&lt;p&gt;给定一个句法二叉树，请你输出相应的中缀表达式，并利用括号反映运算符的优先级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N 表示二叉树的总结点个数。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行以下列格式给出一个结点的信息（第 i 行对应于第 i 个结点）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data left_child right_child
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;data&lt;/code&gt; 是一个长度不超过 10 的字符串，&lt;code&gt;left_child&lt;/code&gt; 和 &lt;code&gt;right_child&lt;/code&gt; 分别是该结点的左右子结点编号。&lt;/p&gt;
&lt;p&gt;所有结点编号从 1 到 N，NULL 用 -1 表示。&lt;/p&gt;
&lt;p&gt;以下两个图分别对应样例 1 和样例 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/12/19_fab5ca9c7c-11.JPG&#34; alt=&#34;11.JPG&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/12/19_019334bc7c-222.JPG&#34; alt=&#34;222.JPG&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请在一行输出中缀表达式，并利用括号反映运算符的优先级。&lt;/p&gt;
&lt;p&gt;注意，不能有多余括号，请任何符号之间不得有空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤20&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
* 8 7
a -1 -1
* 4 1
+ 2 5
b -1 -1
d -1 -1
- -1 6
c -1 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(a+b)*(c*(-d))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
2.35 -1 -1
* 6 1
- -1 4
% 7 8
+ 2 3
a -1 -1
str -1 -1
871 -1 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(a*2.35)+(-(str%871))
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;中序遍历序列加括号的一个过程（注意叶子结点不用添加括号）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

const int N = 30;

int n;
string w[N];
int l[N], r[N];
bool st[N], is_leaf[N];

string dfs (int u) {
    string left, right;
    if (l[u] != -1) {
        left = dfs(l[u]);
        // 判断当前层加不加括号
        if (!is_leaf[l[u]])
            left = &amp;quot;(&amp;quot; + left + &amp;quot;)&amp;quot;;
    }
    if (r[u] != -1) {
        right = dfs(r[u]);
        if (!is_leaf[r[u]])
            right = &amp;quot;(&amp;quot; + right + &amp;quot;)&amp;quot;;
    }
    return left + w[u] + right;
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) {
        cin &amp;gt;&amp;gt; w[i] &amp;gt;&amp;gt; l[i] &amp;gt;&amp;gt; r[i];
        // 如果是根节点，节点编号一定不是左右儿子所出现的编号
        if (l[i])
            st[l[i]] = true;
        if (r[i])
            st[r[i]] = true;
        // 标记是否是叶子节点，叶子节点不用添加左右括号
        if (l[i] == -1 &amp;amp;&amp;amp; r[i] == -1)
            is_leaf[i] = true;
    }
    
    // 找到根节点编号
    int root = 1;
    while (st[root])
        root++;
        
    cout &amp;lt;&amp;lt; dfs(root) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;bfs遍历相关&#34;&gt;BFS遍历相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072&#34;&gt;树的遍历&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016&#34;&gt;Z字型遍历二叉树&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048&#34;&gt;最大的一代&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;树的遍历&#34;&gt;树的遍历&lt;/h3&gt;
&lt;p&gt;一个二叉树，树中每个节点的权值互不相同。&lt;/p&gt;
&lt;p&gt;现在给出它的后序遍历和中序遍历，请你输出它的层序遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示二叉树的节点数。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个整数，表示二叉树的后序遍历。&lt;/p&gt;
&lt;p&gt;第三行包含 N 个整数，表示二叉树的中序遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一行 N 个整数，表示二叉树的层序遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 1 6 3 5 7 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

const int N = 40;
// 存储后序和中序的序列
int post[N], in[N];
// 用哈希表存根节点的左子树和右子树:第一维为表示树结点的值 第二维表示树节点指向的节点
unordered_map&amp;lt;int, int&amp;gt; l, r;
// 记录中序序列的下标
unordered_map&amp;lt;int, int&amp;gt; pos;

// 中序+后序重建二叉树
int build(int is, int ie, int ps, int pe) {
    // 找到根节点
    int root = post[pe];
    // 找到根节点在中序序列中的位置
    int k = pos[root];
    // 左子树存在，构建左子树
    if (is &amp;lt; k)
        l[root] = build(is, k - 1, ps, ps + (k - 1 - is));
    // 右子树存在，构建右子树
    if (k &amp;lt; ie) 
        r[root] = build(k + 1, ie, ps + (k - 1 - is) + 1, pe - 1);
    return root;
}

// 二叉树广度优先搜索,使用队列
void bfs(int root) {
    queue&amp;lt;int&amp;gt; qu;
    vector&amp;lt;int&amp;gt; res;
    qu.push(root);
    while (!qu.empty()) {
        int t = qu.front();
        qu.pop();
        res.push_back(t);
        if (l.count(t))
            qu.push(l[t]);
        if (r.count(t))
            qu.push(r[t]);
    }
    cout &amp;lt;&amp;lt; res[0];
    for (int i = 1; i &amp;lt; res.size(); i++) 
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[i];
}

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; post[i];
    }
    // 读入中序序列并保存中序序列的下标
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; in[i];
        pos[in[i]] = i;
    }
    // 构建树
    int root = build(0, n - 1, 0, n - 1);
    bfs(root);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;z字型遍历二叉树&#34;&gt;Z字型遍历二叉树&lt;/h3&gt;
&lt;p&gt;假设一个二叉树上各结点的权值互不相同。&lt;/p&gt;
&lt;p&gt;我们就可以通过其后序遍历和中序遍历来确定唯一二叉树。&lt;/p&gt;
&lt;p&gt;请你输出该二叉树的 Z 字形遍历序列----也就是说，从根结点开始，逐层遍历，第一层从右到左遍历，第二层从左到右遍历，第三层从右到左遍历，以此类推。&lt;/p&gt;
&lt;p&gt;例如，下图所示二叉树，其 Z 字形遍历序列应该为：&lt;code&gt;1 11 5 8 17 12 20 15&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/12/19_92e868327c-337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg&#34; alt=&#34;337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示二叉树结点数量。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个整数，表示二叉树的中序遍历序列。&lt;/p&gt;
&lt;p&gt;第三行包含 N 个整数，表示二叉树的后序遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出二叉树的 Z 字形遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
12 11 20 17 1 15 8 5
12 20 17 11 15 8 5 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 11 5 8 17 12 20 15
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 40;

vector&amp;lt;int&amp;gt; res;
int n;
unordered_map&amp;lt;int, int&amp;gt; l, r, pos;
int in[N], post[N];

// 构建二叉树
int build (int il, int ir, int pl, int pr) {
    int root = post[pr];
    int k = pos[root];
    
    if (il &amp;lt; k)
        l[root] = build(il, k - 1, pl, pl + k - il - 1);
    if (ir &amp;gt; k)
        r[root] = build(k + 1, ir, pl + k - il - 1 + 1, pr - 1);
    return root;
}

// 层序遍历
void bfs (int u) {
    queue&amp;lt;int&amp;gt; q;
    q.push(u);
    int step = 0;
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int cnt = q.size();
        while (cnt--) {
            int t = q.front();
            q.pop();
            v.push_back(t);
            if (l.count(t))
                q.push(l[t]);
            if (r.count(t))
                q.push(r[t]);
        }
        if (++step % 2)
            reverse(v.begin(), v.end());
        for (int i = 0; i &amp;lt; v.size(); i++)
            res.push_back(v[i]);
    }
}

int main() {
    cin &amp;gt;&amp;gt; n;
    // 使用hash记录下中序遍历的下标位置
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; in[i];
        pos[in[i]] = i;
    }
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; post[i];
    }
    int root = build(0, n - 1, 0, n - 1);
    bfs(root);
    cout &amp;lt;&amp;lt; res[0];
    for (int i = 1; i &amp;lt; res.size(); i++)
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[i];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;最大的一代&#34;&gt;最大的一代&lt;/h3&gt;
&lt;p&gt;家庭关系可以用家谱树来表示，同一层上的所有结点都属于同一代人。&lt;/p&gt;
&lt;p&gt;请你找出人数最多的一代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含一个整数 N 表示树中结点总数以及一个整数 M 表示非叶子结点数。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行的格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ID K ID[1] ID[2] ... ID[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ID 是一个两位数字，表示一个非叶子结点编号，K 是一个整数，表示它的子结点数，接下来的 K 个 ID[i] 也是两位数字，表示一个子结点的编号。&lt;/p&gt;
&lt;p&gt;为了简单起见，我们将根结点固定设为 01。&lt;/p&gt;
&lt;p&gt;所有结点的编号即为 01,02,03,…,31,32,33,…,N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出结点数量最多的一层的结点数量以及层级。&lt;/p&gt;
&lt;p&gt;保证答案唯一。&lt;/p&gt;
&lt;p&gt;根结点定义为第一层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0&amp;lt;N&amp;lt;100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;23 13
21 1 23
01 4 03 02 04 05
03 3 06 07 08
06 2 12 13
13 1 21
08 2 15 16
02 2 09 10
11 2 19 20
17 1 22
05 1 11
07 1 14
09 1 17
10 1 18
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9 4
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;BFS的时候存下每一层的结点，然后找到最大的那一层输出&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 110;

int n, m;
bool g[N][N];
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; level;

void bfs(int u) {
    queue&amp;lt;int&amp;gt; q;
    q.push(u);
    while (!q.empty()) {
        int cnt = q.size();
        vector&amp;lt;int&amp;gt; res;
        while (cnt--) {
            int t = q.front();
            res.push_back(t);
            q.pop();
            for (int i = 1; i &amp;lt;= n; i++) {
                if (g[t][i])
                    q.push(i);
            }
        }
        level.push_back(res);
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while (m--) {
        int id, k;
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; k;
        while (k--) {
            int son;
            cin &amp;gt;&amp;gt; son;
            g[id][son] = true;
        }
    }
    bfs(1);
    int max_size = 0;
    int max_id;
    for (int i = 0; i &amp;lt; level.size(); i++) {
        if (level[i].size() &amp;gt; max_size) {
            max_id = i;
            max_size = level[i].size();
        }
    }
    cout &amp;lt;&amp;lt; level[max_id].size() &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; max_id + 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856&#34;&gt;判断前序序列能够构成二叉搜索树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805407749357568&#34;&gt;判断完全二叉搜索树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805367987355648&#34;&gt;构建二叉搜索树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805355987451904&#34;&gt;二叉搜索树最后两层结点数量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;判断前序序列能否构成二叉搜索树镜像&#34;&gt;判断前序序列能否构成二叉搜索树(镜像)&lt;/h3&gt;
&lt;p&gt;二叉搜索树 (BST) 递归定义为具有以下属性的二叉树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值&lt;/li&gt;
&lt;li&gt;若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值&lt;/li&gt;
&lt;li&gt;它的左、右子树也分别为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将二叉搜索树镜面翻转得到的树称为二叉搜索树的镜像。&lt;/p&gt;
&lt;p&gt;现在，给定一个整数序列，请你判断它是否可能是某个二叉搜索树或其镜像进行前序遍历的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示节点数量。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果给定整数序列是某个二叉搜索树或其镜像的前序遍历序列，则在第一行输出 &lt;code&gt;YES&lt;/code&gt;，否则输出 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你的答案是 &lt;code&gt;YES&lt;/code&gt;，则还需要在第二行输出这棵树的后序遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤1000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
8 6 5 7 10 8 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;YES
5 7 6 8 11 10 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
8 10 11 8 6 7 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;YES
11 8 10 7 5 6 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
8 6 8 5 10 9 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NO
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;ul&gt;
&lt;li&gt;左子树要严格小于左子树，右子树大于等于左子树，所以当出现相同权值结点的时候，我们要取中序序列中相同值是第一个的位置&lt;/li&gt;
&lt;li&gt;镜像之后的中序序列是从大到小，每次在中序序列中找最后一个出现相同值的位置，刚好和镜像之前相反&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int N = 1010;

int n, cnt;
int preorder[N], inorder[N], postorder[N];

bool build (int il, int ir, int pl, int pr, int type) {
    // 当所有点都用完，可以构建成功
    if (il &amp;gt; ir)
        return true;
    int root = preorder[pl];
    int k;
    // 正向
    if (type == 0) {
        // 找到第一个相等的节点(BST定义)
        for (k = il; k &amp;lt;= ir; k++) {
            if (inorder[k] == root)
                break;
        }
        // 找不到构建失败
        if (k &amp;gt; ir)
            return false;
    }
    else {
        // 反向找到第一个相等的节点(BST定义)
        for (k = ir; k &amp;gt;= il; k--) {
            if (inorder[k] == root)
                break;
        }
        if (k &amp;lt; il)
            return false;
    }

    bool res = true;
    if (!build(il, k - 1, pl + 1, pl + 1 + (k - 1 - il), type))
        res = false;
    if (!build(k + 1, ir, pl + 1 + (k - 1 - il) + 1, pr, type))
        res = false;
    postorder[cnt++] = root;
    return res;
}


int main() {
    cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; preorder[i];
        inorder[i] = preorder[i];
    }
    sort(inorder, inorder + n);
    // 正常建树是否可以建成功
    if (build(0, n - 1, 0, n - 1, 0)) {
        cout &amp;lt;&amp;lt; &amp;quot;YES&amp;quot; &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; postorder[0];
        for (int i = 1; i &amp;lt; n; i++) 
            cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; postorder[i];
        cout &amp;lt;&amp;lt; endl;
    }else{
        reverse(inorder, inorder + n); 
        // 判断镜像建树是否可以建成功
        cnt = 0;
        if (build(0, n - 1, 0, n - 1, 1)) {
            cout &amp;lt;&amp;lt; &amp;quot;YES&amp;quot; &amp;lt;&amp;lt; endl;
            cout &amp;lt;&amp;lt; postorder[0];
            for (int i = 1; i &amp;lt; n; i++) 
                cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; postorder[i];
            cout &amp;lt;&amp;lt; endl;
        }else
            cout &amp;lt;&amp;lt; &amp;quot;NO&amp;quot; &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;判断完全二叉搜索树&#34;&gt;判断完全二叉搜索树&lt;/h3&gt;
&lt;p&gt;二叉搜索树 (BST) 递归定义为具有以下属性的二叉树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值&lt;/li&gt;
&lt;li&gt;若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值&lt;/li&gt;
&lt;li&gt;它的左、右子树也分别为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完全二叉树 (CBT) 定义为除最深层外的其他层的结点数都达到最大个数，最深层的所有结点都连续集中在最左边的二叉树。&lt;/p&gt;
&lt;p&gt;现在，给定 N 个不同非负整数，表示 N 个结点的权值，用这 N 个结点可以构成唯一的完全二叉搜索树。&lt;/p&gt;
&lt;p&gt;请你输出该完全二叉搜索树的层序遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示结点个数。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个不同非负整数，表示每个结点的权值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，输出给定完全二叉搜索树的层序遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤1000,&lt;br&gt;
结点权值不超过 2000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10
1 2 3 4 5 6 7 8 9 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 3 8 1 5 7 9 0 2 4
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树当前结点编号x，左儿子2 * x，右儿子2 * x + 1，父节点 x / 2&lt;/li&gt;
&lt;li&gt;构建n个结点的完全二叉树&lt;/li&gt;
&lt;li&gt;当使用中序序列填进完全二叉树，使其满足二叉搜索树的性质&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int N = 1010;

int n;
int w[N], t[N];

// 将中序遍历填进完全二叉树使其满足完全二叉搜索树性质
int dfs(int u, int&amp;amp; k) {
    if (u * 2 &amp;lt;= n)
        dfs(u * 2, k);
    t[u] = w[k++];
    if (u * 2 + 1 &amp;lt;= n)
        dfs(u * 2 + 1, k);
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; w[i];
    }
    // 排完序后w中存的就是中序遍历
    sort(w, w + n);
    int k = 0;
    dfs(1, k);
    cout &amp;lt;&amp;lt; t[1];
    for (int i = 2; i &amp;lt;= n; i++)
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; t[i];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;构建二叉搜索树输入为左右儿子&#34;&gt;构建二叉搜索树(输入为左右儿子)&lt;/h3&gt;
&lt;p&gt;二叉搜索树 (BST) 递归定义为具有以下属性的二叉树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值&lt;/li&gt;
&lt;li&gt;若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值&lt;/li&gt;
&lt;li&gt;它的左、右子树也分别为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定二叉树的具体结构以及一系列不同的整数，只有一种方法可以将这些数填充到树中，以使结果树满足 BST 的定义。&lt;/p&gt;
&lt;p&gt;请你输出结果树的层序遍历。&lt;/p&gt;
&lt;p&gt;示例如图 1 和图 2 所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/05/19_8639415877-24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg&#34; alt=&#34;24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含一个正整数 N，表示树的结点个数。&lt;/p&gt;
&lt;p&gt;所有结点的编号为 0∼N−1，并且编号为 0 的结点是根结点。&lt;/p&gt;
&lt;p&gt;接下来 N 行，第 i 行（从 0 计数）包含结点 i 的左右子结点编号。如果该结点的某个子结点不存在，则用 −1 表示。&lt;/p&gt;
&lt;p&gt;最后一行，包含 N 个不同的整数，表示要插入树中的数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出结果树的层序遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9
1 6
2 3
-1 -1
-1 4
5 -1
-1 -1
7 -1
-1 8
-1 -1
73 45 11 58 82 25 67 38 42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;58 25 82 11 38 67 45 73 42
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

const int N = 110;

int n, cnt;
// 存左右儿子
int l[N], r[N];
int a[N];
// 存节点权值
int w[N];
int p[N];

// 中序遍历去填充节点
void dfs(int u, int&amp;amp; k) {
    if (u == -1)
        return;
    dfs(l[u], k);
    w[u] = a[k++];
    dfs(r[u], k);
}

// 得到节点编号的层次遍历结果p
void bfs() {
    queue&amp;lt;int&amp;gt; q;
    q.push(0);
    while (!q.empty()) {
        int t = q.front();
        p[cnt++] = t;
        q.pop();
        if (l[t] != -1)
            q.push(l[t]);
        if (r[t] != -1)
            q.push(r[t]);
    }
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++){
        cin &amp;gt;&amp;gt; l[i] &amp;gt;&amp;gt; r[i];
    }
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; a[i];
    }
    sort(a, a + n);
    int k = 0;
    dfs(0, k);
    bfs();

    cout &amp;lt;&amp;lt; w[p[0]];
    for (int i = 1; i &amp;lt; n; i++) {
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; w[p[i]];
    }
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉搜索树最后两层结点数量根据插入序列建bst&#34;&gt;二叉搜索树最后两层结点数量(根据插入序列建BST)&lt;/h3&gt;
&lt;p&gt;二叉搜索树 (BST) 递归定义为具有以下属性的二叉树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若它的左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值&lt;/li&gt;
&lt;li&gt;若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值&lt;/li&gt;
&lt;li&gt;它的左、右子树也分别为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将一系列数字按顺序插入到一个空的二叉搜索树中，然后，请你计算结果树的最低两层的结点个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示插入数字序列包含的数字个数。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个整数，表示插入数字序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以如下格式，在一行中，输出结果树的最后两层的结点数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n1 + n2 = n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;n1&lt;/code&gt; 是最底层结点数量，&lt;code&gt;n2&lt;/code&gt; 是倒数第二层结点数量，&lt;code&gt;n&lt;/code&gt; 是它们的和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤1000,&lt;br&gt;
−1000≤ 插入数字 ≤1000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9
25 30 42 16 20 20 35 -5 28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 + 4 = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 1010;

int n;
int l[N], r[N];
// 记录结点权值
int v[N];
int max_depth, idx;
int cnt[N];

// 不断插入节点生成二叉搜索树(递归)
void insert (int&amp;amp; u, int w) {
    // 现在就要进行插入
    if (u == 0) {
        u = ++idx;
        v[u] = w;
    }
    // 插入到左子树
    else if (w &amp;lt;= v[u])
        insert(l[u], w);
    else 
        insert(r[u], w);
}

void dfs (int u, int depth) {
    if (u == 0)
        return;
    // 记录当前层节点数
    cnt[depth]++;
    max_depth = max(max_depth, depth);
    dfs(l[u], depth + 1);
    dfs(r[u], depth + 1);
}

int main () {
    cin &amp;gt;&amp;gt; n;
    int root = 0;
    for (int i = 0; i &amp;lt; n; i++) {
        int a;
        cin &amp;gt;&amp;gt; a;
        insert(root, a);
    }
    // dfs遍历树
    dfs(root, 0);
    
    cout &amp;lt;&amp;lt; cnt[max_depth] &amp;lt;&amp;lt; &amp;quot; + &amp;quot; &amp;lt;&amp;lt; cnt[max_depth - 1] &amp;lt;&amp;lt; &amp;quot; = &amp;quot; &amp;lt;&amp;lt; cnt[max_depth - 1] + cnt[max_depth] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;通过序列构建树&#34;&gt;通过序列构建树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024&#34;&gt;再次树遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805365537882112&#34;&gt;反转二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504&#34;&gt;前序和后序遍历序列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200&#34;&gt;后序遍历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用序列构建二叉树的题目出现频次较多，代码模板要熟记在心&lt;/p&gt;
&lt;h3 id=&#34;再次树遍历&#34;&gt;再次树遍历&lt;/h3&gt;
&lt;p&gt;通过使用栈可以以非递归方式实现二叉树的中序遍历。&lt;/p&gt;
&lt;p&gt;例如，假设遍历一个如下图所示的 6 节点的二叉树（节点编号从 1 到 6）。&lt;/p&gt;
&lt;p&gt;则堆栈操作为：push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop()。&lt;/p&gt;
&lt;p&gt;我们可以从此操作序列中生成唯一的二叉树。&lt;/p&gt;
&lt;p&gt;你的任务是给出这棵树的后序遍历。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/03/19_783e80c875-3.png&#34; alt=&#34;3.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示树中节点个数。&lt;/p&gt;
&lt;p&gt;树中节点编号从 1 到 N。&lt;/p&gt;
&lt;p&gt;接下来 2N 行，每行包含一个栈操作，格式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Push X&lt;/code&gt;，将编号为 X 的节点压入栈中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pop&lt;/code&gt;，弹出栈顶元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出这个二叉树的后序遍历序列。&lt;/p&gt;
&lt;p&gt;数据保证有解，数和数之间用空格隔开，末尾不能有多余空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 4 2 6 5 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Push操作序列顺序就是前序遍历&lt;/li&gt;
&lt;li&gt;Pop出的序列是中序序列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

const int N = 40;
int pre[N], in[N], post[N];
int n, cnt;

void build (int pl, int pr, int il, int ir) {
    if (il &amp;gt; ir)
        return;
    int root = pre[pl];
    // 中序序列中找到根的位置
    int k;
    for (k = il; k &amp;lt;= ir; k++) {
        if (in[k] == root)
            break;
    }
    
    build (pl + 1, pl + 1 + (k - 1 - il), il, k - 1);
    build (pl + 1 + (k - 1 - il) + 1, pr, k + 1, ir);
    post[cnt++] = root;
}

int main() {
    cin &amp;gt;&amp;gt; n;
    stack&amp;lt;int&amp;gt; s;
    int kp = 0;
    int ki = 0;
    for (int i = 0; i &amp;lt; n * 2; i++) {
        string op;
        cin &amp;gt;&amp;gt; op;
        if (op == &amp;quot;Push&amp;quot;) {
            int a;
            cin &amp;gt;&amp;gt; a;
            pre[kp++] = a;
            s.push(a);
        }
        else {
            in[ki++] = s.top();
            s.pop();
        }
    }
    
    build(0, n - 1, 0, n - 1);
    
    cout &amp;lt;&amp;lt; post[0];
    for (int i = 1; i &amp;lt; n; i++) {
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; post[i];
    }
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;反转二叉树&#34;&gt;反转二叉树&lt;/h3&gt;
&lt;p&gt;以下是来自 &lt;code&gt;Max Howell @twitter&lt;/code&gt; 的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;谷歌：我们的百分之九十的工程师都使用你编写的软件，但是你连在白板上反转二叉树都做不到，还是滚吧。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，请你证明你会反转二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含一个整数 N，表示树的结点数量。&lt;/p&gt;
&lt;p&gt;所有结点编号从 0 到 N−1。&lt;/p&gt;
&lt;p&gt;接下来 N 行，每行对应一个 0∼N−1 的结点，给出该结点的左右子结点的编号，如果该结点的某个子结点不存在，则用 &lt;code&gt;−&lt;/code&gt; 表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出反转后二叉树的层序遍历序列和中序遍历序列，每个序列占一行。&lt;/p&gt;
&lt;p&gt;相邻数字之间用空格隔开，末尾不得有多余空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤10&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
1 -
- -
0 -
2 7
- -
- -
5 -
4 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 7 2 6 4 0 5 1
6 5 7 4 3 2 0 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

const int N = 20;
int n, cnt;
// 记录左儿子和右儿子
int l[N], r[N];
// 记录中序遍历和层序遍历
int in[N], level[N];
bool st[N];

// 翻转二叉树
void reverse(int root) {
    if (root == -1)
        return;
    reverse(l[root]);
    reverse(r[root]);
    swap(l[root], r[root]);
}

void bfs(int root) {
    queue&amp;lt;int&amp;gt; q;
    q.push(root);
    while(!q.empty()){
        int t = q.front();
        level[cnt++] = t;
        q.pop();
        if (l[t] != -1)
            q.push(l[t]);
        if (r[t] != -1)
            q.push(r[t]);
    }
    cout &amp;lt;&amp;lt; level[0];
    for (int i = 1; i &amp;lt; n; i++) {
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; level[i];
    }
}

void dfs(int root) {
    if (root == -1)
        return;
    dfs(l[root]);
    in[cnt++] = root;
    dfs(r[root]);
}

int main() {
    cin &amp;gt;&amp;gt; n;
    memset(l, -1, sizeof l);
    memset(r, -1, sizeof r);
    for (int i = 0; i &amp;lt; n; i++) {
        string a, b;
        cin &amp;gt;&amp;gt; a;
        if (a != &amp;quot;-&amp;quot;){
            l[i] = stoi(a);
            st[l[i]] = true;
        }
        cin &amp;gt;&amp;gt; b;
        if (b != &amp;quot;-&amp;quot;){
            r[i] = stoi(b);
            st[r[i]] = true;
        }
    }
    
    // 找到根节点
    int root;
    for (int i = 0; i &amp;lt; n; i++) {
        if (!st[i]){
            root = i;
            break;
        }
    }
    // 翻转二叉树
    reverse(root);
    // 层序遍历
    bfs(root);
    // 中序遍历
    cout &amp;lt;&amp;lt; endl;
    cnt = 0;
    dfs(root);
    cout &amp;lt;&amp;lt; in[0];
    for (int i = 1; i &amp;lt; n; i++) {
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; in[i];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;前序和后序遍历序列&#34;&gt;前序和后序遍历序列&lt;/h3&gt;
&lt;p&gt;假设一个二叉树上所有结点的权值都互不相同。&lt;/p&gt;
&lt;p&gt;我们可以通过后序遍历和中序遍历来确定唯一二叉树。&lt;/p&gt;
&lt;p&gt;也可以通过前序遍历和中序遍历来确定唯一二叉树。&lt;/p&gt;
&lt;p&gt;但是，如果只通过前序遍历和后序遍历，则有可能无法确定唯一二叉树。&lt;/p&gt;
&lt;p&gt;现在，给定一组前序遍历和后序遍历，请你输出对应二叉树的中序遍历。&lt;/p&gt;
&lt;p&gt;如果树不是唯一的，则输出任意一种可能树的中序遍历即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示结点数量。&lt;/p&gt;
&lt;p&gt;第二行给出前序遍历序列。&lt;/p&gt;
&lt;p&gt;第三行给出后序遍历序列。&lt;/p&gt;
&lt;p&gt;一行中的数字都用空格隔开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先第一行，如果树唯一，则输出 &lt;code&gt;Yes&lt;/code&gt;，如果不唯一，则输出 &lt;code&gt;No&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后在第二行，输出树的中序遍历。&lt;/p&gt;
&lt;p&gt;注意，如果树不唯一，则输出任意一种可能的情况均可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yes
2 1 6 4 7 3 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4
1 2 3 4
2 4 3 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;No
2 1 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

const int N = 40;
int pre[N], post[N];
int cnt, n;

int dfs (int l1, int r1, int l2, int r2, string&amp;amp; in) {
    // 已经构建完成，说明方案合法
    if (l1 &amp;gt; r1)
        return 1;
    // 方案不合法
    if (pre[l1] != post[r2])
        return 0;
    // 枚举左子树包含的节点数量
    int cnt = 0;
    // 暴力枚举有多少种情况
    for (int i = l1; i &amp;lt;= r1; i++) {
        string lin, rin;
        int lcnt = dfs(l1 + 1, i, l2, l2 + i - l1 - 1, lin);
        int rcnt = dfs(i + 1, r1, l2 + i - l1 - 1 + 1, r2 - 1, rin);
        // 左右子树都存在，能够构建
        if (lcnt &amp;gt; 0 &amp;amp;&amp;amp; rcnt &amp;gt; 0) {
            in = lin + to_string(pre[l1]) + &#39; &#39; + rin;
            cnt += lcnt * rcnt;
            if (cnt &amp;gt; 1)
                break;
        }
    }
    return cnt;
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) 
        cin &amp;gt;&amp;gt; pre[i];
    for (int i = 0; i &amp;lt; n; i++)
        cin &amp;gt;&amp;gt; post[i];
    string in;
    // 求有多少种方案
    cnt = dfs(0, n - 1, 0, n - 1, in);
    if (cnt &amp;gt; 1)
        cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
    in.pop_back();
    cout &amp;lt;&amp;lt; in &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;后序遍历&#34;&gt;后序遍历&lt;/h3&gt;
&lt;p&gt;假设二叉树上各结点的权值互不相同且都为正整数。&lt;/p&gt;
&lt;p&gt;给定二叉树的前序遍历和中序遍历，请你输出二叉树的后序遍历的第一个数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示二叉树结点总数。&lt;/p&gt;
&lt;p&gt;第二行给出二叉树的前序遍历序列。&lt;/p&gt;
&lt;p&gt;第三行给出二叉树的中序遍历序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出二叉树的后序遍历的第一个数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤50000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
1 2 3 4 5 6 7
2 3 1 5 4 7 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
using namespace std;

const int N = 50010;
int pre[N], in[N];
unordered_map&amp;lt;int, int&amp;gt; pos;
int post, n;

void build(int il, int ir, int pl, int pr) {
    int root = pre[pl];
    int k = pos[root];
    
    if (il &amp;lt; k)
        build(il, k - 1, pl + 1, pl + 1 + k - 1 - il);
    if (ir &amp;gt; k)
        build(k + 1, ir, pl + 1 + k - 1 -il + 1, pr);
    if (post == 0)
        post = root;
}

int main () {
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; pre[i];
    }
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; in[i];
        pos[in[i]] = i;
    }
    build(0, n - 1, 0, n -1);
    cout &amp;lt;&amp;lt; post &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;avl平衡二叉树&#34;&gt;AVL平衡二叉树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805404939173888&#34;&gt;AVL树的根&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805351302414336&#34;&gt;判断完全AVL树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640&#34;&gt;判断红黑树&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;avl树的根&#34;&gt;AVL树的根&lt;/h3&gt;
&lt;p&gt;AVL树是一种自平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;在AVL树中，任何节点的两个子树的高度最多相差 1 个。&lt;/p&gt;
&lt;p&gt;如果某个时间，某节点的两个子树之间的高度差超过 1，则将通过树旋转进行重新平衡以恢复此属性。&lt;/p&gt;
&lt;p&gt;图 1−4 说明了旋转规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/03/30/19_3a941ca472-31.jpg&#34; alt=&#34;31.jpg&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/03/30/19_3dd0488472-32.jpg&#34; alt=&#34;32.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/03/30/19_411c0b5472-33.jpg&#34; alt=&#34;33.jpg&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/03/30/19_43ea12f472-34.jpg&#34; alt=&#34;34.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在，给定插入序列，请你求出 AVL 树的根是多少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示总插入值数量。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个不同的整数，表示每个插入值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出得到的 AVL 树的根是多少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤20&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5
88 70 61 96 120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;70
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7
88 70 61 96 120 90 65
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;88
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h4 id=&#34;ll型-右旋&#34;&gt;LL型  == &amp;gt; 右旋&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;将原来根（A）的左儿子变成新的根&lt;/li&gt;
&lt;li&gt;现在根（B）的右儿子变成原来根（A）的左儿子（根据二叉搜索树定义确定）&lt;/li&gt;
&lt;li&gt;现在根（B）的右儿子变成原来的根（A）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gg4zdbtp3ej310i0l2q4x.jpg&#34; alt=&#34;image-20200626000356718&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 右旋操作
void R (int&amp;amp; u) {
    // 原来根的左儿子变成新的根
    int p = l[u];
    // 现在根的右儿子变成原来根的左儿子
    l[u] = r[p];
    // 现在根的右儿子变成原来的根
    r[p] = u;
    update(u);
    update(p);
    u = p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;rr型-左旋&#34;&gt;RR型 ==&amp;gt; 左旋&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;将原来根（A）的右儿子变成新的根&lt;/li&gt;
&lt;li&gt;现在根（B）的左儿子变成原来根（A）的右儿子（根据二叉搜索树定义确定）&lt;/li&gt;
&lt;li&gt;现在根（B）的左儿子变成原来的根（A）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gg4zo7metaj314k0n20uy.jpg&#34; alt=&#34;image-20200626001424209&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 左旋操作
void L (int&amp;amp; u) {
    // 原来根的右儿子变成新的根
    int p = r[u];
    // 现在根的左儿子变成原来根的右儿子
    r[u] = l[p];
    // 现在根的左儿子变成原来的根
    l[p] = u;
    update(u);
    update(p);
    u = p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;lr型-左旋-右旋&#34;&gt;LR型 == &amp;gt; 左旋 + 右旋&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gg4zxdphrrj31h20hqaco.jpg&#34; alt=&#34;image-20200626002313342&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;rl型-右旋-左旋&#34;&gt;RL型 ==&amp;gt; 右旋 + 左旋&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gg506gjrn9j31g40j6goa.jpg&#34; alt=&#34;image-20200626003156461&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;构建平衡二叉树&#34;&gt;构建平衡二叉树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;插入结点构建二叉搜索树&lt;/li&gt;
&lt;li&gt;每次插入一个结点之后，获取根节点左右儿子高度差
&lt;ul&gt;
&lt;li&gt;左儿子结点的左右儿子高度差为1 == &amp;gt; LL 或者 RR（通过正负判断），否则就是 LR或者 RL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新树的高度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int N = 30;
int l[N], r[N], v[N], h[N], idx;


// 更新树的高度
void update(int u) {
    h[u] = max(h[l[u]], h[r[u]]) + 1;
}

// 右旋操作
void R (int&amp;amp; u) {
    // 原来根的左儿子变成新的根
    int p = l[u];
    // 现在根的右儿子变成原来根的左儿子
    l[u] = r[p];
    // 现在根的右儿子变成原来的根
    r[p] = u;
    update(u);
    update(p);
    u = p;
}

// 左旋操作
void L (int&amp;amp; u) {
    // 原来根的右儿子变成新的根
    int p = r[u];
    // 现在根的左儿子变成原来根的右儿子
    r[u] = l[p];
    // 现在根的左儿子变成原来的根
    l[p] = u;
    update(u);
    update(p);
    u = p;
}
// 获取左右儿子的高度差
int get_balance(int u) {
    return h[l[u]] - h[r[u]];
}

void insert(int&amp;amp; u, int w) {
    if (u == 0) {
        u = ++idx;
        v[u] = w;
    }
    // 插到根节点的左子树
    else if (w &amp;lt; v[u]) {
        insert(l[u], w);
        if (get_balance(u) == 2) {
            // LL型：右旋根节点
            if (get_balance(l[u]) == 1)
                R(u);
            // LR型：左旋左子树，右旋根
            else {
                L(l[u]);
                R(u);
            }
        }
    }
    // 插入到根节点的右子树
    else {
        insert(r[u], w);
        if (get_balance(u) == -2) {
            // RR型：左旋根节点
            if (get_balance(r[u]) == -1)
                L(u);
            // LR型：右旋右子树，左旋根
            else {
                R(r[u]);
                L(u);
            }
        }
    }
    // 更新树的高度
    update(u);
}

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    int root = 0;
    while (n--) {
        int w;
        cin &amp;gt;&amp;gt; w;
        insert(root, w);
    }
    
    cout &amp;lt;&amp;lt; v[root] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;判断完全avl树&#34;&gt;判断完全AVL树&lt;/h3&gt;
&lt;p&gt;AVL树是一种自平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;在AVL树中，任何节点的两个子树的高度最多相差 1 个。&lt;/p&gt;
&lt;p&gt;如果某个时间，某节点的两个子树之间的高度差超过 1，则将通过树旋转进行重新平衡以恢复此属性。&lt;/p&gt;
&lt;p&gt;图 1−4 说明了旋转规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/11/19_b107e4207b-1.jpg&#34; alt=&#34;1.jpg&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/11/19_b3f408627b-2.jpg&#34; alt=&#34;2.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/11/19_b8b9b5fe7b-3.jpg&#34; alt=&#34;3.jpg&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/11/19_bb4555f87b-4.jpg&#34; alt=&#34;4.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在，给定插入序列，请你输出得到的AVL树的层序遍历，并判断它是否是完全二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 N，表示插入序列中元素个数。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个不同的整数表示插入序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行输出得到的AVL树的层序遍历序列。&lt;/p&gt;
&lt;p&gt;第二行，如果该AVL树是完全二叉树，则输出 &lt;code&gt;YES&lt;/code&gt;，否则输出 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤N≤20&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5
88 70 61 63 65
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;70 63 88 61 65
YES
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输入样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
88 70 61 96 120 90 65 68
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;88 65 96 61 70 90 120 68
NO
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;构建平衡二叉树&lt;/li&gt;
&lt;li&gt;BFS判断是否是完全二叉树：pos从1开始记录，左右儿子按2 * i 和2 * i + 1 记录，若记录大于结点数n，则不是完全二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

const int N = 30;

// 记录左右儿子
int l[N], r[N];
// 记录节点权值
int v[N];
// 记录每个节点高度
int h[N];
// 记录层序遍历结果
int level[N];
// 记录节点编号
int pos[N];
int idx, n, cnt;

// 更新节点的高度
void update(int u) {
    h[u] = max(h[l[u]], h[r[u]]) + 1;
}

// 右旋
void R(int&amp;amp; u) {
    // 原来根的左儿子变成新的根
    int p = l[u];
    // 现在根的右儿子变成原来根的左儿子
    l[u] = r[p];
    // 现在根的右儿子变成原来的根
    r[p] = u;
    update(u);
    update(p);
    u = p;
}

// 左旋
void L(int&amp;amp; u) {
    // 原来根的右儿子变成新的根
    int p = r[u];
    // 现在根的左儿子变成原来根的右儿子
    r[u] = l[p];
    // 现在根的左儿子变成原来的根
    l[p] = u;
    update(u);
    update(p);
    u = p;
}

// 获取左右儿子高度差
int get_balance(int u) {
    return h[l[u]] - h[r[u]];
}

// 插入新节点到u的左儿子或右儿子
void insert(int&amp;amp; u, int w) {
    if (u == 0) {
        u = ++idx;
        v[u] = w;
    }
    // 插到根节点的左子树
    else if (w &amp;lt; v[u]) {
        insert(l[u], w);
        if (get_balance(u) == 2) {
            // LL型：右旋根节点
            if (get_balance(l[u]) == 1)
                R(u);
            // LR型：左旋左子树，右旋根
            else {
                L(l[u]);
                R(u);
            }
        }
    }
    // 插入到根节点的右子树
    else {
        insert(r[u], w);
        if (get_balance(u) == -2) {
            // RR型：左旋根节点
            if (get_balance(r[u]) == -1)
                L(u);
            // LR型：右旋右子树，左旋根
            else {
                R(r[u]);
                L(u);
            }
        }
    }
    // 更新树的高度
    update(u);
}


bool bfs(int u) {
    queue&amp;lt;int&amp;gt; q;
    q.push(u);
    pos[u] = 1;
    bool res = true;
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        level[cnt++] = t;
        if (pos[t] &amp;gt; n)
            res = false;
        if (l[t]) {
            q.push(l[t]);
            pos[l[t]] = pos[t] * 2;
        }
        if (r[t]) {
            q.push(r[t]);
            pos[r[t]] = pos[t] * 2 + 1;
        }
    }
    return res;
}

int main() {
    int root = 0;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        int w;
        cin &amp;gt;&amp;gt; w;
        insert(root, w);
    }
    bool res = bfs(root);
    cout &amp;lt;&amp;lt; v[level[0]];
    for (int i = 1; i &amp;lt; n; i++) {
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; v[level[i]];
    }
    cout &amp;lt;&amp;lt; endl;
    if (res)
        cout &amp;lt;&amp;lt; &amp;quot;YES&amp;quot; &amp;lt;&amp;lt; endl;
    else
        cout &amp;lt;&amp;lt; &amp;quot;NO&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;判断红黑树&#34;&gt;判断红黑树&lt;/h3&gt;
&lt;p&gt;数据结构中有一类平衡的二叉搜索树，称为红黑树。&lt;/p&gt;
&lt;p&gt;它具有以下 5 个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点是红色或黑色。&lt;/li&gt;
&lt;li&gt;根节点是黑色。&lt;/li&gt;
&lt;li&gt;所有叶子都是黑色。（叶子是 NULL节点）&lt;/li&gt;
&lt;li&gt;每个红色节点的两个子节点都是黑色。&lt;/li&gt;
&lt;li&gt;从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，下列三张图中，左图中的二叉树是红黑树，其余两图中的二叉树不是红黑树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/13/19_aefa6b627d-1.jpg&#34; alt=&#34;1.jpg&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/13/19_b137133a7d-2.jpg&#34; alt=&#34;2.jpg&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://cdn.acwing.com/media/article/image/2020/04/13/19_b3bfc8407d-3.jpg&#34; alt=&#34;3.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在，对于每个给定的二叉搜索树，请你判断它是否是合法的红黑树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的前序遍历序列可能不合法，即无法构建出合法二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含整数 K，表示共有 K 组测试数据。&lt;/p&gt;
&lt;p&gt;每组测试数据，第一行包含整数 N，表示二叉搜索树的节点数量。&lt;/p&gt;
&lt;p&gt;第二行给出了这个二叉搜索树的前序遍历。&lt;/p&gt;
&lt;p&gt;注意，虽然所有节点的权值都为正，但是我们使用负号表示红色节点。&lt;/p&gt;
&lt;p&gt;各节点权值互不相同。&lt;/p&gt;
&lt;p&gt;输入样例与题目中三个图例相对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每组数据，如果是合法红黑树则输出一行 &lt;code&gt;Yes&lt;/code&gt;，否则输出一行 &lt;code&gt;No&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤K≤30,&lt;br&gt;
1≤N≤30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
9
7 -2 1 5 -4 -11 8 14 -15
9
11 -2 1 -7 5 -4 8 14 -15
8
10 -7 5 -6 8 15 -11 17
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yes
No
No
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过前序和中序序列构建树（注意判断前序序列是否合法）&lt;/li&gt;
&lt;li&gt;判断左右子树中黑色结点个数是否相同&lt;/li&gt;
&lt;li&gt;红色结点下面必须是两个黑色结点判断&lt;/li&gt;
&lt;li&gt;统计黑色结点数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

const int N = 40;
int pre[N], in[N];
unordered_map&amp;lt;int, int&amp;gt; pos;
bool ans;

int build (int il, int ir, int pl, int pr, int&amp;amp; sum) {
    int root = pre[pl];
    int k = pos[abs(root)];
    // 如果前序序列不合法，返回false
    if (k &amp;lt; il || k &amp;gt; ir) {
        ans = false;
        return 0;
    }
    int left = 0;
    int right = 0;
    int ls = 0;
    int rs = 0;
    // 构建树的过程
    if (il &amp;lt; k)
        left = build(il, k - 1, pl + 1, pl + 1 + k - 1 - il, ls);
    if (k &amp;lt; ir)
        right = build(k + 1, ir, pl + 1 + k - 1 - il + 1, pr, rs);
    // 左右子树中黑色点的个数不同
    if (ls != rs)
        ans = false;
    sum = ls;
    // 每个红色节点下面必须是两个黑色节点
    if (root &amp;lt; 0) {
        if (left &amp;lt; 0 || right &amp;lt; 0)
            ans = false;
    }
    // 是黑色节点，则++
    else
        sum++;
        
    return root;
}

int main() {
    int T;
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        int n;
        cin &amp;gt;&amp;gt; n;
        for (int i = 0; i &amp;lt; n; i++) {
            cin &amp;gt;&amp;gt; pre[i];
            // 存在正负：存中序节点我们使用绝对值
            in[i] = abs(pre[i]);
        }
        sort(in, in + n);
        pos.clear();
        for (int i = 0; i &amp;lt; n; i++) 
            pos[in[i]] = i;
        ans = true;
        int sum;
        int root = build(0, n - 1, 0, n - 1, sum);
        
        if (root &amp;lt; 0)
            ans = false;
        if (ans)
            cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else
            cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;公共祖先&#34;&gt;公共祖先&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312&#34;&gt;最低公共祖先&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856&#34;&gt;二叉树中最低公共祖先&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;最低公共祖先&#34;&gt;最低公共祖先&lt;/h3&gt;
&lt;p&gt;树中两个结点 U 和 V 的最低公共祖先（LCA）是指同时具有 U 和 V 作为后代的最深结点。&lt;/p&gt;
&lt;p&gt;二叉搜索树 (BST) 递归定义为具有以下属性的二叉树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值&lt;/li&gt;
&lt;li&gt;若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值&lt;/li&gt;
&lt;li&gt;它的左、右子树也分别为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在给定 BST 中的任意两个结点，请你找出它们的最低公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 M 和 N，分别表示询问结点对数以及二叉搜索树中的结点数量。&lt;/p&gt;
&lt;p&gt;第二行包含 N 个不同整数，表示该二叉搜索树的前序遍历序列。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含两个不同的整数 U 和 V，表示一组询问。&lt;/p&gt;
&lt;p&gt;所有结点权值均在 &lt;strong&gt;int&lt;/strong&gt; 范围内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每对给定的 U 和 V，输出一行结果。&lt;/p&gt;
&lt;p&gt;如果 U 和 V 的 LCA 是 A，且 A 不是 U 或 V，则输出 &lt;code&gt;LCA of U and V is A.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果 U 和 V 的 LCA 是 A，且 A 是 U 或 V 中的一个，则输出 &lt;code&gt;X is an ancestor of Y.&lt;/code&gt;，其中 X 表示 A，Y 表示另一个结点。&lt;/p&gt;
&lt;p&gt;如果 U 或 V 没有在 BST 中找到，则输出 &lt;code&gt;ERROR: U is not found.&lt;/code&gt; 或 &lt;code&gt;ERROR: V is not found.&lt;/code&gt; 或 &lt;code&gt;ERROR: U and V are not found.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤M≤1000,&lt;br&gt;
1≤N≤10000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 8
6 3 1 2 5 4 8 7
2 5
8 7
1 9
12 -3
0 8
99 99
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LCA of 2 and 5 is 3.
8 is an ancestor of 7.
ERROR: 9 is not found.
ERROR: 12 and -3 are not found.
ERROR: 0 is not found.
ERROR: 99 and 99 are not found.
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;存储只需要存储结点的父节点，构建树的时候找所有点深度&lt;/li&gt;
&lt;li&gt;将比较低的点向上移动，找到与另一个点同一深度&lt;/li&gt;
&lt;li&gt;两个点同步向上找到相同的点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;题中结点权值是int范围，我们可以使用hash表做一个映射，映射到0 ~ N - 1，减少时间复杂度前面的常数
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 10010;

int m, n;
int in[N], pre[N];
// 存储离散化处理之前的数据
int seq[N];
// 映射：离散化处理
unordered_map&amp;lt;int, int&amp;gt; pos;
// 记录每个节点的父节点
int p[N];
int depth[N];

// 构建二叉树，并记录每个节点的层数
int build (int il, int ir, int pl, int pr, int d) {
    int root = pre[pl];
    // 进行了映射处理，根节点的值就是相应根节点在中序序列的下标
    int k = root;
    depth[root] = d;
    
    // 记录左右儿子的父节点为root
    if (il &amp;lt; k)
        p[build(il, k - 1, pl + 1, pl + 1 + k - 1- il, d + 1)] = root;
    if (k &amp;lt; ir)
        p[build(k + 1, ir, pl + 1 + k - 1 - il + 1, pr, d + 1)] = root;
    
    return root;
}


int main() {
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; pre[i];
        seq[i] = pre[i];
    }
    sort(seq, seq + n);
    
    // 把int范围内的数映射到 0 ~ n -1，减少常数级别的操作，pos中的key存的就是原来的值
    for (int i = 0; i &amp;lt; n; i++) {
        pos[seq[i]] = i;
        in[i] = i;
    }
    for (int i = 0; i &amp;lt; n; i++)
        pre[i] = pos[pre[i]];
    
    build(0, n - 1, 0, n - 1, 0);
    
    while (m--) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        // 查询合法
        if (pos.count(b) &amp;amp;&amp;amp; pos.count(a)) {
            a = pos[a];
            b = pos[b];
            // 记录下来查询的值
            int x = a;
            int y = b;
            // 找公共祖先节点
            while (a != b) {
                // b的深度更深，往上找父节点
                if (depth[a] &amp;lt; depth[b])
                    b = p[b];
                else
                    a = p[a];
            }
            if (a != x &amp;amp;&amp;amp; b != y)
                printf(&amp;quot;LCA of %d and %d is %d.\n&amp;quot;, seq[x], seq[y], seq[a]);
            else if (a == x)
                printf(&amp;quot;%d is an ancestor of %d.\n&amp;quot;, seq[x], seq[y]);
            else
                printf(&amp;quot;%d is an ancestor of %d.\n&amp;quot;, seq[y], seq[x]);
        }
        else if (pos.count(a) == 0 &amp;amp;&amp;amp; pos.count(b) == 0)
            printf(&amp;quot;ERROR: %d and %d are not found.\n&amp;quot;, a, b);
        else if (pos.count(a) == 0)
            printf(&amp;quot;ERROR: %d is not found.\n&amp;quot;, a);
        else
            printf(&amp;quot;ERROR: %d is not found.\n&amp;quot;, b);
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉树中最低公共祖先&#34;&gt;二叉树中最低公共祖先&lt;/h3&gt;
&lt;p&gt;树中两个结点 U 和 V 的最低公共祖先（LCA）是指同时具有 U 和 V 作为后代的最深结点。&lt;/p&gt;
&lt;p&gt;给定二叉树中的任何两个结点，请你找到它们的 LCA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 M 和 N，分别表示询问结点对数以及二叉树中的结点数量。&lt;/p&gt;
&lt;p&gt;接下来两行，每行包含 N 个不同的整数，分别表示二叉树的中序和前序遍历。&lt;/p&gt;
&lt;p&gt;保证二叉树可由给定遍历序列唯一确定。&lt;/p&gt;
&lt;p&gt;接下来 M 行，每行包含两个不同的整数 U 和 V，表示一组询问。&lt;/p&gt;
&lt;p&gt;所有结点权值均在 &lt;strong&gt;int&lt;/strong&gt; 范围内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每对给定的 U 和 V，输出一行结果。&lt;/p&gt;
&lt;p&gt;如果 U 和 V 的 LCA 是 A，且 A 不是 U 或 V，则输出 &lt;code&gt;LCA of U and V is A.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果 U 和 V 的 LCA 是 A，且 A 是 U 或 V 中的一个，则输出 &lt;code&gt;X is an ancestor of Y.&lt;/code&gt;，其中 X 表示 A，Y 表示另一个结点。&lt;/p&gt;
&lt;p&gt;如果 U 或 V 没有在二叉树中找到，则输出 &lt;code&gt;ERROR: U is not found.&lt;/code&gt; 或 &lt;code&gt;ERROR: V is not found.&lt;/code&gt; 或 &lt;code&gt;ERROR: U and V are not found.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1≤M≤1000,&lt;br&gt;
1≤N≤10000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6 8
7 2 3 4 6 5 1 8
5 3 7 2 6 4 8 1
2 6
8 1
7 9
12 -3
0 8
99 99
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LCA of 2 and 6 is 3.
8 is an ancestor of 1.
ERROR: 9 is not found.
ERROR: 12 and -3 are not found.
ERROR: 0 is not found.
ERROR: 99 and 99 are not found.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;unordered_map&amp;gt;

using namespace std;

const int N = 10010;

int n, m;
int pre[N], in[N], seq[N];
unordered_map&amp;lt;int, int&amp;gt; pos;
int p[N];
int depth[N];

int build (int il, int ir, int pl, int pr, int d) {
    int root = pre[pl];
    int k = root;
    depth[root] = d;
    
    if (il &amp;lt; k)
        p[build(il, k - 1, pl + 1, pl + 1 + k - 1 - il, d + 1)] = root;
    if (k &amp;lt; ir)
        p[build(k + 1, ir, pl + 1 + k - 1 - il + 1, pr, d + 1)] = root;
    
    return root;
}

int main() {
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    // 读入中序序列并映射
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; seq[i];
        pos[seq[i]] = i;
        in[i] = i;
    }
    // 读入前序序列并做好映射
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; pre[i];
        pre[i] = pos[pre[i]];
    }
    
    build(0, n - 1, 0, n - 1, 0);
    
    while (m--) {
        int a, b;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        // 查询合法
        if (pos.count(b) &amp;amp;&amp;amp; pos.count(a)) {
            a = pos[a];
            b = pos[b];
            // 记录下来查询的值
            int x = a;
            int y = b;
            // 找公共祖先节点
            while (a != b) {
                // b的深度更深，往上找父节点
                if (depth[a] &amp;lt; depth[b])
                    b = p[b];
                else
                    a = p[a];
            }
            if (a != x &amp;amp;&amp;amp; b != y)
                printf(&amp;quot;LCA of %d and %d is %d.\n&amp;quot;, seq[x], seq[y], seq[a]);
            else if (a == x)
                printf(&amp;quot;%d is an ancestor of %d.\n&amp;quot;, seq[x], seq[y]);
            else
                printf(&amp;quot;%d is an ancestor of %d.\n&amp;quot;, seq[y], seq[x]);
        }
        else if (pos.count(a) == 0 &amp;amp;&amp;amp; pos.count(b) == 0)
            printf(&amp;quot;ERROR: %d and %d are not found.\n&amp;quot;, a, b);
        else if (pos.count(a) == 0)
            printf(&amp;quot;ERROR: %d is not found.\n&amp;quot;, a);
        else
            printf(&amp;quot;ERROR: %d is not found.\n&amp;quot;, b);
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">树（实战篇）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/java-ji-chu-pian-si/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Java内存模型和虚拟机相关内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;java线程内存模型&#34;&gt;Java线程内存模型&lt;/h2&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9zv84vidnj30wd0u0dqz.jpg&#34; alt=&#34;image-20191217175041005&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;线程私有&#34;&gt;线程私有&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序计数器---&amp;gt;**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈---&amp;gt;&lt;strong&gt;其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。&lt;/strong&gt; （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法栈---&amp;gt;和虚拟机栈所发挥的作用非常相似，区别是： &lt;strong&gt;虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程共有&#34;&gt;线程共有&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;堆：Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。&lt;strong&gt;此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新生代(1/3)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eden(8/10)&lt;/li&gt;
&lt;li&gt;From Survivor(1/10)&lt;/li&gt;
&lt;li&gt;To Survivor(1/10)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代(2/3)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久代---&amp;gt;JDK1.8&lt;strong&gt;移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区：方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时常量池：&lt;strong&gt;运行时常量池是方法区的一部分&lt;/strong&gt;。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直接内存&#34;&gt;直接内存&lt;/h3&gt;
&lt;h2 id=&#34;常见垃圾回收算法&#34;&gt;常见垃圾回收算法&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md&#34;&gt;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如何判断对象已经死亡&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引用计数法----&amp;gt;&lt;strong&gt;不能解决循环引用问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。&lt;strong&gt;实现简单，效率高&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC Roots(可达性分析算法)&lt;/p&gt;
&lt;p&gt;​	&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga6jh9u01jj30s60jmafy.jpg&#34; alt=&#34;image-20191223122314902&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，&lt;strong&gt;则证明此对象是不可用的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可作为GC Roots的：&lt;strong&gt;线程栈变量、静态变量、常量池、JNI指针&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见垃圾回收算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记清除(Mark and sweep)&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga6jopo2u0j30vy0oyae1.jpg&#34; alt=&#34;image-20191223123026324&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;首先标记出所有需要回收的对象，&lt;strong&gt;在标记完成后统一回收所有被标记的对象&lt;/strong&gt;----&amp;gt;问题：位置不连续产生碎片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拷贝算法&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga6jq7761fj30vs0p0q7r.jpg&#34; alt=&#34;image-20191223123151261&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;它可以将&lt;strong&gt;内存分为大小相同的两块，每次使用其中的一块&lt;/strong&gt;。当这一块的内存使用完后，就将还存活的对象复制到另一块去，&lt;strong&gt;然后再把使用的空间一次清理掉&lt;/strong&gt;。这样就使每次的内存回收都是对内存区间的一半进行回收。&lt;strong&gt;没有碎片，效率高，连续&lt;/strong&gt;------&amp;gt;&lt;strong&gt;问题：浪费内存&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记-压缩(标记整理)&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga6jtlfwr9j313e0lygqa.jpg&#34; alt=&#34;image-20191223123507134&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;标记过程仍然与“标记-清除”算法一样，&lt;strong&gt;但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动&lt;/strong&gt;，然后直接清理掉端边界以外的内存。&lt;strong&gt;没有碎片&lt;/strong&gt;---&amp;gt;&lt;strong&gt;问题：浪费内存&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分代收集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种算法没有什么新的思想，&lt;strong&gt;只是根据对象存活周期的不同将内存分为几块&lt;/strong&gt;。一般将 java 堆分为&lt;strong&gt;新生代和老年代&lt;/strong&gt;，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hotspot虚拟机对象揭秘&#34;&gt;HotSpot虚拟机对象揭秘&lt;/h2&gt;
&lt;h3 id=&#34;对象创建过程&#34;&gt;对象创建过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类加载检查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申请内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指针碰撞&lt;/p&gt;
&lt;p&gt;用于堆内存比较规整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空闲列表&lt;/p&gt;
&lt;p&gt;用于堆内存比较零散&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9zyoumlhkj31nk0eiq6w.jpg&#34; alt=&#34;image-20191217195035011&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成员变量赋予默认值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用初始化方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;成员变量按顺序调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化成员变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造方法调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象内存布局&#34;&gt;对象内存布局&lt;/h3&gt;
&lt;p&gt;和虚拟机有关&lt;/p&gt;
&lt;p&gt;以HotSpot为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象头markWord&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储对象自身的自身运行时数据(哈希码、GC分代年龄、锁状态标志等等)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;类型指针----&amp;gt;指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例数据(对象的成员变量)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补齐(因为Hotspot虚拟机的自动内存管理系统要求对象&lt;strong&gt;起始地址必须是8字节的整数倍&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象的访问定位&#34;&gt;对象的访问定位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用句柄：Java堆中将会划分出一块内存来作为句柄池&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga0tr5oz9tj314i0jo46h.jpg&#34; alt=&#34;image-20191218134522761&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;直接指针： Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga0tsb9nsdj315i0k8jyq.jpg&#34; alt=&#34;image-20191218134627510&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;string类和常量池&#34;&gt;String类和常量池&lt;/h3&gt;
&lt;h4 id=&#34;string对象的两种创建方式&#34;&gt;String对象的两种创建方式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;String str1 = &amp;quot;abcd&amp;quot;;
String str2 = new String(&amp;quot;abcd&amp;quot;);
System.out.println(str1==str2);//false
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一种方式是在常量池中拿对象&lt;/li&gt;
&lt;li&gt;第二种方式是直接在堆内存空间创建一个新的对象。（只要使用了new方法，则一定会在堆内存区域创建新的对象）&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga0u00la52j312q0hyq4p.jpg&#34; alt=&#34;image-20191218135354038&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;string类型的常量池&#34;&gt;String类型的常量池&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接使用双引号声明出来的 String 对象会直接存储在常量池中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：&lt;strong&gt;如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用&lt;/strong&gt;；如果没有，&lt;strong&gt;则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s1 = new String(&amp;quot;计算机&amp;quot;);
String s2 = s1.intern();
String s3 = &amp;quot;计算机&amp;quot;;
System.out.println(s2);//计算机
System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，
System.out.println(s3 == s2);//true，因为两个都是常量池中的String对象字符串拼接
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串拼接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String str1 = &amp;quot;str&amp;quot;;
String str2 = &amp;quot;ing&amp;quot;;

String str3 = &amp;quot;str&amp;quot; + &amp;quot;ing&amp;quot;;		//常量池中的对象
String str4 = str1 + str2; 			//在堆上创建的新的对象	  
String str5 = &amp;quot;string&amp;quot;;					//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga0u4luznqj30u00v9djq.jpg&#34; alt=&#34;image-20191218135818700&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;string-str-new-stringabc创建了几个对象&#34;&gt;String str = new String(&amp;quot;abc&amp;quot;)创建了几个对象？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;2个&lt;/strong&gt;  先有&lt;strong&gt;字符串&amp;quot;abc&amp;quot;放入常量池&lt;/strong&gt;，然后 &lt;strong&gt;new 了一份字符串&amp;quot;abc&amp;quot;放入Java堆&lt;/strong&gt;(字符串常量&amp;quot;abc&amp;quot;在编译期就已经确定放入常量池，而 Java 堆上的&amp;quot;abc&amp;quot;是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的&amp;quot;abc&amp;quot;。&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		String s1 = new String(&amp;quot;abc&amp;quot;);// 堆内存的地址值
		String s2 = &amp;quot;abc&amp;quot;;
		System.out.println(s1 == s2);// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。
		System.out.println(s1.equals(s2));// 输出true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8种基本类型的包装类和常量池&#34;&gt;8种基本类型的包装类和常量池&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出false
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;深入理解包装类的装箱拆箱&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

System.out.println(&amp;quot;i1=i2   &amp;quot; + (i1 == i2));
System.out.println(&amp;quot;i1=i2+i3   &amp;quot; + (i1 == i2 + i3));
System.out.println(&amp;quot;i1=i4   &amp;quot; + (i1 == i4));
System.out.println(&amp;quot;i4=i5   &amp;quot; + (i4 == i5));
System.out.println(&amp;quot;i4=i5+i6   &amp;quot; + (i4 == i5 + i6));   
System.out.println(&amp;quot;40=i5+i6   &amp;quot; + (40 == i5 + i6));    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而&lt;strong&gt;使用常量池中的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Integer i4 = new Integer(40);这种情况下&lt;strong&gt;会创建新的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语句i4 == i5 + i6，&lt;strong&gt;因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加&lt;/strong&gt;，即i4 == 40。&lt;strong&gt;然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40&lt;/strong&gt;，最终这条语句转为40 == 40进行数值比较。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Java基础篇（四）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/java-ji-chu-pian-san/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇主要涉及到多线程方面的面试题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;线程-程序-进程&#34;&gt;线程、程序、进程&lt;/h2&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;- 定义：
	1、一个正在执行的程序
	2、系统运行程序的基本单位
	3、一个进程可由进程控制块(PCB包含：标识符、状态、优先级、程序计数器、内存指针、上下文数据、IO信息等)的数据结构来控制
	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进程状态&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9zrtw49tuj30s40bm0y5.jpg&#34; alt=&#34;image-20191217155307260&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新建态：线程被创建，PCB被创建出来但还未加载到内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就绪态：进程已经加载到内存，已经做好了准备，等待CPU进行调度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行态：得到CPU的调度，进程正在执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞态：进程因为某些事件需要停止执行(IO操作等)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出态：操作系统从可执行进程组中释放该进程，要么自己停止，要么因为某种原因被取消运行&lt;/p&gt;
&lt;p&gt;Java中&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9zscph8rfj31ba0u0dzc.jpg&#34; alt=&#34;image-20191217161118329&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个进程在其执行的过程中可以产生多个线程。与进程&lt;strong&gt;不同的是同类的多个线程共享同一块内存空间和一组系统资源&lt;/strong&gt;系统在产生一个线程，或是在&lt;strong&gt;各个线程之间作切换工作时，负担要比进程小得多&lt;/strong&gt;，也正因为如此，线程也被称为轻量级进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么是上下文切换&#34;&gt;什么是上下文切换？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多线程编程中一般&lt;strong&gt;线程的个数都大于 CPU 核心的个数&lt;/strong&gt;，而&lt;strong&gt;一个 CPU 核心在任意时刻只能被一个线程使用&lt;/strong&gt;，为了让这些线程都能得到有效执行，CPU 采取的策略是为&lt;strong&gt;每个线程分配时间片并轮转的形式&lt;/strong&gt;。当一个线程的时间片用完的时候就会&lt;strong&gt;重新处于就绪状态让给其他线程使用&lt;/strong&gt;，这个过程就属于一次上下文切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结说：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。&lt;strong&gt;任务从保存到再加载的过程就是一次上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sleep和wait方法的区别和共同点&#34;&gt;sleep()和wait()方法的区别和共同点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最主要的区别在于：&lt;strong&gt;sleep 方法没有释放锁，而 wait 方法释放了锁&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共同点：&lt;strong&gt;都可以暂停线程的执行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法&#34;&gt;为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;new 一个 Thread，线程进入了新建状态;&lt;strong&gt;调用 start() 方法，会启动一个线程并使线程进入了就绪状态&lt;/strong&gt;，当分配到时间片后就可以开始运行了。 &lt;strong&gt;start() 会执行线程的相应准备工作，然后自动执行 run() 方法&lt;/strong&gt;的内容&lt;/li&gt;
&lt;li&gt;直接执行 run() 方法，会把 run 方法&lt;strong&gt;当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java多线程3中实现方式&#34;&gt;Java多线程3中实现方式&lt;/h2&gt;
&lt;h3 id=&#34;继承thread类实现多线程&#34;&gt;继承Thread类实现多线程&lt;/h3&gt;
&lt;p&gt;继承Thread类的方法尽管被我列为一种多线程实现方式，但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyThread extends Thread {
　　public void run() {
　　 System.out.println(&amp;quot;MyThread.run()&amp;quot;);
　　}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在合适的地方启动线程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyThread myThread1 = new MyThread();
MyThread myThread2 = new MyThread();
myThread1.start();
myThread2.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实现runnable接口实现多线程&#34;&gt;实现Runnable接口实现多线程&lt;/h3&gt;
&lt;p&gt;如果自己的类已经extends另一个类，就无法直接extends Thread，此时，必须实现一个Runnable接口，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyThread extends OtherClass implements Runnable {
　　public void run() {
　　 System.out.println(&amp;quot;MyThread.run()&amp;quot;);
　　}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动MyThread&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyThread myThread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void run() {
　　if (target != null) {
　　 target.run();
　　}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用executorservice-callable-future实现有返回结果的多线程&#34;&gt;使用ExecutorService、Callable、Future实现有返回结果的多线程&lt;/h3&gt;
&lt;p&gt;Executor框架是指java 5中引入的一系列并发库中与executor相关的一些功能类，其中包括线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。他们的关系为：&lt;/p&gt;
&lt;p&gt;并发编程的一种编程方式是把任务拆分为一些列的小任务，即Runnable，然后在提交给一个Executor执行，&lt;strong&gt;Executor.execute(Runnalbe)&lt;/strong&gt; 。Executor在执行时使用内部的线程池完成操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建线程池&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Executors类，提供了&lt;strong&gt;一系列工厂方法用于创先线程池&lt;/strong&gt;，返回的线程池都实现了ExecutorService接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static ExecutorService newFixedThreadPool(int nThreads)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建固定数目线程的线程池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static ExecutorService newCachedThreadPool()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个可缓存的线程池，调用&lt;code&gt;execute&lt;/code&gt; 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static ExecutorService newSingleThreadExecutor()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个单线程化的Executor。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Executor executor = Executors.newFixedThreadPool(10);  
Runnable task = new Runnable() {  
    @Override  
    public void run() {  
        System.out.println(&amp;quot;task over&amp;quot;);  
    }  
};  
executor.execute(task);  
  
executor = Executors.newScheduledThreadPool(10);  
ScheduledExecutorService scheduler = (ScheduledExecutorService) executor;  
scheduler.scheduleAtFixedRate(task, 10, 10, TimeUnit.SECONDS);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ExecutorService生命周期&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ExecutorService&lt;strong&gt;扩展了Executor并添加了一些生命周期管理的方法&lt;/strong&gt;。一个Executor的生命周期有三种状态，&lt;strong&gt;运行&lt;/strong&gt; ，&lt;strong&gt;关闭&lt;/strong&gt; ，&lt;strong&gt;终止&lt;/strong&gt; 。Executor创建时处于运行状态。&lt;strong&gt;当调用ExecutorService.shutdown()后，处于关闭状态，isShutdown()方法返回true&lt;/strong&gt;。这时，不应该再想Executor中添加任务，所有已添加的任务执行完毕后，Executor处于终止状态，isTerminated()返回true。&lt;/p&gt;
&lt;p&gt;如果Executor处于关闭状态，往Executor提交任务会抛出unchecked exception RejectedExecutionException。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ExecutorService executorService = (ExecutorService) executor;  
while (!executorService.isShutdown()) {  
    try {  
        executorService.execute(task);  
    } catch (RejectedExecutionException ignored) {  
          
    }  
}  
executorService.shutdown();  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用Callable，Future返回结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Future&lt;V&gt;代表一个异步执行的操作，通过get()方法可以获得操作的结果，如果异步操作还没有完成，则，get()会使当前线程阻塞。&lt;strong&gt;FutureTask&lt;V&gt;实现了Future&lt;V&gt;和Runable&lt;V&gt;。Callable代表一个有返回值的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Callable&amp;lt;Integer&amp;gt; func = new Callable&amp;lt;Integer&amp;gt;(){  
    public Integer call() throws Exception {  
        System.out.println(&amp;quot;inside callable&amp;quot;);  
        Thread.sleep(1000);  
        return new Integer(8);  
    }         
};        
FutureTask&amp;lt;Integer&amp;gt; futureTask  = new FutureTask&amp;lt;Integer&amp;gt;(func);  
Thread newThread = new Thread(futureTask);  
newThread.start();  
  
try {  
    System.out.println(&amp;quot;blocking here&amp;quot;);  
    Integer result = futureTask.get();  
    System.out.println(result);  
} catch (InterruptedException ignored) {  
} catch (ExecutionException ignored) {  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;线程死锁&#34;&gt;线程死锁&lt;/h2&gt;
&lt;p&gt;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。&lt;/p&gt;
&lt;h3 id=&#34;产生死锁的必要条件&#34;&gt;产生死锁的必要条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：该资源任意一个时刻只由一个线程占用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求与保持条件&lt;/strong&gt;：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不剥夺条件&lt;/strong&gt;:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环等待条件&lt;/strong&gt;:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何避免死锁&#34;&gt;如何避免死锁？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;破坏互斥条件：&lt;strong&gt;没有办法破坏&lt;/strong&gt;，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏请求和保持条件：一次性申请所有的资源（银行家算法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;写一产生死锁的程序&#34;&gt;写一产生死锁的程序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -&amp;gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &amp;quot;get resource1&amp;quot;);
                try {
                    Thread.sleep(1000);  //
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &amp;quot;waiting get resource2&amp;quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &amp;quot;get resource2&amp;quot;);
                }
            }
        }, &amp;quot;线程 1&amp;quot;).start();

        new Thread(() -&amp;gt; {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + &amp;quot;get resource2&amp;quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &amp;quot;waiting get resource1&amp;quot;);
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + &amp;quot;get resource1&amp;quot;);
                }
            }
        }, &amp;quot;线程 2&amp;quot;).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;线程 A 通过 &lt;code&gt;synchronized (resource1) &lt;/code&gt;获得 resource1 的监视器锁，然后通过&lt;code&gt;Thread.sleep(1000);&lt;/code&gt;让线程 A 休眠 1s 为的是让&lt;strong&gt;线程 B 得到执行然后获取到 resource2 的监视器锁&lt;/strong&gt;。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这&lt;strong&gt;两个线程就会陷入互相等待的状态&lt;/strong&gt;，这也就产生了死锁。&lt;/p&gt;
&lt;h3 id=&#34;破坏死锁&#34;&gt;破坏死锁&lt;/h3&gt;
&lt;p&gt;靠&lt;strong&gt;按序申请资源来预防。按某一顺序申请资源&lt;/strong&gt;，释放资源则反序释放。破坏循环等待条件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Thread(() -&amp;gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &amp;quot;get resource1&amp;quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &amp;quot;waiting get resource2&amp;quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &amp;quot;get resource2&amp;quot;);
                }
            }
        }, &amp;quot;线程 2&amp;quot;).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了&lt;/strong&gt;。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。&lt;strong&gt;然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了&lt;/strong&gt;。这样就破坏了破坏循环等待条件，因此避免了死锁。&lt;/p&gt;
&lt;h2 id=&#34;乐观锁和悲观锁&#34;&gt;乐观锁和悲观锁&lt;/h2&gt;
&lt;h3 id=&#34;何为乐观锁-悲观锁&#34;&gt;何为乐观锁、悲观锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;乐观锁&lt;/p&gt;
&lt;p&gt;总是&lt;strong&gt;假设最好&lt;/strong&gt;的情况，每次去拿数据的时候都&lt;strong&gt;认为别人不会修改&lt;/strong&gt;，所以&lt;strong&gt;不会上锁&lt;/strong&gt;，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，&lt;strong&gt;乐观锁适用于多读的应用类型，这样可以提高吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;悲观锁&lt;/p&gt;
&lt;p&gt;总是&lt;strong&gt;假设最坏&lt;/strong&gt;的情况，每次去拿数据的时候都&lt;strong&gt;认为别人会修改&lt;/strong&gt;，所以每次在拿数据的时候都&lt;strong&gt;会上锁&lt;/strong&gt;，这样别人想拿这个数据就会阻塞直到它拿到锁（&lt;strong&gt;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&lt;/strong&gt;）。&lt;strong&gt;一般多写的场景下用悲观锁就比较合适。&lt;/strong&gt;----&amp;gt;synchronized ReentrantLock就是悲观锁的思想，传统的关系型数据库里边就用到了很多这种锁机制，比如&lt;strong&gt;行锁，表锁等，读锁，写锁&lt;/strong&gt;等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;乐观锁实现方式&#34;&gt;乐观锁实现方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本号控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		一般是在数据表中&lt;strong&gt;加上一个数据版本号version字段&lt;/strong&gt;，&lt;strong&gt;表示数据被修改的次数&lt;/strong&gt;，当数据被修改时，version值会加一。当线程&lt;strong&gt;A要更新数据值时，在读取数据的同时也会读取version值&lt;/strong&gt;，在&lt;strong&gt;提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新&lt;/strong&gt;，否则重试更新操作，直到更新成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga1xidusg9j31h00hmgu1.jpg&#34; alt=&#34;image-20191219124054387&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CAS算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即&lt;strong&gt;compare and swap（比较与交换）&lt;/strong&gt;，是一种有名的&lt;strong&gt;无锁算法&lt;/strong&gt;。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。&lt;strong&gt;CAS算法&lt;/strong&gt;涉及到三个操作数&lt;/p&gt;
&lt;p&gt;​		需要读写的内存值V&lt;/p&gt;
&lt;p&gt;​		进行比较的值A&lt;/p&gt;
&lt;p&gt;​		拟写入的新值B&lt;/p&gt;
&lt;p&gt;当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个&lt;strong&gt;自旋操作&lt;/strong&gt;，即&lt;strong&gt;不断的重试&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;乐观锁缺点&#34;&gt;乐观锁缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ABA问题&lt;/strong&gt;：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &lt;strong&gt;&amp;quot;ABA&amp;quot;问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决ABA问题办法----&amp;gt;引入版本号控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环时间长CPU开销大：&lt;strong&gt;自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只能保证一个共享变量的原子操作&lt;/strong&gt;：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。但是从 JDK 1.5开始，提供了&lt;code&gt;AtomicReference类&lt;/code&gt;来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用&lt;code&gt;AtomicReference类&lt;/code&gt;把多个共享变量合并成一个共享变量来操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cas和synchronized的使用场景&#34;&gt;CAS和Synchronized的使用场景&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		对于资源竞争较少（线程冲突较轻）的情况，&lt;strong&gt;使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源&lt;/strong&gt;；而&lt;strong&gt;CAS基于硬件实现，不需要进入内核&lt;/strong&gt;，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。&lt;/p&gt;
&lt;p&gt;​		Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 &lt;strong&gt;“重量级锁”&lt;/strong&gt; 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 &lt;strong&gt;偏向锁&lt;/strong&gt; 和 &lt;strong&gt;轻量级锁&lt;/strong&gt; 以及其它&lt;strong&gt;各种优化&lt;/strong&gt;之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 &lt;strong&gt;Lock-Free&lt;/strong&gt; 的队列，基本思路是 &lt;strong&gt;自旋后阻塞&lt;/strong&gt;，&lt;strong&gt;竞争切换后继续竞争锁&lt;/strong&gt;，&lt;strong&gt;稍微牺牲了公平性，但获得了高吞吐量&lt;/strong&gt;。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。&lt;/p&gt;
&lt;h2 id=&#34;synchronizedreentrantlocklock&#34;&gt;Synchronized,ReentrantLock,Lock&lt;/h2&gt;
&lt;h3 id=&#34;synchronized关键字用法&#34;&gt;synchronized关键字用法&lt;/h3&gt;
&lt;h4 id=&#34;修饰代码块&#34;&gt;&lt;strong&gt;修饰代码块&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，&lt;strong&gt;作用的对象是调用这个代码块的对象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Demo1 ---&amp;gt;理解synchronized关键字锁的是对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SyncThread implements Runnable {
   private static int count;

   public SyncThread() {
      count = 0;
   }

   public  void run() {
      synchronized(this) {
         for (int i = 0; i &amp;lt; 5; i++) {
            try {
               System.out.println(Thread.currentThread().getName() + &amp;quot;:&amp;quot; + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }

   public int getCount() {
      return count;
   }
}




&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用结果1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// main方法调用----&amp;gt;一个对象
SyncThread syncThread = new SyncThread();
Thread thread1 = new Thread(syncThread, &amp;quot;SyncThread1&amp;quot;);
Thread thread2 = new Thread(syncThread, &amp;quot;SyncThread2&amp;quot;);
thread1.start();
thread2.start();

结果：
SyncThread1:0
SyncThread1:1
SyncThread1:2
SyncThread1:3
SyncThread1:4
SyncThread2:5
SyncThread2:6
SyncThread2:7
SyncThread2:8
SyncThread2:9

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用结果2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// main方法调用----&amp;gt;两个对象的时候
SyncThread syncThread1 = new SyncThread();
SyncThread syncThread2 = new SyncThread();
Thread thread1 = new Thread(syncThread1, &amp;quot;SyncThread1&amp;quot;);
Thread thread2 = new Thread(syncThread2, &amp;quot;SyncThread2&amp;quot;);
thread1.start();
thread2.start();


SyncThread1:0
SyncThread2:1
SyncThread1:2
SyncThread2:3
SyncThread1:4
SyncThread2:5
SyncThread2:6
SyncThread1:7
SyncThread1:8
SyncThread2:9

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时创建了&lt;strong&gt;两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)&lt;/strong&gt;；我们知道synchronized锁定的是对象，这时会有&lt;strong&gt;两把锁&lt;/strong&gt;分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Demo2---&amp;gt;指定某个对象加锁&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 银行账户类
 */
class Account {
   String name;
   float amount;

   public Account(String name, float amount) {
      this.name = name;
      this.amount = amount;
   }
   //存钱
   public  void deposit(float amt) {
      amount += amt;
      try {
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
   //取钱
   public  void withdraw(float amt) {
      amount -= amt;
      try {
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }

   public float getBalance() {
      return amount;
   }
}

/**
 * 账户操作类
 */
class AccountOperator implements Runnable{
   private Account account;
   public AccountOperator(Account account) {
      this.account = account;
   }

   public void run() {
      synchronized (account) {
         account.deposit(500);
         account.withdraw(500);
         System.out.println(Thread.currentThread().getName() + &amp;quot;:&amp;quot; + account.getBalance());
      }
   }
}

// main方法进行调用
Account account = new Account(&amp;quot;zhang san&amp;quot;, 10000.0f);
AccountOperator accountOperator = new AccountOperator(account);

final int THREAD_NUM = 5;
Thread threads[] = new Thread[THREAD_NUM];
for (int i = 0; i &amp;lt; THREAD_NUM; i ++) {
   threads[i] = new Thread(accountOperator, &amp;quot;Thread&amp;quot; + i);
   threads[i].start();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread3:10000.0
Thread2:10000.0
Thread1:10000.0
Thread4:10000.0
Thread0:10000.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修饰普通方法&#34;&gt;修饰普通方法&lt;/h4&gt;
&lt;p&gt;被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，&lt;strong&gt;只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga5k9ll02vj30x80u0430.jpg&#34; alt=&#34;image-20191222160453297&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。&lt;strong&gt;如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的&lt;/strong&gt;，而必须显式地在&lt;strong&gt;子类的这个方法中加上synchronized关键字才可以&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga5kcdlrp3j30tg0l476y.jpg&#34; alt=&#34;image-20191222160736255&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;修饰一个静态的方法&#34;&gt;修饰一个静态的方法&lt;/h4&gt;
&lt;p&gt;其作用的范围是整个静态方法，作用的对象是这个类的所有对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Demo：synchronized关键字修饰静态方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 同步线程
 */
class SyncThread implements Runnable {
   private static int count;

   public SyncThread() {
      count = 0;
   }

   public synchronized static void method() {
      for (int i = 0; i &amp;lt; 5; i ++) {
         try {
            System.out.println(Thread.currentThread().getName() + &amp;quot;:&amp;quot; + (count++));
            Thread.sleep(100);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }

   public synchronized void run() {
      method();
   }
}

// main方法中的调用
SyncThread syncThread1 = new SyncThread();
SyncThread syncThread2 = new SyncThread();
Thread thread1 = new Thread(syncThread1, &amp;quot;SyncThread1&amp;quot;);
Thread thread2 = new Thread(syncThread2, &amp;quot;SyncThread2&amp;quot;);
thread1.start();
thread2.start();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SyncThread1:0
SyncThread1:1
SyncThread1:2
SyncThread1:3
SyncThread1:4
SyncThread2:5
SyncThread2:6
SyncThread2:7
SyncThread2:8
SyncThread2:9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，&lt;strong&gt;而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;修饰类&#34;&gt;修饰类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ClassName {
   public void method() {
      synchronized(ClassName.class) {
         // todo
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;synchronized底层实现&#34;&gt;synchronized底层实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进入执行synchronized代码块： monitorenter：count++&lt;/li&gt;
&lt;li&gt;释放：monitorexit： count--；&lt;/li&gt;
&lt;li&gt;线程判断计数器是否是0，如果是0表示当前锁空闲，可以进行占用，反之就等待&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;synchronized性能优化&#34;&gt;synchronized性能优化&lt;/h3&gt;
&lt;p&gt;参考：http://www.pianshen.com/article/13827882/&lt;/p&gt;
&lt;h4 id=&#34;jdk16之前重量级锁&#34;&gt;JDK1.6之前（重量级锁）&lt;/h4&gt;
&lt;p&gt;​		&lt;strong&gt;Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的&lt;/strong&gt;。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而**操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。**因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用&lt;/p&gt;
&lt;h4 id=&#34;jdk16之后锁升级&#34;&gt;JDK1.6之后（锁升级）&lt;/h4&gt;
&lt;p&gt;锁的升级过程如下：&lt;em&gt;&lt;strong&gt;*锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁*&lt;/strong&gt;&lt;/em&gt;。(对象头中锁的状态是2个字节)随着锁的竞争，锁可以从&lt;strong&gt;偏向锁升级到轻量级锁，再升级的重量级锁&lt;/strong&gt;（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自旋锁优化----&amp;gt;自适应自旋锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**频繁的阻塞和唤醒对CPU来说是一件负担很重的工作,所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。**怎么等待呢？执行一段无意义的循环即可（自旋),如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好&lt;/p&gt;
&lt;p&gt;JDK 1.6引入了更加聪明的自旋锁，即&lt;em&gt;&lt;strong&gt;自适应自旋锁&lt;/strong&gt;&lt;/em&gt;。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？**线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。**反之，&lt;strong&gt;如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锁消除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁消除&lt;strong&gt;是Java虚拟机在JIT编译时&lt;/strong&gt;，通过对运行上下文的扫描，&lt;strong&gt;去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间&lt;/strong&gt;。就是JVM会检测到不可能存在共享数据竞争，JVM会进行锁的消除(StringBuffer,Vector,HashTable)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锁粗化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将连续的加锁 精简到只加一次锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StringBufferTest {
    StringBuffer stringBuffer = new StringBuffer();
 
    public void append(){
        stringBuffer.append(&amp;quot;a&amp;quot;);
        stringBuffer.append(&amp;quot;b&amp;quot;);
        stringBuffer.append(&amp;quot;c&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里&lt;strong&gt;每次调用stringBuffer.append方法都需要加锁和解锁&lt;/strong&gt;，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，&lt;strong&gt;即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无竞争的条件下，通过CAS消除同步互斥&lt;/strong&gt;多个线程交替同步执行的情况，没有竞争&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无竞争条件下，消除整个互斥同步，&lt;strong&gt;连CAS都不做(只有一个线程执行同步)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入偏向锁是为了在&lt;strong&gt;无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径&lt;/strong&gt;，因为轻量级锁的获取及释放&lt;strong&gt;依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令&lt;/strong&gt;（由于一旦出现&lt;strong&gt;多线程竞争的情况就必须撤销偏向锁&lt;/strong&gt;，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。&lt;/p&gt;
&lt;p&gt;​		偏向锁只有&lt;strong&gt;遇到其他线程尝试竞争偏向锁时&lt;/strong&gt;，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga5m43mnzij316c0e80vr.jpg&#34; alt=&#34;image-20191222170850243&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lock&#34;&gt;Lock&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga5m8g1y7bj31ik0mi78d.jpg&#34; alt=&#34;image-20191222171301152&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		Lock实现和synchronized不一样，&lt;strong&gt;后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来&lt;/strong&gt;。而&lt;strong&gt;Lock呢底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Lock接口的源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Lock {

    /**
     * Acquires the lock.
     */
    void lock();

    /**
     * Acquires the lock unless the current thread is
     * {@linkplain Thread#interrupt interrupted}.
     */
    void lockInterruptibly() throws InterruptedException;

    /**
     * Acquires the lock only if it is free at the time of invocation.
     */
    boolean tryLock();

    /**
     * Acquires the lock if it is free within the given waiting time and the
     * current thread has not been {@linkplain Thread#interrupt interrupted}.
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    /**
     * Releases the lock.
     */
    void unlock();
	
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reentrantlock&#34;&gt;ReentrantLock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ReentrantLock是Lock的一个具体实现类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockTest {
	private Lock lock = new ReentrantLock();

	//需要参与同步的方法
	private void method(Thread thread){
		lock.lock();
		try {
			System.out.println(&amp;quot;线程名&amp;quot;+thread.getName() + &amp;quot;获得了锁&amp;quot;);
		}catch(Exception e){
			e.printStackTrace();
		} finally {
			System.out.println(&amp;quot;线程名&amp;quot;+thread.getName() + &amp;quot;释放了锁&amp;quot;);
			lock.unlock();
		}
	}
	
	public static void main(String[] args) {
		LockTest lockTest = new LockTest();
		
		//线程1
		Thread t1 = new Thread(new Runnable() {
			
			@Override
			public void run() {
				lockTest.method(Thread.currentThread());
			}
		}, &amp;quot;t1&amp;quot;);
		
		Thread t2 = new Thread(new Runnable() {
			
			@Override
			public void run() {
				lockTest.method(Thread.currentThread());
			}
		}, &amp;quot;t2&amp;quot;);
		
		t1.start();
		t2.start();
	}
}
//执行情况： 线程名t1获得了锁
//         线程名t1释放了锁
//         线程名t2获得了锁
//         线程名t2释放了锁

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reentrantlock和synchronized用法区别&#34;&gt;ReentrantLock和synchronized用法区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用ReentrantlLock保护代码块一定要在finally块里面释放锁，synchronized不需要，JVM自动帮助我们释放&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Lock lock = new ReentrantLock();
lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;性能区别&lt;/p&gt;
&lt;p&gt;在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能区别&lt;/p&gt;
&lt;p&gt;便利性：很明显&lt;strong&gt;Synchronized的使用比较方便简洁&lt;/strong&gt;，并且&lt;strong&gt;由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁&lt;/strong&gt;，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。&lt;/p&gt;
&lt;p&gt;锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;竞争资源不是很激烈，偶有同步---&amp;gt;synchronized&lt;/li&gt;
&lt;li&gt;同步激烈，synchronized性能急剧下降---&amp;gt;ReentrantLock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们什么时候才应该使用 &lt;code&gt;ReentrantLock&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;在确实需要一些 synchronized 所没有的特性的时候&lt;/strong&gt;，比如&lt;strong&gt;时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票(ReentrantLock的独有魅力)&lt;/strong&gt;。 &lt;code&gt;ReentrantLock&lt;/code&gt; 还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数 synchronized 块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用 synchronized 开发，直到确实证明 synchronized 不合适，而不要仅仅是假设如果使用 &lt;code&gt;ReentrantLock&lt;/code&gt; “性能会更好”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Java基础篇（三）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/java-ji-chu-pian-er/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;从本篇起，Java基础篇的整理主要偏向于面试题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;面向对象和面向过程的区别&#34;&gt;面向对象和面向过程的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向过程性能高，因为类调用时需要实例化，开销比较大，比较消耗资源&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向过程没有面向对象易维护、易复用、易扩展(封装、继承、多态)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm&#34;&gt;JVM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java虚拟机（JVM）是运行 Java 字节码的虚拟机。&lt;strong&gt;JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果&lt;/strong&gt;。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构造器constructor-是否可被-override&#34;&gt;构造器Constructor 是否可被 override?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就&lt;strong&gt;不能被 override（重写）&lt;/strong&gt;,但是&lt;strong&gt;可以 overload（重载）&lt;/strong&gt;,所以你可以看到一个类中有多个构造函数的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java面向对象三大特性封装-继承-多态&#34;&gt;Java面向对象三大特性：封装、继承、多态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;封装：封装把一&lt;strong&gt;个对象的属性私有化&lt;/strong&gt;，同时&lt;strong&gt;提供一些可以被外界访问的属性的方法&lt;/strong&gt;，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的&#34;&gt;String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;String类中：private &lt;strong&gt;final&lt;/strong&gt; char value[]  ---&amp;gt;不可变&lt;/li&gt;
&lt;li&gt;StringBuilder 与 StringBuffer 的构造方法都是&lt;strong&gt;调用父类构造方法也就是 AbstractStringBuilder 实现&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;StringBuffer 对方法&lt;strong&gt;加了同步锁或者对调用的方法加了同步锁(synchronized)&lt;/strong&gt;，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口和抽象类区别&#34;&gt;接口和抽象类区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;接口的方法&lt;strong&gt;默认是 public&lt;/strong&gt;，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），&lt;strong&gt;而抽象类可以有非抽象的方法。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接口中&lt;strong&gt;除了static、final变量，不能有其他变量&lt;/strong&gt;，而抽象类中则不一定。&lt;/li&gt;
&lt;li&gt;一个类可以实现多个接口，&lt;strong&gt;但只能实现一个抽象类&lt;/strong&gt;。接口自己本身可以通过extends关键字扩展多个接口。&lt;/li&gt;
&lt;li&gt;在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对象实体和对象引用有何区别&#34;&gt;对象实体和对象引用有何区别？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;new创建对象实例（&lt;strong&gt;对象实例在堆内存中&lt;/strong&gt;），&lt;strong&gt;对象引用指向对象实例&lt;/strong&gt;（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;&lt;strong&gt;一个对象可以有n个引用指向它&lt;/strong&gt;（可以用n条绳子系住一个气球）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实例方法和静态方法有何不同&#34;&gt;实例方法和静态方法有何不同？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;浅层次：在外部调用&lt;strong&gt;静态方法时，可以使用&amp;quot;类名.方法名&amp;quot;的方式&lt;/strong&gt;，&lt;strong&gt;也可以使用&amp;quot;对象名.方法名&amp;quot;的方式&lt;/strong&gt;。而实例方法只有后面这种方式。也就是说，&lt;strong&gt;调用静态方法可以无需创建对象。（静态方法的调用不依赖于对象）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JVM深层次：类的静态方法，静态变量是在&lt;strong&gt;类装载的时候装载的&lt;/strong&gt;，这时候还没有产生对象**。静态变量 存放在 Java 内存区域的方法区**&lt;/li&gt;
&lt;li&gt;static关键字使用场景
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;修饰成员变量和成员方法:&lt;/strong&gt; 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：&lt;code&gt;类名.静态变量名&lt;/code&gt; &lt;code&gt;类名.静态方法名()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态代码块:&lt;/strong&gt; 静态代码块定义在类中方法外, &lt;strong&gt;静态代码块在非静态代码块之前执行(静态代码块—&amp;gt;非静态代码块—&amp;gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态内部类（static修饰类的话只能修饰内部类）：&lt;/strong&gt; 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态导包(用来导入类中的静态资源，1.5之后的新特性):&lt;/strong&gt; 格式为：&lt;code&gt;import static&lt;/code&gt; 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;final关键字&#34;&gt;final关键字&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可作用在变量、方法、类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final作用在基本数据类型上：数值一旦初始化便不能随意更改；final作用在引用型变量：初始化之后不能再指向其他的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final作用在类上--&amp;gt;该类不能被继承，所有的成员方法默认为final&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final作用在方法上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把方法锁定，防止任何继承类修改它的含义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类中的private修饰的方法默认添加有final关键字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java中异常&#34;&gt;Java中异常&lt;/h2&gt;
&lt;h3 id=&#34;层次&#34;&gt;层次&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9ztjy5yx9j31a20py7nz.jpg&#34; alt=&#34;image-20191217165252832&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Error（错误）:是程序无法处理的错误&lt;/strong&gt;，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exception（异常）:是程序本身可以处理的异常&lt;/strong&gt;。Exception 类有一个重要的子类 &lt;strong&gt;RuntimeException&lt;/strong&gt;。RuntimeException 异常由Java虚拟机抛出。&lt;strong&gt;NullPointerException&lt;/strong&gt;（要访问的变量没有引用任何对象时，抛出该异常）、&lt;strong&gt;ArithmeticException&lt;/strong&gt;（算术运算异常，一个整数除以0时，抛出该异常）和 &lt;strong&gt;ArrayIndexOutOfBoundsException&lt;/strong&gt; （下标越界异常）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常和错误的区别：异常能被程序本身处理，错误是无法处理。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;trycatchfianlly&#34;&gt;try/catch/fianlly&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;try 块：&lt;/strong&gt; 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;catch 块：&lt;/strong&gt; 用于处理try捕获到的异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;finally 块：&lt;/strong&gt; 无论是否捕获或处理异常，finally块里的语句都会被执行。&lt;strong&gt;当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;finally语句块不会被执行的情况：
&lt;ol&gt;
&lt;li&gt;在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行&lt;/li&gt;
&lt;li&gt;在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行&lt;/li&gt;
&lt;li&gt;程序所在的线程死亡。&lt;/li&gt;
&lt;li&gt;关闭CPU。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;深拷贝浅拷贝&#34;&gt;深拷贝/浅拷贝&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：对基本数据类型进行值传递，引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针，不复制堆内存中的对象。&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9ztvk9ybgj30u00uyack.jpg&#34; alt=&#34;image-20191217170403217&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：对基本数据类型进行值传递，引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针和堆内存中的对象。（在堆中创建了新的对象）&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9ztxcys4pj30u00v5gnt.jpg&#34; alt=&#34;image-20191217170540653&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h2 id=&#34;反射&#34;&gt;反射&lt;/h2&gt;
&lt;p&gt;对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。---&amp;gt;&lt;strong&gt;反射就是把java类中的各种成分映射成一个个的Java对象&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9zuj06enpj31gm0lkn56.jpg&#34; alt=&#34;image-20191217172633390&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;反射优势：运行期类型的判断，动态加载类，提高代码灵活度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDBC 连接数据库时使用 &lt;code&gt;Class.forName()&lt;/code&gt;通过反射加载数据库的驱动程序&lt;/li&gt;
&lt;li&gt;Spring XML配置方法进行装在Bean&lt;/li&gt;
&lt;/ul&gt;
">Java基础篇（二）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/java-ji-chu-pian-yi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇主要涉及Java基础部分中一些较难以理解的部分，主要涉及到 内部类、包装类、String相关、异常等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;内部类&#34;&gt;内部类&lt;/h2&gt;
&lt;h3 id=&#34;非静态内部类&#34;&gt;(非)静态内部类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class TestInnerClass {	
public static void main(String[] args) {
		Face f = new Face();
		//非静态内部类，必须要先创建外部类，再创建内部类
    	Face.Nose n = f.new Nose();
    	n.breath();
		//静态内部类，不必先创建外部类再创建内部类
		Face.Ear e = new Face.Ear();    
    	e.listen();
	}	
	}

	class Face{
	// 外部类的属性
	String type = &amp;quot;瓜子脸&amp;quot;;
	static String color = &amp;quot;Red&amp;quot;;

	/**
   * 非静态内部类：必须要先创建外部类，再创建内部类，可以看成是一个对象的成员属性
 	*/
	class Nose{
    	//内部类不能定义成static的方法和属性
    	String type;
    	void breath(){
        	System.out.println(Face.this.type);  //内部类可以调用外部类的内容
       	 System.out.println(&amp;quot;呼吸&amp;quot;);
    	}
	}

/**
 * 静态内部类：当一个静态内部类存在，并不一定存在对应的外部类对象
 */
static class Ear{
    //静态内部类的实例方法不能直接访问外部类的实例方法，因为外部类不一定存在
    void listen(){
        System.out.println(color); //可访问内部类的静态属性
        System.out.println(&amp;quot;听&amp;quot;);
    }
}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;瓜子脸
呼吸
Red
听
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看出：&lt;br&gt;
内部类既可以访问自身的数据域，也可以访问他的外围类对象的数据域(如：&lt;strong&gt;Face.this.type&lt;/strong&gt;)&lt;br&gt;
编写内部类构造器这一方面，可以使用语法&lt;br&gt;
&lt;strong&gt;outerObject.new InnerClass(Construction parm);&lt;/strong&gt; 例如 &lt;strong&gt;Face.Nose n = f.new Nose();&lt;/strong&gt;&lt;br&gt;
特别注意:内部类不能有static方法&lt;br&gt;
局部类不能用public或private访问说明符进行，它的作用域被限制在声明这个局部类的块中--&amp;gt;优势:对外部世界可以完全隐藏起来&lt;/p&gt;
&lt;h3 id=&#34;匿名内部类&#34;&gt;匿名内部类&lt;/h3&gt;
&lt;p&gt;将局部内部类进一步深入，假如只创建这个类的一个对象，就不必命名了，这种类被称为“匿名内部类”&lt;br&gt;
详细用法--&amp;gt;&lt;a href=&#34;https://blog.csdn.net/hellocsz/article/details/81974251&#34;&gt;Click&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;包装类&#34;&gt;包装类&lt;/h2&gt;
&lt;p&gt;java中的数据类型int，double等不是对象，无法通过向上转型获取到Object提供的方法，而像String却可以，只因为String是一个对象而不是一个类型。基本数据类型由于这样的特性，导致无法参与转型，泛型，反射等过程。为了弥补这个缺陷，java提供了包装类。&lt;/p&gt;
&lt;p&gt;具体内容Click-&amp;gt;&lt;a href=&#34;https://blog.csdn.net/weixin_40739833/article/details/80093527&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;常用类&#34;&gt;常用类&lt;/h2&gt;
&lt;h3 id=&#34;date类&#34;&gt;Date()类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class TestDate {
  	public static void main(String[] args) {
      	Date d = new Date(2000);    
      	System.out.println(d);//Thu Jan 01 08:00:02 CST 1970
      	System.out.println(d.getTime());//2000

      	Date d2 = new Date();
      	System.out.println(d2.getTime());//1569572482084
      	System.out.println(d2.after(d));//true
  	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;calendar类&#34;&gt;Calendar类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class TestCalendar {
	public static void main(String[] args) {

		//获得日期相关元素
		Calendar calendar = new GregorianCalendar(2999,10,9,22,10,50);
		int year = calendar.get(Calendar.YEAR);
		int month = calendar.get(Calendar.MONTH);  //获得月份
		int weekday = calendar.get(Calendar.DAY_OF_WEEK); //星期几

		//System.out.println(year);
		//System.out.println(month);  //0-11表示对应的月份，0是1月...
		//System.out.println(weekday); //1-7 1-&amp;gt;星期天

		//设置日期相关元素
		Calendar calendar2 = new GregorianCalendar();
		//System.out.println(calendar2);  //不传参数，默认打印出今天的日期
		calendar2.set(Calendar.YEAR,2020);
		//System.out.println(calendar2);
		//日期的计算
		Calendar calendar3 = new GregorianCalendar();
		calendar3.add(Calendar.YEAR,-100);//将该时间向前100年，第一个参数控制加减的是年/月/日，第二参数控制加减的大小
		//System.out.println(calendar3);

		//日期对象和时间对象的转换
		Date date = calendar3.getTime();
		Calendar calendar4 = new GregorianCalendar();
		calendar4.setTime(new Date());
		printCalendar(calendar4);
	}

	//打印日期的方法进行封装
	private static void printCalendar(Calendar calendar){
		int year = calendar.get(Calendar.YEAR);
		int month = calendar.get(Calendar.MONTH) + 1;
		int date = calendar.get(Calendar.DAY_OF_MONTH);
		int dayWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1;
		String dayWeek2 = dayWeek == 0 ? &amp;quot;日&amp;quot; :dayWeek + &amp;quot;&amp;quot;;  //对星期进行处理
		int hour = calendar.get(Calendar.HOUR);
		int minute = calendar.get(Calendar.MINUTE);
		int second = calendar.get(Calendar.SECOND);

		System.out.println(year + &amp;quot;年&amp;quot; + month + &amp;quot;月&amp;quot; + date + &amp;quot;日&amp;quot; + hour + &amp;quot;时&amp;quot; + minute + &amp;quot;分&amp;quot; + second + &amp;quot;秒&amp;quot;
							+ &amp;quot;  周&amp;quot; + dayWeek2);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dateformat类&#34;&gt;DateFormat类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
* @Author: Rick
* @Date: 2019/1/28 18:38
* @Description: 测试时间对象和字符串之间的互相转换
*                DateFormat抽象类的SimpleDateFormat实现类的使用
*/
public class TestDateFormat {

	public static void main(String[] args) throws ParseException {

		//把时间对象按照“格式字符串指定的格式”转成相应的字符串
		DateFormat df = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);  // SimpleDateFormat()是DateFormat()的子类
		String str = df.format(new Date(4000000));
		System.out.println(str);  //   打印已经转化成了的字符串 1970-01-01 09:06:40

		//把字符串按照“格式字符串指定的格式”转成相应的时间对象
		DateFormat df2 = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日hh时mm分ss秒&amp;quot;);
		Date date = df2.parse(&amp;quot;2019年01月28日18时54分40秒&amp;quot;);
		System.out.println(date);  //打印字符串转换成的日期  Mon Jan 28 18:54:40 CST 2019

		//测试其他的格式字符。比如:利用D，获得本时间对象是所处年份的第几天
		DateFormat df3 = new SimpleDateFormat(&amp;quot;D&amp;quot;);
		String str3 = df3.format(new Date());
		System.out.println(str3);  //29
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;math类&#34;&gt;Math类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class TestMath {
	public static void main(String[] args) {
		//取整相关操作
		System.out.println(Math.ceil(3.2));   //4.0
		System.out.println(Math.floor(3.2));  //3.0
		System.out.println(Math.round(3.2));  //3
		System.out.println(Math.round(3.8));  //4

		//绝对值、开方、幂的操作
		System.out.println(Math.abs(-45));  //45
		System.out.println(Math.sqrt(64));  //8.0
		System.out.println(Math.pow(5,2));  //25.0
		System.out.println(Math.pow(2,5));  //32.0

		//常量
		System.out.println(Math.PI);  //3.141592653589793
		System.out.println(Math.E);   //2.718281828459045

		//随机数
		System.out.println(Math.random()); // [0,1)之间的随机数
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;random类&#34;&gt;Random类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class TestRandom {
	public static void main(String[] args) {
		Random rand = new Random();
		System.out.println(rand.nextDouble());  //随机生成[0,1)之间的double类型的数据
		System.out.println(rand.nextInt());     //随机生成int类型允许范围之内的整型数据
		System.out.println(rand.nextFloat());   //随机生成[0,1)之间的float类型的数据
		System.out.println(rand.nextBoolean()); //随机生成false或true
		System.out.println(rand.nextInt(10));  //随机生成[0,10)之间的int类型的数据
		System.out.println(20 + rand.nextInt(10));  //随机生成[20,30)之间的int类型的数据
		System.out.println(20 + (int)(rand.nextDouble() * 10));  //随机生成[20,30)之间的int类型的数据,较为复杂
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h2 id=&#34;string-stringbuffer-stringbuilder&#34;&gt;String、StringBuffer、StringBuilder&lt;/h2&gt;
&lt;h3 id=&#34;string常见问题&#34;&gt;String常见问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/VBFDIHhPg0MJ-L9DpzbiWw&#34;&gt;创建几个对象和intern()方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/dr6nCAd0NRdU1CdYYB7cNA&#34;&gt;String可能导致内存泄漏&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String长度为什么不可变?&lt;/p&gt;
&lt;p&gt;简单的来说：String类中使用final关键字字符数组保存字符串 &lt;strong&gt;private final char value[]&lt;/strong&gt;，所以String对象是不可以变的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stringbuffer和stringbuilder&#34;&gt;StringBuffer和StringBuilder&lt;/h3&gt;
&lt;p&gt;StringBuffer和Stringbuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串 &lt;strong&gt;char [] value&lt;/strong&gt;但是没有用final关键字修饰，所以这两种对象都是可变的&lt;/p&gt;
&lt;h3 id=&#34;三者之间的比较&#34;&gt;三者之间的比较&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;br&gt;
&lt;strong&gt;AbstractStringBuilder&lt;/strong&gt;是StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。&lt;br&gt;
StringBuffer 对方法&lt;strong&gt;加了同步锁&lt;/strong&gt;或者对调用的方法加了同步锁，所以是&lt;strong&gt;线程安全&lt;/strong&gt;的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次对 String 类型&lt;strong&gt;进行改变&lt;/strong&gt;的时候，都会生成一个&lt;strong&gt;新的 String 对象&lt;/strong&gt;，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。&lt;strong&gt;相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;三者使用的总结&#34;&gt;三者使用的总结&lt;/h3&gt;
&lt;p&gt;操作少量的数据 = &lt;kbd&gt;String&lt;/kbd&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;单线程&lt;/strong&gt;&lt;/em&gt; 操作字符串缓冲区下操作大量数据 = &lt;kbd&gt;StringBuilder&lt;/kbd&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;多线程&lt;/strong&gt;&lt;/em&gt; 操作字符串缓冲区下操作大量数据 = &lt;kbd&gt;StringBuffer&lt;/kdb&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;java中的传参机制&#34;&gt;Java中的传参机制&lt;/h2&gt;
&lt;p&gt;首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。&lt;strong&gt;按值调用(call by value)表示方法接收的是调用者提供的值&lt;/strong&gt;，而按&lt;strong&gt;引用调用（call by reference)表示方法接收的是调用者提供的变量地址&lt;/strong&gt;。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java程序设计语言总是采用按值调用&lt;/strong&gt;。也就是说，方法得到的是&lt;font color = #00BFFF&gt;所有参数值的一个拷贝&lt;/font&gt;，也就是说，方法不能修改传递给它的任何参数变量的内容。&lt;/p&gt;
&lt;p&gt;参考文章(一 为什么 Java 中只有值传递？) ---&amp;gt;  &lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%882018-8-7%EF%BC%89.md&#34;&gt;Click&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;error-exception-runtimeexception&#34;&gt;Error、Exception、RuntimeException&lt;/h2&gt;
&lt;h3 id=&#34;三者联系&#34;&gt;三者联系&lt;/h3&gt;
&lt;p&gt;首先搞清楚他们三者之间的关系，&lt;strong&gt;Error和Exception都继承自Throwable，而RuntimeException继承Exception。在Java中只有Throwable类型的实例才可被抛出或捕获&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Error类层次结构描述了Java运行时系统内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。&lt;/p&gt;
&lt;p&gt;在设计Java程序时，需要关注Exception的层次结构。这个层次结构又分解为两个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。&lt;strong&gt;程序错误导致的异常属于RuntimeException；而程序本身没有问题，但像I/O错误这类问题导致的异常属于其他异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中常见的RuntimeException有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NullPointerException：见的最多了，其实很简单，一般都是在null对象上调用方法了&lt;/li&gt;
&lt;li&gt;NumberFormatException：继承IllegalArgumentException，字符串转换为数字时出现。比如int i= Integer.parseInt(&amp;quot;ab3&amp;quot;);&lt;/li&gt;
&lt;li&gt;ArrayIndexOutOfBoundsException:数组越界。比如 int[] a=new int[3]; int b=a[3];&lt;/li&gt;
&lt;li&gt;StringIndexOutOfBoundsException：字符串越界。比如 String s=&amp;quot;hello&amp;quot;; char c=s.chatAt(6);&lt;/li&gt;
&lt;li&gt;ClassCastException:类型转换错误。比如 Object obj=new Object(); String s=(String)obj;&lt;/li&gt;
&lt;li&gt;ArithmeticException：算术错误，典型的就是0作为除数的时候。&lt;/li&gt;
&lt;li&gt;IllegalArgumentException：非法参数，在把字符串转换成数字的时候经常出现的一个异常，我们可以在自己的程序中好好利用这个异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Error类或RuntimeException类的所有异常称为&lt;font color = #F08080&gt;非受查异常&lt;/font&gt;，所有其他的异常称为&lt;font color = #F08080&gt;受查异常&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何声明异常&#34;&gt;如何声明异常&lt;/h3&gt;
&lt;p&gt;如果遇到了无法处理的情况，那么Java方法可以抛出异常。&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public FileInputStream(String name) throws FileNotFoundException
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException异常。如果发生了这种糟糕的情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException类对象。如果这个方法真的抛出了这样一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理FileNotFoundException对象。&lt;/p&gt;
&lt;p&gt;什么时候使用throws子句声明异常？&lt;strong&gt;通常有以下几种情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用一个受查异常的方法，例如FileInputStream构造器&lt;/li&gt;
&lt;li&gt;程序运行过程中发生错误&lt;/li&gt;
&lt;li&gt;程序出现错误&lt;/li&gt;
&lt;li&gt;Java虚拟机和运行时库出现内部错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color = red&gt;警告&lt;/font&gt;  如果在子类中覆盖了一个超类的方法，子类方法中声明的受查异常不能比超类方法中声明的异常更加通用(也就是说：子类方法中可以抛出更特定的异常，或者根本不抛出任何异常)&lt;/p&gt;
&lt;h3 id=&#34;如何抛出异常&#34;&gt;如何抛出异常&lt;/h3&gt;
&lt;p&gt;首先看一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	String readData(Scanner in) throws EOFException
	{
		...
		while(...)
		{
			if(!in.hasNext())
			{
				if(n &amp;lt; len)
					throw new EOFException();
			}
			...
		}
		return s;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此我们可以看到，对于一个已经存在的异常类，将其抛出很容易&lt;br&gt;
1.找到一个合适的异常类&lt;br&gt;
2.创建这个类的一个对象&lt;br&gt;
3.将对象抛出&lt;/p&gt;
&lt;h3 id=&#34;throw和throws关键字对比&#34;&gt;throw和throws关键字对比&lt;/h3&gt;
&lt;p&gt;1、throw用在方法体内，上面代码显示了，是直接在main方法体内，throws用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。&lt;br&gt;
2、&lt;em&gt;&lt;strong&gt;throw是具体向外抛异常的，抛出的是一个异常实例&lt;/strong&gt;&lt;/em&gt;，throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常&lt;br&gt;
3、&lt;em&gt;&lt;strong&gt;throw如果执行了，那么一定是抛出了某种异常了，throws表示可能出现，但不一定抛出了异常。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
4、同时出现的时候，throws出现在函数头、throw出现在函数体，两种不会由函数去处理，真正的处理由函数的上层调用处理&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;自定义异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2种自定义异常的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;/**
 * @Author: Rick
 * @Date: 2019/1/30 17:30
 * @Description: 自定义异常方式
 */
public class Test02 {
    public static void main(String[] args) {
        Person p = new Person();
        p.setAge(-10);
    }
}

class Person{
    private int age;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if(age &amp;lt; 0){
            try {
                throw new IllegalException(&amp;quot;年龄不能为负&amp;quot;);
            } catch (IllegalException e) {
                e.printStackTrace();
            }
        }
        this.age = age;
    }
}


//自己定义异常
// 方式1继承RuntimeException,可以不用在代码中try/catch进行异常处理,遇到异常,程序中断
class IllegalException extends RuntimeException{
    public IllegalException(){

    }

    public IllegalException(String msg){
        super(msg);
    }
}

//方式2继承Exception,必须在代码中对异常进行try/catch处理,这样才能通过编译
class IllegalException extends Exception {
    public IllegalException() {

    }

    public IllegalException(String msg) {
        super(msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rick_03_Exception.IllegalException: 年龄不能为负
	at Rick_03_Exception.Person.setAge(Test02.java:25)
	at Rick_03_Exception.Test02.main(Test02.java:11)

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NoClassDefFoundError和ClassNotFoundException有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;NoClassDefFoundError&lt;/kbd&gt;是当Java虚拟机或ClassLoader实例试图加载某个类，但无法找到该类的定义时抛出此异常&lt;br&gt;
&lt;kbd&gt;ClassNotFoundException&lt;/kbd&gt;是当应用程序试图调用Class.forName(String)通过字符串名加载类，而找不到该类定义时抛出的异常。&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;equals和的区别&#34;&gt;equals()和==的区别&lt;/h2&gt;
&lt;p&gt;&lt;font color = red&gt;== &lt;/font&gt;: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(&lt;strong&gt;基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;font color = red&gt;equals() &lt;/font&gt;: equals用来比较的是两个对象的内容是否相等，由于&lt;strong&gt;所有的类都是继承自java.lang.Object类的&lt;/strong&gt;，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。请看Object类中equals方法的源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public boolean equals(Object obj) {
    return (this == obj);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Test01 {
    public static void main(String[] args) {
    Person p1 = new Person(&amp;quot;Rick&amp;quot;,1001);
    Person p2 = new Person(&amp;quot;Rick&amp;quot;, 1001);
    System.out.println(p1.equals(p2)); 		//false
    }
}

class Person{
    String name;
    int ID;

    public Person() {
    }

    public Person(String name, int ID) {
        this.name = name;
        this.ID = ID;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里由于没有重写继承java.lang.Object类中的equals()方法，我们比较的是这两个对象的地址(==方法)因此出现的是false&lt;/p&gt;
&lt;p&gt;我们再&lt;strong&gt;重写equals()方法&lt;/strong&gt;看下测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Test02 {
    public static void main(String[] args) {
        Student stu1 = new Student(&amp;quot;Rick&amp;quot;,20);
        Student stu2 = new Student(&amp;quot;Rick&amp;quot;,20);
        System.out.println(stu1.equals(stu2));      //true
        System.out.println(stu1 == stu2);       //false
    }
}

class Student{
    String name;
    int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /**
     * 重写equals()方法
     * @param obj
     * @return
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (this == obj)
            return true;
        if (this.getClass() != obj.getClass())
            return false;

        Student stu = (Student)obj;
        return (name.equals(stu.name) &amp;amp;&amp;amp; age == stu.age);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上我们再String类型中使用的equals()方法，已经是被重写过了--&amp;gt;&lt;a href=&#34;https://www.cnblogs.com/Eason-S/p/5524837.html&#34;&gt;参考博文&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class test1 {
    public static void main(String[] args) {
        String a = new String(&amp;quot;ab&amp;quot;); // a 为一个引用
        String b = new String(&amp;quot;ab&amp;quot;); // b为另一个引用,对象的内容一样
        String aa = &amp;quot;ab&amp;quot;; // 放在常量池中
        String bb = &amp;quot;ab&amp;quot;; // 从常量池中查找
        if (aa == bb) // true
            System.out.println(&amp;quot;aa==bb&amp;quot;);
        if (a == b) // false，非同一对象
            System.out.println(&amp;quot;a==b&amp;quot;);
        if (a.equals(b)) // true
            System.out.println(&amp;quot;aEQb&amp;quot;);
        if (42 == 42.0) { // true
            System.out.println(&amp;quot;true&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里我们特别注意创建字符串String时&lt;/p&gt;
&lt;p&gt;String s=&amp;quot;abce&amp;quot;是一种非常特殊的形式,&lt;strong&gt;new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径&lt;/strong&gt;。以String s=&amp;quot;abce&amp;quot;形式赋值在java中叫&lt;strong&gt;直接量&lt;/strong&gt;它是在常量池中而不是像new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为&amp;quot;abcd&amp;quot;的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象,如果没有,则在常量池中新创建一个&amp;quot;abcd&amp;quot;,下一次如果有String s1 = &amp;quot;abcd&amp;quot;;又会将s1指向&amp;quot;abcd&amp;quot;这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.&lt;br&gt;
　　&lt;strong&gt;而String s = new String(&amp;quot;abcd&amp;quot;);和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;hashcode和equals区别&#34;&gt;HashCode()和equals()区别&lt;/h2&gt;
&lt;p&gt;推荐阅读：&lt;a href=&#34;https://www.cnblogs.com/skywang12345/p/3324958.html&#34;&gt;Java hashCode() 和 equals()的若干问题解答&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数&lt;/strong&gt; 。这个哈希码的作用是确定该对象在哈希表中的索引位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数&lt;/strong&gt;。&lt;br&gt;
虽然，每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。&lt;br&gt;
上面的散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashCode()和equals()的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们以 &lt;em&gt;&lt;strong&gt;类的用途&lt;/strong&gt;&lt;/em&gt; 来将“hashCode() 和 equals()的关系”分2种情况来说明。&lt;/p&gt;
&lt;h3 id=&#34;不会创建类对应的散列表&#34;&gt;不会创建“类对应的散列表”&lt;/h3&gt;
&lt;p&gt;这里所说的“不会创建类对应的散列表”是说：&lt;font color = #F08080&gt;我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。&lt;/font&gt;例如，不会创建该类的HashSet集合。在这种情况下，&lt;strong&gt;该类的“hashCode() 和 equals() ”没有半毛钱关系的！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;import java.util.*;
import java.lang.Comparable;

/**
* @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。
*
* @author skywang
* @emai kuiwu-wang@163.com
*/
public class NormalHashCodeTest{
	
	public static void main(String[] args) {
	// 新建2个相同内容的Person对象，
	// 再用equals比较它们是否相等
	Person p1 = new Person(&amp;quot;eee&amp;quot;, 100);
	Person p2 = new Person(&amp;quot;eee&amp;quot;, 100);
	Person p3 = new Person(&amp;quot;aaa&amp;quot;, 200);
	System.out.printf(&amp;quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&amp;quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());
	System.out.printf(&amp;quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&amp;quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());
	
	}

	/**
	* @desc Person类。
	*/
	private static class Person {
		int age;
		String name;

		public Person(String name, int age) {
			this.name = name;
			this.age = age;
		}

		public String toString() {
			return name + &amp;quot; - &amp;quot; +age;
		}

		/** 
		* @desc 覆盖equals方法 
		*/  
		public boolean equals(Object obj){  
			if(obj == null){  
				return false;  
			}  
			
			//如果是同一个对象返回true，反之返回false  
			if(this == obj){  
				return true;  
			}  
			
			//判断是否类型相同  
			if(this.getClass() != obj.getClass()){  
				return false;  
			}  
			
			Person person = (Person)obj;  
			return name.equals(person.name) &amp;amp;&amp;amp; age==person.age;  
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1.equals(p2) : true; p1(1169863946) p2(1901116749)
p1.equals(p3) : false; p1(1169863946) p3(2131949076)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果也可以看出：&lt;strong&gt;p1和p2相等的情况下，hashCode()也不一定相等。&lt;/strong&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;会创建类对应的散列表&#34;&gt;会创建“类对应的散列表”&lt;/h3&gt;
&lt;p&gt;这里所说的“会创建类对应的散列表”是说：&lt;strong&gt;我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：&lt;br&gt;
1)、如果两个对象相等，那么它们的hashCode()值一定相同。&lt;br&gt;
这里的相等是指，通过equals()比较两个对象时返回true。&lt;br&gt;
2)、如果两个对象hashCode()相等，它们并不一定相等。&lt;br&gt;
因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突&lt;br&gt;
我们来看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;import java.util.*;
import java.lang.Comparable;

/**
* @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。
*
* @author skywang
* @emai kuiwu-wang@163.com
*/
public class ConflictHashCodeTest1{

	public static void main(String[] args) {
		// 新建Person对象，
		Person p1 = new Person(&amp;quot;eee&amp;quot;, 100);
		Person p2 = new Person(&amp;quot;eee&amp;quot;, 100);
	Person p3 = new Person(&amp;quot;aaa&amp;quot;, 200);

		// 新建HashSet对象 
		HashSet set = new HashSet();
		set.add(p1);
		set.add(p2);
	set.add(p3);

		// 比较p1 和 p2， 并打印它们的hashCode()
		System.out.printf(&amp;quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&amp;quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());
		// 打印set
		System.out.printf(&amp;quot;set:%s\n&amp;quot;, set);
}

	/**
	* @desc Person类。
	*/
	private static class Person {
		int age;
	String name;

		public Person(String name, int age) {
			this.name = name;
			this.age = age;
	}

		public String toString() {
			return &amp;quot;(&amp;quot;+name + &amp;quot;, &amp;quot; +age+&amp;quot;)&amp;quot;;
	}

		/** 
		* @desc 覆盖equals方法 
		*/  
		@Override
		public boolean equals(Object obj){  
			if(obj == null){  
				return false;  
			}  
			
			//如果是同一个对象返回true，反之返回false  
			if(this == obj){  
				return true;  
			}  
			
			//判断是否类型相同  
			if(this.getClass() != obj.getClass()){  
				return false;  
			}  
			
			Person person = (Person)obj;  
			return name.equals(person.name) &amp;amp;&amp;amp; age==person.age;  
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1.equals(p2) : true; p1(1169863946) p2(1690552137)
set:[(eee, 100), (eee, 100), (aaa, 200)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果分析：&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
 我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？
&lt;br&gt;
 &lt;font color = red&gt;这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。&lt;/font&gt;
&lt;br&gt;
&lt;br&gt;
下面我们同时覆盖equals() 和 hashCode()方法   
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	import java.util.*;
import java.lang.Comparable;

/**
* @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。
*
* @author skywang
* @emai kuiwu-wang@163.com
*/
public class ConflictHashCodeTest2{

	public static void main(String[] args) {
		// 新建Person对象，
		Person p1 = new Person(&amp;quot;eee&amp;quot;, 100);
		Person p2 = new Person(&amp;quot;eee&amp;quot;, 100);
		Person p3 = new Person(&amp;quot;aaa&amp;quot;, 200);
	Person p4 = new Person(&amp;quot;EEE&amp;quot;, 100);

		// 新建HashSet对象 
		HashSet set = new HashSet();
		set.add(p1);
		set.add(p2);
	set.add(p3);

		// 比较p1 和 p2， 并打印它们的hashCode()
		System.out.printf(&amp;quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&amp;quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());
		// 比较p1 和 p4， 并打印它们的hashCode()
		System.out.printf(&amp;quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&amp;quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());
		// 打印set
		System.out.printf(&amp;quot;set:%s\n&amp;quot;, set);
}

	/**
	* @desc Person类。
	*/
	private static class Person {
		int age;
	String name;

		public Person(String name, int age) {
			this.name = name;
			this.age = age;
	}

		public String toString() {
			return name + &amp;quot; - &amp;quot; +age;
	}

		/** 
		* @desc重写hashCode 
		*/  
		@Override
		public int hashCode(){  
			int nameHash =  name.toUpperCase().hashCode();
			return nameHash ^ age;
	}

		/** 
		* @desc 覆盖equals方法 
		*/  
		@Override
		public boolean equals(Object obj){  
			if(obj == null){  
				return false;  
			}  
			
			//如果是同一个对象返回true，反之返回false  
			if(this == obj){  
				return true;  
			}  
			
			//判断是否类型相同  
			if(this.getClass() != obj.getClass()){  
				return false;  
			}  
			
			Person person = (Person)obj;  
			return name.equals(person.name) &amp;amp;&amp;amp; age==person.age;  
		} 
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1.equals(p2) : true; p1(68545) p2(68545)
p1.equals(p4) : false; p1(68545) p4(68545)
set:[aaa - 200, eee - 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这下，equals()生效了，HashSet中没有重复元素。&lt;br&gt;
比较p1和p2，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。&lt;br&gt;
比较p1和p4，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。&lt;/p&gt;
">Java基础篇（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/cmian-xiang-dui-xiang-ji-chu-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;C++是一门面向对象的语言，本篇就C++面向对象中类与对象的特性做相关整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;类与对象&#34;&gt;类与对象&lt;/h2&gt;
&lt;h3 id=&#34;类的对象和概念&#34;&gt;类的对象和概念&lt;/h3&gt;
&lt;p&gt;变量 + 函数 进行捆绑封装形成一个类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Employee
{
private:
    char sname[20];

public:
    int salary;

    void setName(const char *name);
    void getName(char *name);
    void avrageSalary(Employee e1, Employee e2);
};	// 必须要有分号

// 成员变量的函数可在类中进行实现，同样也可在外部实现
// 外部实现方式 类名 :: 方法
void Employee ::setName(const char * name)
{
    strcpy(sname, name);
}

void Employee ::getName(char *name)
{
    strcpy(name, sname);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Employee emp;
// 对象名.成员名
emp.setName(&amp;quot;Rick&amp;quot;);
emp.salary = 10000;
// 指针-&amp;gt;成员名
Employee *p = &amp;amp;emp;
p-&amp;gt;salary = 5000;
// 引用名.成员名
CEmployee &amp;amp;r = emp;
r.salary = 8000;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问权限&#34;&gt;访问权限&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;private&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;私有成员，只能在成员函数中访问&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;public&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;公有成员，可以在任何地方访问&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;protect&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;保护成员，暂不介绍&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;默认函数&#34;&gt;默认函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Line{
   public:
      Line();  		// 这是默认空构造函数
  		Line(double length);	// 带参构造函数
   private:
      double length;
}; 
int main( ){
   Line line1;
	 Line line2(5.0)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;析构函数&lt;/p&gt;
&lt;p&gt;类的&lt;strong&gt;析构函数&lt;/strong&gt;是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。&lt;/p&gt;
&lt;p&gt;析构函数的名称与类的名称是完全相同的，只是在&lt;strong&gt;前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数&lt;/strong&gt;。析构函数有&lt;strong&gt;助于在跳出程序（比如关闭文件、释放内存等）前释放资源&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();   // 这是构造函数声明
      ~Line();  // 这是析构函数声明
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout &amp;lt;&amp;lt; &amp;quot;Object is being created&amp;quot; &amp;lt;&amp;lt; endl;
}
Line::~Line(void)
{
    cout &amp;lt;&amp;lt; &amp;quot;Object is being deleted&amp;quot; &amp;lt;&amp;lt; endl;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line;
   // 设置长度
   line.setLength(6.0); 
   cout &amp;lt;&amp;lt; &amp;quot;Length of line : &amp;quot; &amp;lt;&amp;lt; line.getLength() &amp;lt;&amp;lt;endl;
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Object is being created
Length of line : 6
Object is being deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;this指针&#34;&gt;this指针&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;并非对象的成员，是常量指针&lt;/p&gt;
&lt;p&gt;每个对象可以使用this指针访问自己的地址&lt;/p&gt;
&lt;p&gt;非static成员函数调用时，this指针为隐式参数&lt;/p&gt;
&lt;p&gt;用途：防止自赋值、返回以连续调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Rick
{
private:
    int age;
public:
    Rick();
    Rick(int age);
  	Rick* ReturnAddress() {
      return this;
    }
};

Rick::Rick(int age)
{
    this-&amp;gt;age = age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;函数模板&#34;&gt;函数模板&lt;/h3&gt;
&lt;p&gt;例如实际问题中的需要：&lt;strong&gt;对于不同类型数据可以用的排序函数sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板中&lt;code&gt;class&lt;/code&gt;也可写成 &lt;code&gt;typename&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;class T&amp;gt;
return-type sort(...T...)

template &amp;lt;class T1, class T2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;class T&amp;gt;
void print(const T array[], int size){
    int i;
    for (i = 0; i &amp;lt; size; i++) {
        cout &amp;lt;&amp;lt; array[i];
    }
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;class T&amp;gt;
T Max(T a, T b) {
    cout &amp;lt;&amp;lt; &amp;quot;TemplateMax&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}

template &amp;lt;class T1, class T2&amp;gt;
T1 Max(T1 a, T2 b) {
    cout &amp;lt;&amp;lt; &amp;quot;TemplateMax2&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}

double Max(double a, double b) {
    cout &amp;lt;&amp;lt; &amp;quot;MyMax&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}

int main() {
    int i = 4, j = 5;
    Max(1.2, 3.4);      // MyMax
    Max(i, j);          // TemplateMax
    Max(1.2, 3);        // TemplateMax2
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在有多个函数和函数模板名字相同的情况下，编译器如下处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先找参数完全匹配的&lt;strong&gt;普通函数&lt;/strong&gt;（非由模板实例化而得的函数）&lt;/li&gt;
&lt;li&gt;再找参数完全匹配的&lt;strong&gt;模板函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;再找是参数经过自动类型转换后能够匹配的&lt;strong&gt;普通函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上面的都找不到，则报错&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类模板&#34;&gt;类模板&lt;/h3&gt;
&lt;p&gt;为了多快好省地定义出一批相似的类，可以&lt;strong&gt;定义类模板&lt;/strong&gt;，然后由类模板生成不同的类&lt;/p&gt;
&lt;p&gt;类模板：在&lt;strong&gt;定义类的时候给它一个/多个参数，这个/些参数表示不同的数据类型&lt;/strong&gt;。在&lt;strong&gt;调用类模板时，指定参数&lt;/strong&gt;，由编译系统根据参数提供的数据类型自动产生相应的模板类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;class T&amp;gt;  // 类模板首部，声明类模板参数
class Carray
{
    T *ptrElement;
    int size;
public:
    Carray(int length);
    ~Carray();
    int len();
    void setElement(T arg, int index);
    T getElement(int index);
};
int main(int argc, char const *argv[])
{
  	// 创建一个元素类型为int的Carray模板类，而声明该模板类的一个对象、以及一个指针
    Carray &amp;lt;int&amp;gt; arrayInt(50), *ptrArrayInt;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;函数模板作为类模板成员&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;class T&amp;gt;
class A {
    public:
        // 成员模板函数
        template &amp;lt;class T2&amp;gt;
        void Func(T2 t) {
            cout &amp;lt;&amp;lt; t;
        }  
};

int main() {
    A&amp;lt;int&amp;gt; a;
    a.Func(&#39;K&#39;);    // K
    a.Func(&amp;quot;hello&amp;quot;);    // hello
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类模板的“&amp;lt;类型参数表&amp;gt;”中&lt;strong&gt;可以出现非类型参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;class T, int size&amp;gt;
class Array {
    T array[size];
    public:
        void Print() {
            for (int i = 0; i &amp;lt; size; i++) {
                cout &amp;lt;&amp;lt; array[i] &amp;lt;&amp;lt; endl;
            }
        }
};

int main() {
    Array&amp;lt;double, 40&amp;gt; a1;
    Array&amp;lt;int, 50&amp;gt; a2;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;static&#34;&gt;static&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;static修饰成员变量就是静态成员变量，&lt;strong&gt;静态成员变量一共就一份，为所有对象共享&lt;/strong&gt;，静态成员不需要通过对象就能访问到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符不会计算静态成员变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MyClass {
    int n;
    static int n;
};
sizeof(MyClass)   = 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;static修饰成员函数就是静态成员函数，普通成员函数必须具体作用于某个对象，而&lt;strong&gt;静态成员函数并不具体作用于某个对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Rectangle {
    private:
        int w,h;
        static int nTotalArea;
        static int nTotalNumber;
    public:
        Rectangle(int w_, int h_);
        ~Rectangle();
        static void PrintTotal();
};
// 必须在定义类的文件中对静态成员变量进行一次说明或初始化，否则链接不能通过
int Rectangle::nTotalNumber = 0;
int Rectangle::nTotalArea = 0;

Rectangle::Rectangle(int w_, int h_) {
    w = w_;
    h = h_;
    nTotalNumber ++;
    nTotalArea += w * h;
}

Rectangle::~Rectangle() {
    nTotalNumber--;
    nTotalArea -= w * h;
}
/**
 * 在静态成员函数中，不能访问费静态成员变量，也不能调用非静态成员函数
 */
void Rectangle::PrintTotal() {
    cout &amp;lt;&amp;lt; nTotalNumber &amp;lt;&amp;lt; &amp;quot;,&amp;quot; &amp;lt;&amp;lt; nTotalArea &amp;lt;&amp;lt; endl;
}

int main(void){
    Rectangle r1(3,3), r2(2,2);
    Rectangle::PrintTotal();
    r1.PrintTotal();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;成员变量和封闭类&#34;&gt;成员变量和封闭类&lt;/h3&gt;
&lt;p&gt;有成员对象的类叫 封闭类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class CTyre {
    private:
        int radius;
        int width;
    public:
        // 构造器初始化列表
        CTyre(int r, int w) : radius(r), width(w) {}
};

class CEngine{

};

class CCar {
    private:
        int price;
        CTyre tyre;
        CEngine engine;
    public:
        CCar(int p, int tr, int tw);  
};

CCar::CCar(int p, int tr, int tw) : price(p), tyre(tr, tw) {}

int main(void) {
    CCar car(20000, 17, 225);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中如果&lt;code&gt;CCar&lt;/code&gt;不定义构造函数， &lt;code&gt;CCar car&lt;/code&gt; 会报错，因为编译器不明白 &lt;code&gt;car.tyre&lt;/code&gt;该如何初始化。&lt;code&gt;car.engine&lt;/code&gt;的初始化没问题，用默认构造函数即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象是如何初始化的。&lt;/p&gt;
&lt;p&gt;具体做法就是：通过封闭类的构造函数的初始化列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;常量对象-常量成员函数&#34;&gt;常量对象、常量成员函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量对象：如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加&lt;code&gt;const&lt;/code&gt;关键字&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Demo {
  private:
  	int value;
  public:
  	void setValue() {}
};
const Demo Obj;		// 常量对象
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量成员函数&lt;/strong&gt;：在函数说明后面加&lt;code&gt;const&lt;/code&gt;关键字。&lt;strong&gt;常量成员函数执行期间不应修改其所作用的对象&lt;/strong&gt;。因此，在&lt;strong&gt;常量成员函数中不能修改成员变量的值(静态成员变量除外)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Sample {
    public:
        int value;
        void GetValue() const;
        void func();
        Sample();
};

void Sample::GetValue() const {
    // value = 0      wrong!
    // func();      wrong!
}

int main(void) {
    const Sample s;
    s.value = 100;      // Error  常量对象不可修改
    s.func();           // Error  常量对象上面不能执行非常量成员函数
    s.GetValue();       // OK     常量对象上可以执行常量成员函数
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常引用&lt;/strong&gt;：引用前面加const关键字，称为常引用。&lt;strong&gt;不能通过其常引用，修改其引用的变量&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Sample {
  ...
}
// 当我们去传递引用参数的时候，不能避免o无意被修改，这时就需要常引用
void PrintObj(Sample &amp;amp;o) {
  ...
}
// 这样就能确保不会出现无意中更改o值得语句
void PrintObj(const Sample &amp;amp;o) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;友元&#34;&gt;友元&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;友元分为友元函数和友元类两种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。&lt;strong&gt;尽管友元函数的原型有在类的定义中出现过，但是&lt;/strong&gt;友元函数并不是成员函数&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Car;  //提前声明Car类
class Driver {
    public:
        void ModifyCar(Car* pCar);
};

class Car {
    private:
        int price;
    friend int MostExpensiveCar(Car cars[], int total); // 友元声明
    // 友元声明：可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元
  	friend void Driver::ModifyCar(Car* pCar);   
};

void Driver::ModifyCar(Car* pCar) {
    pCar-&amp;gt;price += 1000;
}

// 不是任何类的成员函数
int MostExpensiveCar (Car cars[], int total) {
    int tmpMax = -1;
    for (int i = 0; i &amp;lt; total; i++) {
        if (cars[i].price &amp;gt;tmpMax) {
            tmpMax = cars[i].price;
        }
    }
    return tmpMax;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;友元类：如果A是B的友元类，那么A的成员函数可以访问B的私有成员&lt;/strong&gt;。（&lt;strong&gt;友元类之间的关系不能传递，不能继承&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Car {
    private:
        int price;
    friend class Driver;		// 声明Driver为友元类
};

class Driver {
    public:
        Car myCar;
        void ModifyCar() {
            myCar.price += 1000;
        }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">C++面向对象基础篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/shu-jin-jie-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;上一篇介绍了树和二叉树的一些基本知识，存储结构，遍历，常见算法应用等，这一篇主要对树的另外一些高级数据结构进行梳理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;什么是二叉搜索树&#34;&gt;什么是二叉搜索树？&lt;/h3&gt;
&lt;p&gt;一颗二叉树，可以为空；如果不为空，满足以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非空&lt;strong&gt;左子树&lt;/strong&gt;的所有键值&lt;strong&gt;小于其根节点的键值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;非空&lt;strong&gt;右子树&lt;/strong&gt;的所有键值&lt;strong&gt;大于其根节点的键值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左、右子树都是二叉搜素树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉搜索树常见算法&#34;&gt;二叉搜索树常见算法&lt;/h3&gt;
&lt;h4 id=&#34;查找元素&#34;&gt;查找元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Position Find(ElementType X, BinTree BST)&lt;/code&gt;：从二叉搜索树BST中查找元素X，返回其结点所在地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* Find(int x, TreeNode* root) {
    if (root == NULL) {
        return NULL;		// 查找失败
    }
    if (root-&amp;gt;val &amp;gt; x) {
        return Find(x, root-&amp;gt;left);		// 左子树递归查找
    }
    if (root-&amp;gt;val &amp;lt; x) {
        return Find(x, root-&amp;gt;right);	// 右子树递归查找
    }else
    {
        return root;		// 查找到结点
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* Find(int x, TreeNode* root) {
    while (root != NULL) {
        if (root-&amp;gt;val &amp;gt; x) {
            root = root-&amp;gt;left;
        }else if (root-&amp;gt;val &amp;lt; x)
        {
            root = root-&amp;gt;right;
        }else
        {
            return root;
        }       
        return NULL;
    }   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查找的效率决定于树的高度&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;查找最值元素&#34;&gt;查找最值元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Position FindMin(BinTree BST)&lt;/code&gt;：从二叉搜索树BST中查找并返回最小元素所在节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* FindMin(TreeNode* root) {
    if (root == NULL) {
        return NULL;
    }
    if (root-&amp;gt;left == NULL) {
        return root;
    }else
    {
        return FindMin(root-&amp;gt;left);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Position FindMax(BinTree BST)&lt;/code&gt;：从二叉搜索树BST中查找并返回最大元素所在节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* FindMax(TreeNode* root) {
    if (root != NULL) {
        while (root-&amp;gt;right != NULL) {
            root = root-&amp;gt;right;
        }
    } 
    return root;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;插入元素&#34;&gt;插入元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BinTree Insert(ElementType X, BinTree BST)&lt;/code&gt;：插入元素X到二叉搜索树BST中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* insertIntoBST(TreeNode* root, int val) {
    // 若原树为空，生成并返回一个结点的二叉搜索树
  	if (root == NULL) {
      root = new TreeNode(val);
    }
  	// 开始查找要插入元素的位置
    if (root-&amp;gt;val &amp;gt; val) {
      root-&amp;gt;left = insertIntoBST(root-&amp;gt;left, val);		// 递归处理左子树
    }else if (root-&amp;gt;val &amp;lt; val)
    {
      root-&amp;gt;right = insertIntoBST(root-&amp;gt;right, val);	// 递归处理右子树
    }
    return root; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;删除元素&#34;&gt;删除元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BinTree Delete(ElementType X, BinTree BST)&lt;/code&gt;：从二叉搜索树BST中删除元素X&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要删除&lt;strong&gt;叶结点&lt;/strong&gt;：直接删除，并修改其父节点指针--置为&lt;code&gt;NULL&lt;/code&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcyhhxlq3bj30lw0ceq4b.jpg&#34; alt=&#34;image-20200318231109608&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要删除的结点&lt;strong&gt;只有一个孩子结点&lt;/strong&gt;：将其父节点的指针指向要删除节点的孩子结点&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcyhk2f5qkj30i20c4ta7.jpg&#34; alt=&#34;image-20200318231314737&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要删除的结点&lt;strong&gt;有左、右两颗子树&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;另一结点替代被删除结点&lt;/strong&gt;：&lt;strong&gt;右子树的最小元素或者左子树的最大元素&lt;/strong&gt;，这样就&lt;strong&gt;转换成了前两种情况&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcyhtajm8kj30gg0csq52.jpg&#34; alt=&#34;image-20200318232206833&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcyhubc8zrj30dg0cogmy.jpg&#34; alt=&#34;image-20200318232306027&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcyhtzurowj30cu0aumyx.jpg&#34; alt=&#34;image-20200318232247420&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcyhs7y6jxj30dg0cqta2.jpg&#34; alt=&#34;image-20200318232104915&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* deleteNode(TreeNode* root, int key) {
    TreeNode* temp = NULL;
    // 先查找到结点的位置
    if (root == NULL) {
      return root;
    }
    if (root-&amp;gt;val &amp;gt; key) {
      root-&amp;gt;left = deleteNode(root-&amp;gt;left, key);
    }else if (root-&amp;gt;val &amp;lt; key)
    {
      root-&amp;gt;right = deleteNode(root-&amp;gt;right, key);
    }else
    // 找到了要删除的结点，然后对三种情况进行判断
    {
        // 左右子树都有结点的情况
        if (root-&amp;gt;left != NULL &amp;amp;&amp;amp; root-&amp;gt;right != NULL) {
            // 在右子树上找一个最小的结点对要删除的结点进行替代
            temp = FindMin(root-&amp;gt;right);
            root-&amp;gt;val = temp-&amp;gt;val;
            // 转换成要删除的是叶子结点或者只有一个孩子结点的情况
            root-&amp;gt;right = deleteNode(root-&amp;gt;right, root-&amp;gt;val);
        }else
            // 针对要删除的是叶子结点或者是只有一个孩子结点的情况
        {
            if (root-&amp;gt;left == NULL) {
                root = root-&amp;gt;right;
            }else if (root-&amp;gt;right == NULL)
            {
                root = root-&amp;gt;left;
            }
        }
    }
    return root; 
}

TreeNode* FindMin(TreeNode* root) {
  if (root == NULL) {
    return NULL;
  }
  if (root-&amp;gt;left == NULL) {
    return root;
  }else
  {
    return FindMin(root-&amp;gt;left);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* deleteNode(TreeNode* root, int key) {
  if (!root) {
    return nullptr;
  }
  // 找到要删除的结点
  if (root-&amp;gt;val == key) {
    // 如果右子树没有结点，直接删掉该结点并返回左子树
    if (!root-&amp;gt;right) {
      TreeNode* left = root-&amp;gt;left;
      delete root;
      return left;
    }else
    {
      // 如果右子树有结点，找到右子树的最小结点
      // 进行交换，这样下次删除的就是叶子结点，比较容易
      TreeNode* right = root-&amp;gt;right;
      while (right-&amp;gt;left) {
        right = right-&amp;gt;left;
      }
      swap(root-&amp;gt;val, right-&amp;gt;val);
    }
  }
  root-&amp;gt;left = deleteNode(root-&amp;gt;left, key);
  root-&amp;gt;right = deleteNode(root-&amp;gt;right, key);
  return root;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;判断一棵树是否为二叉搜索树&#34;&gt;判断一棵树是否为二叉搜索树&lt;/h3&gt;
&lt;h4 id=&#34;递归&#34;&gt;递归&lt;/h4&gt;
&lt;p&gt;乍一看：这是一个平凡的问题，只需要遍历整棵树，检查结点值&lt;code&gt;node-&amp;gt;right-&amp;gt;val &amp;gt; node-&amp;gt;val&lt;/code&gt;和&lt;code&gt;node-&amp;gt;left-&amp;gt;val &amp;lt; node-&amp;gt;val&lt;/code&gt;对每个结点都成立&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd0gt8xjxlj30vw0fi0vg.jpg&#34; alt=&#34;image-20200320161835995&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;p&gt;问题是，这种方法并不总是正确。&lt;strong&gt;不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点&lt;/strong&gt;。例如:&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd0gudchi6j317e0fgdkj.jpg&#34; alt=&#34;image-20200320161938824&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;p&gt;这意味着我们需要&lt;strong&gt;在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool isValidBST(TreeNode* root) {
  // 为了测试通过LeetCode测试用例，上边界和下边界使用了long的边界值
  return helper(root, LONG_MAX, LONG_MIN);
}
bool helper(TreeNode* root, long upper, long lower) {
    if (!root) {
      	return true;
    }
    int val = root-&amp;gt;val;
    if (val &amp;gt;= upper) {
      	return false;
    }
    if (val &amp;lt;= lower) {
      	return false;
    }
    if (!helper(root-&amp;gt;left, val, lower)) {
      	return false;
    }
    if (!helper(root-&amp;gt;right, upper, val)) {
      	return false;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更为优雅的递归：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    private:
    TreeNode* prev = NULL;
public:
    bool isValidBST(TreeNode* root) {
        if(!root)   return true;
        return isValidBST(root-&amp;gt;left)  &amp;amp;&amp;amp; help(root) &amp;amp;&amp;amp; isValidBST(root-&amp;gt;right);
    }
    
    bool help(TreeNode* root){
        if(!prev){
            prev = root;
            return true;
        }
        if(prev-&amp;gt;val &amp;gt;= root-&amp;gt;val)   return false;
        prev = root;
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;中序遍历为升序&#34;&gt;中序遍历为升序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isValidBST(TreeNode* root) {
        TreeNode* node = root;
        vector&amp;lt;int&amp;gt; inorder;
        stack&amp;lt;TreeNode*&amp;gt; s;
        while (node || !s.empty()) {
            while (node) {
                s.push(node);
                node = node-&amp;gt;left;
            }
            if (!s.empty()) {
                node = s.top();
                inorder.push_back(node-&amp;gt;val);
                s.pop();
                node = node-&amp;gt;right;
            }
        }
        // 验证中序序列是否为升序
        for (int i = 1; i &amp;lt; inorder.size(); i++) {
            if (inorder[i] &amp;lt;= inorder[i - 1]) {
                return false;
            }
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;平衡二叉树avl树&#34;&gt;平衡二叉树(AVL树)&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;平衡二叉树概念&#34;&gt;平衡二叉树概念&lt;/h3&gt;
&lt;p&gt;搜索树结点不同插入次序，将导致&lt;strong&gt;不同的深度和平均查找长度ASL&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平衡因子（Balance Factor）：&lt;strong&gt;BF(T) = h&lt;sub&gt;L&lt;/sub&gt; - h&lt;sub&gt;R&lt;/sub&gt;&lt;/strong&gt;，其中h&lt;sub&gt;L&lt;/sub&gt; 、h&lt;sub&gt;R&lt;/sub&gt;分别表示T的左、右子树的高度。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;平衡二叉树（Balanced Binary Tree）（AVL树）空树，或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T)| ≤ 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczdyj85pqj30qe080778.jpg&#34; alt=&#34;image-20200319175418894&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;注意：是对任意一个结点而言，不仅仅是根节点&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;平衡二叉树的高度&#34;&gt;平衡二叉树的高度&lt;/h3&gt;
&lt;p&gt;完全二叉树 高度log&lt;sub&gt;2&lt;/sub&gt;n，设n&lt;sub&gt;h&lt;/sub&gt;高度为h的平衡二叉树的最少结点数。结点数最少时：&lt;/p&gt;
&lt;p&gt;有 &lt;strong&gt;n&lt;sub&gt;h&lt;/sub&gt; = n&lt;sub&gt;h-1&lt;/sub&gt; + n&lt;sub&gt;h-2&lt;/sub&gt; + 1&lt;/strong&gt;  ==&amp;gt;	斐波那契数列加1&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gcze6gngzxj30pe072gmw.jpg&#34; alt=&#34;image-20200319180157073&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;平衡二叉树的调整&#34;&gt;平衡二叉树的调整&lt;/h3&gt;
&lt;p&gt;在平衡二叉树进行插入结点后，可能会导致该二叉树不再是平衡二叉树，需要对结点位置进行调整：调整的原则一定要注意：&lt;strong&gt;调整完一定还要是二叉搜索树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;####RR旋转&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczf67zqhnj30o605q40i.jpg&#34; alt=&#34;image-20200319183618370&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;不平衡的**“发现者”&lt;strong&gt;是Mar，&lt;/strong&gt;“麻烦结点”**Nov在发现右子树的右边，因而叫RR插入，需要RR旋转（右单旋）&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczf7l9frkj30qc0800vu.jpg&#34; alt=&#34;image-20200319183737281&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;注意：插入的结点&lt;strong&gt;不一定就是最右边的结点才算RR旋转&lt;/strong&gt;，一定要明确的是：插入结点后，&lt;strong&gt;被破坏平衡的那个结点的右子树的右边（可以是左叶子结点也可以是右叶子结点，只要是在右子树的右边即可）就可&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczfdkl7yfj30m20aidj6.jpg&#34; alt=&#34;image-20200319184322231&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczfexawy7j30n40fsdlh.jpg&#34; alt=&#34;image-20200319184440426&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;ll旋转&#34;&gt;LL旋转&lt;/h4&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczg6wjifhj30r009atci.jpg&#34; alt=&#34;image-20200319191132018&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;Mar的平衡性和May的平衡性都被破坏，我们&lt;strong&gt;只需要解决第一个被破坏的结点Mar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“发现者”是Mar，“麻烦结点”Apr在&lt;strong&gt;发现者左子树的左边&lt;/strong&gt;，因而交LL插入，需要&lt;strong&gt;LL旋转（左单旋）&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczga3lq2xj30qs07o77n.jpg&#34; alt=&#34;image-20200319191437310&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;lr旋转&#34;&gt;LR旋转&lt;/h4&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczgl6yye9j30rc07ggqh.jpg&#34; alt=&#34;image-20200319192517997&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;“发现者”&lt;strong&gt;是May，&lt;/strong&gt;“麻烦结点”&lt;strong&gt;Jan在&lt;/strong&gt;左子树的右边&lt;/strong&gt;，因而交LR插入，需要LR旋转&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczgngz7eij30qo09kn1u.jpg&#34; alt=&#34;image-20200319192729272&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;rl旋转&#34;&gt;RL旋转&lt;/h4&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczhisf5hvj30s008uwkm.jpg&#34; alt=&#34;image-20200319195734013&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gczi7io743j30rk09uwje.jpg&#34; alt=&#34;image-20200319202119089&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;相关概念&#34;&gt;相关概念&lt;/h3&gt;
&lt;p&gt;优先队列（Priority Queue）：特殊的“队列”，&lt;strong&gt;取出元素的顺序是按照元素的优先权（关键字）大小&lt;/strong&gt;，呃呃不是元素进入队列的先后顺序；我们发现当我们实现优先队列的时候，无论是数组、有序数组还是链表，我们都不能很好地去实现按优先权大小这个功能&lt;/p&gt;
&lt;p&gt;堆&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构性：用&lt;strong&gt;数组&lt;/strong&gt;表示的&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd2xwdipq4j30m00bg0uh.jpg&#34; alt=&#34;image-20200322194055046&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有序性：&lt;strong&gt;任一结点的关键字是其子树所有节点的最大值（或最小值）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大堆：也称“大顶堆”：根节点是最大值&lt;/li&gt;
&lt;li&gt;最小堆：也称“小顶堆”：根节点是最小值&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd2ui2g1a7j30ts0j67fg.jpg&#34; alt=&#34;image-20200322174322022&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;h3 id=&#34;最大堆操作&#34;&gt;最大堆操作&lt;/h3&gt;
&lt;h4 id=&#34;创建最大堆&#34;&gt;创建最大堆&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef int ElementType;
typedef struct HNode* Heap; /* 堆的类型定义 */
struct HNode {
    ElementType* Data; /* 存储元素的数组 */
    int Size;          /* 堆中当前元素个数 */
    int Capacity;      /* 堆的最大容量 */
};
typedef Heap MaxHeap; /* 最大堆 */

#define MAXDATA 1000  /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */

/**
 * @description: 创建容量为MaxSize的空的最大堆
 * @param int
 * @return: MaxHeap
 */ 
MaxHeap CreateMaxHeap (int MaxSize) {
    MaxHeap H = (MaxHeap) malloc (sizeof(struct HNode));
    H-&amp;gt;Data = (ElementType*) malloc ((MaxSize + 1) * sizeof(ElementType));
    H-&amp;gt;Size = 0;
    H-&amp;gt;Capacity = MaxSize;
    H-&amp;gt;Data[0] = MAXDATA;   /* 定义&amp;quot;哨兵&amp;quot;为大于堆中所有可能元素的值*/
    return H;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;最大堆插入结点&#34;&gt;最大堆插入结点&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @description: 将元素X插入最大堆H，其中H-&amp;gt;Data[0]已经定义为哨兵
 * @param MaxHeap 
 * @param ElementType
 * @return: bool
 */
bool Insert (MaxHeap H, ElementType X) {
    int i;
    if (IsFull(H)) { 
        printf(&amp;quot;最大堆已满\n&amp;quot;);
        return false;
    }
    i = ++H-&amp;gt;Size; /* i指向插入后堆中的最后一个元素的位置 */
    for (; H-&amp;gt;Data[i / 2] &amp;lt; X; i /= 2)
        H-&amp;gt;Data[i] = H-&amp;gt;Data[i / 2]; /* 上滤X */
    H-&amp;gt;Data[i] = X; /* 将X插入 */
    return true;
}

/**
 * @description: 判断堆是否达到最大容量
 * @param Heap
 * @return: bool
 */
bool IsFull(Heap H){
    return (H-&amp;gt;Size == H-&amp;gt;Capacity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;最大堆结点的删除&#34;&gt;最大堆结点的删除&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */
/**
 * @description: 从最大堆H中取出键值为最大的元素，并删除一个结点
 * @param MaxHeap 
 * @return: ElementType
 */
ElementType DeleteMax (MaxHeap H) {
    int Parent, Child;
    ElementType MaxItem, X;
    if (IsEmpty(H)) {
        printf(&amp;quot;最大堆已为空&amp;quot;);
        return ERROR;
    }
    MaxItem = H-&amp;gt;Data[1]; /* 取出根结点存放的最大值 */
    /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */
    X = H-&amp;gt;Data[H-&amp;gt;Size--]; /* 注意当前堆的规模要减小 */
    for(Parent = 1; Parent * 2 &amp;lt;= H-&amp;gt;Size; Parent = Child ) {
        Child = Parent * 2;
        if((Child != H-&amp;gt;Size) &amp;amp;&amp;amp; (H-&amp;gt;Data[Child] &amp;lt; H-&amp;gt;Data[Child + 1]))
            Child++;  /* Child指向左右子结点的较大者 */
        if(X &amp;gt;= H-&amp;gt;Data[Child]) break; /* 找到了合适位置 */
        else  /* 下滤X */
            H-&amp;gt;Data[Parent] = H-&amp;gt;Data[Child];
    }
    H-&amp;gt;Data[Parent] = X;
    return MaxItem;
} 

/**
 * @description: 判断堆是否为空
 * @param Heap 
 * @return: bool
 */
bool IsEmpty(Heap H) {
    return (H-&amp;gt;Size == 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;最大堆的建立&#34;&gt;最大堆的建立&lt;/h4&gt;
&lt;p&gt;建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法1：通过插入操作，将N个元素一个个相继插入到一个初始化为空的堆中去，时间代价为&lt;code&gt;O(NlogN)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法2：在线性时间复杂度下建立最大堆
&lt;ul&gt;
&lt;li&gt;将N个元素按输入顺序存入，先满足完全二叉树的结构特性&lt;/li&gt;
&lt;li&gt;调整各结点位置，以满足最大堆的有序特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @description: 调整H-&amp;gt;Data[]中的元素，使满足最大堆的有序性
 * @param MaxHeap 
 */
void BuildMaxHeap(MaxHeap H) {
    /* 这里假设所有H-&amp;gt;Size个元素已经存在H-&amp;gt;Data[]中 */
    int i;
    /* 从最后一个结点的父节点开始，到根结点1 */
    for(i = H-&amp;gt;Size / 2; i &amp;gt; 0; i--)
        PercDown(H, i);
}

/**
 * @description: 下滤：将H中以H-&amp;gt;Data[p]为根的子堆调整为最大堆
 * @param MaxHeap
 * @param int 
 */
void PercDown(MaxHeap H, int p) {
    int Parent, Child;
    ElementType X;
    X = H-&amp;gt;Data[p]; /* 取出根结点存放的值 */
    for(Parent = p; Parent * 2 &amp;lt;= H-&amp;gt;Size; Parent = Child ) {
        Child = Parent * 2;
        if((Child != H-&amp;gt;Size) &amp;amp;&amp;amp; (H-&amp;gt;Data[Child] &amp;lt; H-&amp;gt;Data[Child + 1]) )
            Child++;  /* Child指向左右子结点的较大者 */
        if(X &amp;gt;= H-&amp;gt;Data[Child]) break; /* 找到了合适位置 */
        else  /* 下滤X */
            H-&amp;gt;Data[Parent] = H-&amp;gt;Data[Child];
    }
    H-&amp;gt;Data[Parent] = X;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;堆排序&#34;&gt;堆排序&lt;/h3&gt;
&lt;h4 id=&#34;算法1&#34;&gt;算法1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void HeapSort1 (ElementType A[], int N) {
  BuildHeap(A);
  for (i = 0; i &amp;lt; N; i++) {
    tempA[i] = DeleteMin(A);
  }
  for (i = 0; i &amp;lt; N; i++) {
    A[i] = tempA[i];
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度为&lt;code&gt;O(NlogN)&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;需要额外&lt;code&gt;O(N)&lt;/code&gt;空间，并且复制元素需要时间&lt;/p&gt;
&lt;h4 id=&#34;算法2&#34;&gt;算法2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef int ElementType;

/**
 * @brief 交换元素
 * @param a 
 * @param b 
 */
void Swap(ElementType *a, ElementType *b) {
    ElementType t = *a;
    *a = *b;
    *b = t;
}

/**
 * @brief 向下过滤，将N个元素的数组中以A[p]为根的子堆调整为最大堆
 * @param A 
 * @param p 
 * @param N 
 */
void PercDown(ElementType A[], int p, int N) {
    int Parent, Child;
    ElementType X;

    X = A[p]; /* 取出根结点存放的值 */
    for (Parent = p; (Parent * 2 + 1) &amp;lt; N; Parent = Child) {
        Child = Parent * 2 + 1; // 从0开始，不同之前堆是从1开始
        if ((Child != N - 1) &amp;amp;&amp;amp; (A[Child] &amp;lt; A[Child + 1]))
            Child++; /* Child指向左右子结点的较大者 */
        if (X &amp;gt;= A[Child])
            break; /* 找到了合适位置 */
        else       /* 下滤X */
            A[Parent] = A[Child];
    }
    A[Parent] = X;
}

/**
 * @brief 堆排序
 * @param A 
 * @param N 
 */
void HeapSort(ElementType A[], int N) {
    int i;
    for (i = N / 2; i &amp;gt;= 0; i--) /* 建立最大堆 */
        PercDown(A, i, N);
    for (i = N - 1; i &amp;gt; 0; i--) {
        /* 删除最大堆顶 */
        Swap(&amp;amp;A[0], &amp;amp;A[i]);
        PercDown(A, 0, i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;哈夫曼树与编码&#34;&gt;哈夫曼树与编码&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;基础概念&#34;&gt;基础概念&lt;/h3&gt;
&lt;p&gt;带权路径长度（WPL）：设二叉树有n个叶子结点，每个叶子结点带有权值w&lt;sub&gt;k&lt;/sub&gt;，从根节点到每个叶子结点的长度为I&lt;sub&gt;k&lt;/sub&gt;，则每个叶子结点的带权路径长度之和就是 &lt;strong&gt;WPL = ∑w&lt;sub&gt;k&lt;/sub&gt;I&lt;sub&gt;k&lt;/sub&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最优二叉树获哈夫曼树&lt;/strong&gt;：&lt;strong&gt;WPL最小的二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;哈夫曼树的构造&#34;&gt;哈夫曼树的构造&lt;/h3&gt;
&lt;p&gt;每次把&lt;strong&gt;权值最小的两颗二叉树&lt;/strong&gt;合并，&lt;strong&gt;如何每次找到最小的权值 ==&amp;gt; 最小堆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
#define MINDATA -1     /* 该值应根据具体情况定义为小于堆中所有可能元素的值 */

typedef struct HuffmanTreeNode* HuffmanTree;
struct HuffmanTreeNode {    /* 哈弗曼树结点定义 */
    int weight;             /* 权值 */
    HuffmanTree left, right;
};

typedef HuffmanTreeNode* ElementType;   /* 哈弗曼树结点的指针为ElementType */
typedef struct HNode* Heap; /* 堆的类型定义 */
typedef Heap MinHeap;       /* 最小堆 */
struct HNode {
    ElementType* Data;      /* 存储元素的数组 */
    int Size;               /* 堆中当前元素个数 */
    int Capacity;           /* 堆的最大容量 */
};

/**
 * @description: 创建容量为MaxSize的最小堆
 * @param int 
 * @return: MinHeap
 */
MinHeap CreateMinHeap (int MaxSize) {
    MinHeap H = (MinHeap)malloc(sizeof(struct HNode));
    H-&amp;gt;Data = (ElementType*)malloc((MaxSize + 1) * sizeof (ElementType));
    H-&amp;gt;Size = 0;
    H-&amp;gt;Capacity = MaxSize;
    H-&amp;gt;Data[0]-&amp;gt;weight = MINDATA;  /* 定义&amp;quot;哨兵&amp;quot;为小于堆中所有可能元素的值*/
    return H;
}

/**
 * @description: 判断堆是否达到最大容量
 * @param MinHeap
 * @return: bool
 */
bool IsFull(MinHeap H){
    return (H-&amp;gt;Size == H-&amp;gt;Capacity);
}

/**
 * @description: 将元素X插入最小堆H，其中H-&amp;gt;Data[0]已经定义为哨兵
 * @param MinHeap
 * @param ElementType 
 * @return: bool
 */
bool Insert (MinHeap H, ElementType X) {
    int i;
    if (IsFull(H)) {
        printf(&amp;quot;最小堆已满\n&amp;quot;);
        return false;
    }
    i = ++H-&amp;gt;Size;  /* i指向插入后堆中的最后一个元素的位置 */
    for (; H-&amp;gt;Data[i / 2]-&amp;gt;weight &amp;gt; X-&amp;gt;weight; i /= 2) {
        H-&amp;gt;Data[i] = H-&amp;gt;Data[i / 2];    /* 上滤X */
    }
    H-&amp;gt;Data[i] = X; /* 将X插入 */
}

/**
 * @description: 判断堆是否为空
 * @param MinHeap 
 * @return: bool
 */
bool IsEmpty(MinHeap H) {
    return (H-&amp;gt;Size == 0);
}

/**
 * @description: 从最小堆H中取出键值为最小的元素，并删除一个结点
 * @param MinHeap 
 * @return: ElementType
 */
ElementType DeleteMin (MinHeap H) {
    int Parent, Child;
    ElementType MinItem, X;
    if (IsEmpty(H)) {
        printf(&amp;quot;最小堆已为空\n&amp;quot;);
        return;
    }
    MinItem = H-&amp;gt;Data[1];   /* 取出根结点存放的最小值 */
    X = H-&amp;gt;Data[H-&amp;gt;Size--];
    for (Parent = 1; Parent * 2 &amp;lt;= H-&amp;gt;Size; Parent = Child) {
        Child = Parent * 2;
        if ((Child != H-&amp;gt;Size) &amp;amp;&amp;amp; (H-&amp;gt;Data[Child]-&amp;gt;weight &amp;gt; H-&amp;gt;Data[Child + 1]-&amp;gt;weight))
            Child++;    /* Child指向左右子结点的较小者 */
        if (X-&amp;gt;weight &amp;lt;= H-&amp;gt;Data[Child]-&amp;gt;weight) break; /* 找到了合适的位置 */
        else  /* 下滤X */
            H-&amp;gt;Data[Parent] = H-&amp;gt;Data[Child];
    }
    H-&amp;gt;Data[Parent] = X;
    return MinItem;
}

/**
 * @description: 下滤：将H中以H-&amp;gt;Data[p]为根的子堆调整为最小堆
 * @param MaxHeap
 * @param int 
 */
void PercDown(MinHeap H, int p) {
    int Parent, Child;
    ElementType X;
    X = H-&amp;gt;Data[p]; /* 取出根结点存放的值 */
    for(Parent = p; Parent * 2 &amp;lt;= H-&amp;gt;Size; Parent = Child) {
        Child = Parent * 2;
        if((Child != H-&amp;gt;Size) &amp;amp;&amp;amp; (H-&amp;gt;Data[Child]-&amp;gt;weight &amp;gt; H-&amp;gt;Data[Child + 1]-&amp;gt;weight))
            Child++;  /* Child指向左右子结点的较大者 */
        if(X-&amp;gt;weight &amp;lt;= H-&amp;gt;Data[Child]-&amp;gt;weight) break; /* 找到了合适位置 */
        else  /* 下滤X */
            H-&amp;gt;Data[Parent] = H-&amp;gt;Data[Child];
    }
    H-&amp;gt;Data[Parent] = X;
}

/**
 * @description: 调整H-&amp;gt;Data[]中的元素，使满足最大堆的有序性
 * @param MaxHeap 
 */
void BuildMinHeap(MinHeap H) {
    /* 这里假设所有H-&amp;gt;Size个元素已经存在H-&amp;gt;Data[]中 */
    int i;
    /* 从最后一个结点的父节点开始，到根结点1 */
    for(i = H-&amp;gt;Size / 2; i &amp;gt; 0; i--)
        PercDown(H, i);
}

/**
 * @description: 利用最小堆构建哈弗曼树
 * @param MinHeap 
 * @return: HuffmanTree
 */
HuffmanTree Huffman (MinHeap H) {
    /* 假设H-&amp;gt;Size个权值赢存在H-&amp;gt;Elements[]-&amp;gt;weight里 */
    int i;
    HuffmanTree T;
    BuildMinHeap(H);    /* 将H-&amp;gt;Elements[]按权值调整为最小堆 */
    for (i = 1; i &amp;lt; H-&amp;gt;Size; i++) {     /* 合并 */
        T = (HuffmanTree)malloc(sizeof(struct HuffmanTreeNode));
        T-&amp;gt;left = DeleteMin(H);     /* 从最小堆删除一个结点，作为左结点 */
        T-&amp;gt;right = DeleteMin(H);    /* 从最小堆删除一个结点，作为右结点 */
        T-&amp;gt;weight = T-&amp;gt;left-&amp;gt;weight + T-&amp;gt;right-&amp;gt;weight; /* 计算新权值 */
        Insert(H, T);               /* 将新T插入最小堆 */
    }
    T = DeleteMin(H);
    return T;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;哈弗曼编码&#34;&gt;哈弗曼编码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据字符出现的频次，进行不等长编码，提高编码的效率，频率高的字符编码尽量短。但是不等长编码会带来二义性的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免二义性：&lt;strong&gt;前缀码 （prefix code）：任何字符的编码都不是领字符编码的前缀，这样就可以无二义性地解码&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规定在哈弗曼树中左分支为0，右分支为1，则从根节点到每个叶子结点所经过的分支对应的0和1组成的序列便是该结点对应的哈弗曼编码&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd54wq1nlwj316e0u0tgw.jpg&#34; alt=&#34;image-20200324171431840&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;并查集&#34;&gt;并查集&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;基础概念-2&#34;&gt;基础概念&lt;/h3&gt;
&lt;p&gt;并查集是一种维护集合的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并：Union（合并）合并两个集合&lt;/li&gt;
&lt;li&gt;查：Find（查找）判断&lt;strong&gt;两个元素是否在同一个集合里面&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;集：Set（集合）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并查集实现一般&lt;strong&gt;使用数组&lt;/strong&gt;来实现，数组中每个元素类型定义为&lt;code&gt;SetType&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef int ElementType;
typedef struct {
    ElementType data;
    int parent;		// 指向parent数组下标
}SetType;
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd56rbmyqfj30dw0gcq4i.jpg&#34; alt=&#34;image-20200324181835578&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd56saat66j30ke07iwft.jpg&#34; alt=&#34;image-20200324181930573&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;集合运算&#34;&gt;集合运算&lt;/h3&gt;
&lt;h4 id=&#34;查找&#34;&gt;查找&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 查找某个元素所在集合
 * @param S 
 * @param X 
 * @return int 
 */
int Find(SetType S[], ElementType X) {
    int i;
    for (i = 0; i &amp;lt; MaxSize &amp;amp;&amp;amp; S[i].data != X; i++);
    if (i &amp;gt;= MaxSize)
        return -1;  // 未找到返回-1
    for (; S[i].parent &amp;gt; 0; i = S[i].parent);
    return i;       // 找到 X 所在集合，返回树根结点在数组 X 中的下标
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;并&#34;&gt;并&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;分别找到&lt;code&gt;X1&lt;/code&gt;和&lt;code&gt;X2&lt;/code&gt;两个元素所在集合树的根节点&lt;/li&gt;
&lt;li&gt;如果他们不同根，&lt;strong&gt;将其中一个根节点的父结点指针设置成另一个根节点的数组下标&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为了提高合并后查找的性能，我们可以采用小的集合合并到大的集合里面&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如何知道两个集合谁大谁小？ ==&amp;gt; 我们可以看到当一个元素为根节点的时候，他的&lt;code&gt;parent&lt;/code&gt;为-1，那么我们可以对其进行修改变为 &lt;code&gt;-集合元素个数&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTgy1gd57zq96wmj30we0hi0zw.jpg&#34; alt=&#34;image-20200324190115919&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * @brief 合并两个元素所在集合树根节点
 * @param S 
 * @param X1 
 * @param X2 
 */
void Union (SetType S[], ElementType X1, ElementType X2) {
    int root1, root2;
    root1 = Find(S, X1);
    root2 = Find(S, X2);
    // 集合1比较大，将集合2并入集合1
    if (S[root1].parent &amp;lt; S[root2].parent) { 
        S[root1].parent += S[root2].parent;
        S[root2].parent = root1;
    } else {
        S[root2].parent += S[root1].parent;
        S[root1].parent = root2;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">树（进阶篇）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/shu-ru-men-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;树是一种数据结构，它是由n（n&amp;gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。本篇主要就树的一些基础部分进行一些梳理，所有代码均在LeetCode或PAT上Accepted&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;二叉树相关概念&#34;&gt;二叉树相关概念&lt;/h2&gt;
&lt;/br&gt;
&lt;h3 id=&#34;树的相关概念&#34;&gt;树的相关概念&lt;/h3&gt;
&lt;p&gt;在数据结构中把树枝分叉处、树叶、树根抽象为&lt;strong&gt;节点（node）&lt;/strong&gt;，其中树根抽象为&lt;strong&gt;根节点&lt;/strong&gt;，且对于一棵树来说最多存在一个根节点；把树叶概括为&lt;strong&gt;叶子节点&lt;/strong&gt;，且叶子节点不再延伸出新的节点；把茎干和树枝统一抽象为&lt;strong&gt;边&lt;/strong&gt;。这样，树就被定位为若干个节点和若干条边组成的数据结构，且在&lt;strong&gt;树中的结点不能被边连接成环&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树可以没有结点，这种情况下被称为空树&lt;/li&gt;
&lt;li&gt;树的&lt;strong&gt;层次(layer)&lt;strong&gt;从根节点开始计算，即根节点为第一层，根节点子树的&lt;/strong&gt;根节点&lt;/strong&gt;为第二层&lt;/li&gt;
&lt;li&gt;把结点的子树棵树称为结点的&lt;strong&gt;度(degree)&lt;/strong&gt;，而树中结点最大的度称为&lt;strong&gt;树的度&lt;/strong&gt;。（二叉树的树度为2）&lt;/li&gt;
&lt;li&gt;由于一条边连接两个结点，且树中不存在环，因此对&lt;strong&gt;有n个结点的树，边数一定是n-1&lt;/strong&gt;。且&lt;strong&gt;满足连通、边数等于顶点数 - 1的结构一定是树&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;叶子节点被定义为度为0的结点，因此当树中只有一个结点（根节点）时，根节点也算叶子结点&lt;/li&gt;
&lt;li&gt;结点的&lt;strong&gt;深度(depth)&lt;strong&gt;是指从根节点（深度为1）开始&lt;/strong&gt;自顶向下逐层累&lt;/strong&gt;加至该节点时的深度值；结点的&lt;strong&gt;高度（height）&lt;strong&gt;是指从最底层叶子结点（高度为1）开始&lt;/strong&gt;自底向上逐层累加&lt;/strong&gt;至该节点时的高度。树的高度是指树中结点的最大高度。&lt;strong&gt;对树而言，深度和高度是相等的&lt;/strong&gt;，对结点而言不一定。&lt;/li&gt;
&lt;li&gt;多棵树组合在一起称为&lt;strong&gt;森林（forest）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcpz40e6q9j30g308ljrs.jpg&#34; alt=&#34;image-20200311143025921&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉树及特殊的二叉树&#34;&gt;二叉树及特殊的二叉树&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉树递归定义：&lt;/p&gt;
&lt;p&gt;1、要么二叉树没有根节点，是一棵空树&lt;/p&gt;
&lt;p&gt;2、要么二叉树由根节点、左子树、右子树组成，且左子树和右子树都是二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;二叉树和度为2的树区别：度为2的树只能说明树中每个结点的子节点个数不超过2。二叉树虽然满足，但是&lt;strong&gt;二叉树严格区分左右子树，不能随意交换左子树和右子树的位置。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;满二叉树：每一层的结点个数&lt;strong&gt;都达到了该层所能达到的最大结点个数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;完全二叉树：除了最下面一层外，&lt;strong&gt;其余层的结点个数都达到了当层所能达到的最大结点树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcpzcvqmxyj31ki0rg11a.jpg&#34; alt=&#34;image-20200311143901133&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉树的主要性质&#34;&gt;二叉树的主要性质&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在二叉树中，第&lt;code&gt;i&lt;/code&gt;层上最多有&lt;code&gt;2i&lt;/code&gt;个结点&lt;code&gt;（ i≥0 ）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;深度为&lt;code&gt;k&lt;/code&gt;的二叉树至多有&lt;strong&gt;2&lt;sup&gt;k+1&lt;/sup&gt; - 1&lt;/strong&gt;个结点&lt;code&gt;（ k≥0 ）&lt;/code&gt;其中深度&lt;code&gt;(depth)&lt;/code&gt;定义为二叉树中层数最大的叶结点的层数&lt;/li&gt;
&lt;li&gt;一棵二叉树，若其终端结点数为&lt;strong&gt;n&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt;，度为2的结点数为&lt;strong&gt;n&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; ，则&lt;strong&gt;n&lt;sub&gt;0&lt;/sub&gt; = n&lt;sub&gt;2&lt;/sub&gt; + 1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;满二叉树定理：非空满二叉树树叶数目等于其分支结点数加1&lt;/li&gt;
&lt;li&gt;满二叉树定理推论：一个非空3叉树的空子树数目等 于其结点数加1&lt;/li&gt;
&lt;li&gt;有n个结点&lt;code&gt;（ n &amp;gt; 0 ）&lt;/code&gt;的完全二叉树的高度为 &lt;strong&gt;⌈log&lt;sub&gt;2&lt;/sub&gt; (n+1)⌉&lt;/strong&gt;（深度为⌈log&lt;sub&gt;2&lt;/sub&gt; (n+1)⌉ - 1 ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;二叉树的存储结构&#34;&gt;二叉树的存储结构&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt;是特殊化的&lt;code&gt;Tree&lt;/code&gt;；&lt;code&gt;Tree&lt;/code&gt;是特殊化的&lt;code&gt;Graph&lt;/code&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉树顺序存储结构&#34;&gt;二叉树顺序存储结构&lt;/h3&gt;
&lt;p&gt;完全二叉树：从上至下、从左到右存储n个结点的完全二叉树的结点父子关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非根节点（序号i &amp;gt; 1）的&lt;strong&gt;父节点&lt;/strong&gt;序号是**⌊i/2⌋**&lt;/li&gt;
&lt;li&gt;结点（序号为i）的左孩子结点序号是&lt;code&gt;2i&lt;/code&gt;，（若&lt;code&gt;2i &amp;lt;= n&lt;/code&gt;，否则没有左孩子）&lt;/li&gt;
&lt;li&gt;结点（序号为i）的左孩子结点序号是&lt;code&gt;2i + 1&lt;/code&gt;，（若&lt;code&gt;2i &amp;lt;= n&lt;/code&gt;，否则没有左孩子）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcr3wigu48j30a907m0t4.jpg&#34; alt=&#34;image-20200312140148940&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;结点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;A&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;B&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;O&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;S&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;M&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Q&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;W&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;K&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;一般二叉树可以采用这种结构，但会造成空间浪费&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3 id=&#34;二叉树链表存储&#34;&gt;二叉树链表存储&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TreeNode {
    public int val;
    public TreeNode left,right;
    public TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcr451q1xjj30po08sdgk.jpg&#34; alt=&#34;image-20200312141005358&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;二叉树的遍历&#34;&gt;二叉树的遍历&lt;/h2&gt;
&lt;p&gt;我们统一结点类型为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;			// 数据域
    TreeNode* left;		// 指向左子树根节点指针
    TreeNode* right;	// 指向右子树根节点指针
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;先中后递归遍历&#34;&gt;先中后递归遍历&lt;/h3&gt;
&lt;h4 id=&#34;先序&#34;&gt;先序&lt;/h4&gt;
&lt;p&gt;​	访问&lt;strong&gt;根节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;先序&lt;/strong&gt;遍历其&lt;strong&gt;左子树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;先序&lt;/strong&gt;遍历其&lt;strong&gt;右子树&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) {
        if (root != NULL) {
            res.push_back(root-&amp;gt;val);
            preorderTraversal(root-&amp;gt;left);
            preorderTraversal(root-&amp;gt;right);
        }
        return res;
    }
private:
    vector&amp;lt;int&amp;gt; res;
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;中序&#34;&gt;中序&lt;/h4&gt;
&lt;p&gt;​	&lt;strong&gt;中序&lt;/strong&gt;遍历&lt;strong&gt;左子树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	访问&lt;strong&gt;根节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;中序&lt;/strong&gt;遍历&lt;strong&gt;右子树&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) {
        if (root != NULL) {
            inorderTraversal(root-&amp;gt;left);
            res.push_back(root-&amp;gt;val);
            inorderTraversal(root-&amp;gt;right);
        }
    }
private:
    vector&amp;lt;int&amp;gt; res;
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;后序&#34;&gt;后序&lt;/h4&gt;
&lt;p&gt;​	&lt;strong&gt;后序&lt;/strong&gt;遍历&lt;strong&gt;左子树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;后序&lt;/strong&gt;遍历&lt;strong&gt;右子树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	访问&lt;strong&gt;根节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) {
        if(root != NULL) {
            postorderTraversal(root-&amp;gt;left);
            postorderTraversal(root-&amp;gt;right);
            res.push_back(root-&amp;gt;val);
        }
        return res;
    }
private:
    vector&amp;lt;int&amp;gt; res;
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;先中后非递归遍历&#34;&gt;先中后非递归遍历&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;先序、中序和后序遍历过程：遍历过程中经过结点的路线是一样的，只是访问各结点的时机不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先序遍历和中序遍历的，&lt;strong&gt;区别在于第一次访问结点和第二次访问结点什么时候打印结点的问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T = root;
while(栈不空 || T != NULL) {
	while(T != NULL) {
		第一次访问结点;T进栈		// printf ==&amp;gt; 先序
		T = T-&amp;gt;lchild;
	}
	// 以下考虑栈顶结点
	while(栈不空) {
		第二次访问结点;出栈;		// printf ==&amp;gt; 中序
		T = T-&amp;gt;rchild;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;先序-2&#34;&gt;先序&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第一次碰到结点就打印（压栈操作的时候）&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcre0lq5v7j30z40mwq8j.jpg&#34; alt=&#34;image-20200312195147479&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;遇到一个结点就把它压栈打印，并去遍历它的左子树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;左子树遍历结束后，从栈顶弹出这个结点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后按照其&lt;strong&gt;右指针在去先序遍历该结点的右子树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 先序遍历非递归算法
     * @param root 
     * @return vector&amp;lt;int&amp;gt; 
     */
    vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) {
        TreeNode* T = root;
        vector&amp;lt;int&amp;gt; res;
        stack &amp;lt;TreeNode*&amp;gt; s;
        while (T != NULL || !s.empty()) {
            // 遇到第一个结点就压栈，并去遍历左子树
            while (T != NULL) {
                // 第一次访问结点就加到结果集
                res.push_back(T-&amp;gt;val);
                s.push(T);
                T = T-&amp;gt;left;
            }
            if (!s.empty()) {
                // 左子树遍历结束，弹出栈顶元素
                T = s.top();
                s.pop();
                T = T-&amp;gt;right;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;中序-2&#34;&gt;中序&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第二次碰到结点就打印（出栈操作的时候）&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcrdzhhggvj310e0mc0ze.jpg&#34; alt=&#34;image-20200312195042614&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;遇到一个结点就把它压栈，并去遍历它的左子树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;左子树遍历结束后，从栈顶弹出这个结点并访问它&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后按照其&lt;strong&gt;右指针在去中序遍历该结点的右子树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 中序遍历非递归算法
     * @param root 
     * @return vector&amp;lt;int&amp;gt; 
     */
    vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) {
        TreeNode* T = root;
        vector&amp;lt;int&amp;gt; res;
        stack&amp;lt;TreeNode*&amp;gt; s;
        while (T != NULL || !s.empty()) {
            // 遇到第一个结点就压栈，并遍历左子树
            while (T != NULL) {
                s.push(T);
                T = T-&amp;gt;left;
            }
            if (!s.empty()) {
                // 左子树遍历结束，从栈顶弹出结点并访问
                T = s.top();
                s.pop();
                res.push_back(T-&amp;gt;val);
                // 按右指针去中序遍历该结点右子树
                T = T-&amp;gt;right;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;后序-2&#34;&gt;后序&lt;/h4&gt;
&lt;p&gt;我们不妨来思考先序遍历的顺序是 根-左-右，&lt;strong&gt;我们很容易能够变成根-右-左，那么后序遍历恰好是这种结果的一个倒序&lt;/strong&gt;，我们就可以&lt;strong&gt;采用栈来保存根-右-左这种遍历结果的顺序，然后依次出栈就是后序遍历结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 后序遍历非递归算法 ==&amp;gt; 中序遍历稍作修改
     * @param root 
     * @return vector&amp;lt;int&amp;gt; 
     */
    vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) {
        vector&amp;lt;int&amp;gt; res;
        stack&amp;lt;TreeNode*&amp;gt; s;
        TreeNode* T = root;
        while (T != NULL || !s.empty()) {
            // 遇到第一个结点就压栈，并去访问右子树，将结果放在前面
            while (T != NULL) {
                s.push(T);
                res.insert(res.begin(),T-&amp;gt;val);
                T = T-&amp;gt;right;
            }
            // 访问栈顶元素，遍历结点左子树
            if (!s.empty()) {
                T = s.top();
                s.pop();
                T = T-&amp;gt;left;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;层次遍历&#34;&gt;层次遍历&lt;/h3&gt;
&lt;p&gt;层次遍历是按照层次的顺序从根节点向下逐层进行遍历，而且对每一层的结点从左到右进行&lt;/p&gt;
&lt;p&gt;BFS思想 ==&amp;gt; &lt;strong&gt;使用队列实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 层序遍历：使用队列 BFS 思想
     * @param root 
     * @return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; 
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
        queue&amp;lt;TreeNode*&amp;gt; q;
        if (root == NULL) {
            return res;
        }
        q.push(root);
        while (!q.empty()) {
            vector&amp;lt;int&amp;gt; v;
            // 使用count记录每一层的个数
            int count = q.size();
            while (count--) {
                TreeNode* T;
                T = q.front();
                q.pop();
                v.push_back(T-&amp;gt;val);
                if (T-&amp;gt;left != NULL) {
                    q.push(T-&amp;gt;left);
                }        
                if (T-&amp;gt;right != NULL) {
                    q.push(T-&amp;gt;right);
                }
            }
            res.push_back(v);
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h2 id=&#34;二叉树遍历的应用&#34;&gt;二叉树遍历的应用&lt;/h2&gt;
&lt;p&gt;以下我们统一数据结点为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;输出二叉树的叶子结点&#34;&gt;输出二叉树的叶子结点&lt;/h3&gt;
&lt;p&gt;在二叉树遍历算法中&lt;strong&gt;增加检测结点的“左右子树是否都为空”&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void PreOrderPrintLeaves (TreeNode* root) {
  if (root != NULL) {
    if (root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) {
      printf(&amp;quot;%d\n&amp;quot;, root-&amp;gt;val);
    }
    PreOrderPrintLeaves(root-&amp;gt;left);
    PreOrderPrintLeaves(root-&amp;gt;right);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;求二叉树的高度&#34;&gt;求二叉树的高度&lt;/h3&gt;
&lt;h4 id=&#34;递归解法&#34;&gt;递归解法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxDepth(TreeNode* root) {
    if (root == NULL) {
      return 0;
    }
    return 1 + max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;bfs解法&#34;&gt;BFS解法&lt;/h4&gt;
&lt;p&gt;我们也可以使用层序遍历二叉树，然后计数总层数，即为二叉树的最大深度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @brief 求树的最大深度
     * @param root 
     * @return int 
     */
    int maxDepth(TreeNode *root) {
        TreeNode *T = root;
        int res = 0;
        if (root == NULL) {
            return 0;
        }
        queue&amp;lt;TreeNode *&amp;gt; q;
        q.push(T);
        while (!q.empty()) {
            res++;
            // 一定要将 q.size() 放在初始化里，而不能放在判断停止的条件中
            // 因为q的大小是随时变化的，所以放停止条件中会出错
            for (int i = q.size(); i &amp;gt; 0; i--) {
                T = q.front();
                q.pop();
                if (T-&amp;gt;left != NULL) {
                    q.push(T-&amp;gt;left);
                }
                if (T-&amp;gt;right != NULL) {
                    q.push(T-&amp;gt;right);
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;dfs解法&#34;&gt;DFS解法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int max_depth = 0;
    int maxDepth(TreeNode* root) {
        if (root == NULL)
            return 0;
        dfs (root, 1);
        return max_depth;
    }
    /**
     * @brief DFS求最大深度
     * @param root 
     * @param depth 
     */
    void dfs (TreeNode* root, int depth) {
        // 是叶子结点，更新最大高度
        if (root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) {
            max_depth = max(max_depth, depth); 
        }
        // 递归左子树
        if (root-&amp;gt;left != NULL)
            dfs(root-&amp;gt;left, depth + 1);
        // 递归右子树
        if (root-&amp;gt;right != NULL)
            dfs(root-&amp;gt;right, depth + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/br&gt;
&lt;h3 id=&#34;两种遍历序列确定一颗二叉树&#34;&gt;两种遍历序列确定一颗二叉树&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;必须要知道&lt;strong&gt;中序序列&lt;/strong&gt;才能去确定一颗二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;先序中序&#34;&gt;先序+中序&lt;/h4&gt;
&lt;p&gt;先序和中序遍历序列来确定一颗二叉树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据&lt;strong&gt;先序&lt;/strong&gt;序列第一个结点确定&lt;strong&gt;根节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据根节点在中序遍历序列中&lt;strong&gt;分割出左右两个子序列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对左子树和右子树&lt;strong&gt;分别递归使用相同的方法继续分解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcsdd9pamcj30rh09tdgb.jpg&#34; alt=&#34;image-20200313161453855&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;如果递归过程中先序序列区间为&lt;code&gt;[ps, pe]&lt;/code&gt;，中序序列为&lt;code&gt;[is, ie]&lt;/code&gt;，&lt;code&gt;pos&lt;/code&gt;为&lt;strong&gt;根节点在中序序列中的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;左子树的结点个数为&lt;code&gt;numLeft = pos - is&lt;/code&gt;，左子树的先序序列区间就是&lt;code&gt;[ps + 1, ps + numLeft]&lt;/code&gt;，左子树的中序序列区间就是&lt;code&gt;[is, pos - 1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;右子树的先序序列&lt;code&gt;[ps + numLeft + 1, pe]&lt;/code&gt;，右子树的中序序列为&lt;code&gt;[pos + 1, ie]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) {
        return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);
    }

    TreeNode* create(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder, int ps, int pe, int is, int ie){
        if(ps &amp;gt; pe){
            return nullptr;
        }
        TreeNode* node = new TreeNode(preorder[ps]);
        // 找中序序列的位置
        int pos;
        for(int i = is; i &amp;lt;= ie; i++){
            if(inorder[i] == node-&amp;gt;val) {
                pos = i;
                break;
            }
        }
        int numLeft = pos - is;
        // 递归
        node-&amp;gt;left = create(preorder, inorder, ps + 1, ps + numLeft, is, pos - 1);
        node-&amp;gt;right = create(preorder, inorder, ps + numLeft + 1, pe, pos + 1, ie);
        return node;                            
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;后序中序&#34;&gt;后序+中序&lt;/h4&gt;
&lt;p&gt;思路同前序序列和中序序列构造二叉树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果递归过程中后序序列区间为&lt;code&gt;[ps, pe]&lt;/code&gt;，中序序列为&lt;code&gt;[is, ie]&lt;/code&gt;，&lt;code&gt;pos&lt;/code&gt;为&lt;strong&gt;根节点在中序序列中的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;左子树的结点个数为&lt;code&gt;numLeft = pos - is&lt;/code&gt;，左子树的后序序列区间就是&lt;code&gt;[ps, ps + numLeft - 1]&lt;/code&gt;，左子树的中序序列区间就是&lt;code&gt;[is, pos - 1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;右子树的后序序列&lt;code&gt;[ps + numLeft, pe - 1]&lt;/code&gt;，右子树的中序序列为&lt;code&gt;[pos + 1, ie]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder) {
        return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
    }
    TreeNode* create(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder, int is, int ie, int ps, int pe) {
        if (ps &amp;gt; pe) {
            return nullptr;
        }
        TreeNode* node = new TreeNode(postorder[pe]);
        int pos;
        for (int i = is; i &amp;lt;= ie; i++) {
            if (inorder[i] == node-&amp;gt;val) {
                pos = i;
                break;
            }
        }
        int numLeft = pos - is;
        node-&amp;gt;left = create(inorder, postorder, is, pos - 1, ps, ps + numLeft - 1);
        node-&amp;gt;right = create(inorder, postorder, pos + 1, ie, ps + numLeft, pe - 1);
        return node;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">树（入门篇）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/redis-ji-chu-pian-yi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Redis 是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的 Web 应用程序。Redis 也被作者戏称为数据结构服务器 ，这意味着使用者可以通过一些命令，基于带有 TCP 套接字的简单服务器-客户端协议来访问一组可变数据结构 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;redis是什么&#34;&gt;Redis是什么?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、&lt;strong&gt;Key-Value数据库&lt;/strong&gt;，并提供多种语言的API&lt;/p&gt;
&lt;p&gt;​	1、Redis安装在磁盘&lt;/p&gt;
&lt;p&gt;​	2、&lt;strong&gt;Redis数据存储在内存&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis解决什么问题&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9zzdqdpa6j30ne0xmwgl.jpg&#34; alt=&#34;image-20191217201429438&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;​	先从Redis缓存查询数据，如果没有则到MySQL中查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;速度快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;键值对数据结构服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;丰富的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单稳定  --- 单线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高可用、分布式转移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端语言多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis使用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;缓存数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排行榜&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数器应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;社交网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis数据类型&#34;&gt;Redis数据类型?&lt;/h2&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;类型 （实际上可以是&lt;strong&gt;字符串（包括&lt;code&gt;XML JSON&lt;/code&gt;）&lt;/strong&gt;，还有数字（整形 浮点数），&lt;strong&gt;二进制（图片 音频 视频）&lt;/strong&gt;，&lt;strong&gt;最大不能超过512MB&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set age 18	(18)
incr age		(19)
decr age		(18)
incrby age 2	(20)
decrby age 2	(18)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量设值 &lt;code&gt;mset&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mset name Rick age 20
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​		批量设置，可&lt;strong&gt;减少IO进而提高效率&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置过期时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set age 23 ex 10	// 10s后过期 px 10000ms过期
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set name Rick
append name Kay
get name			(RickKay)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计数器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INCR article:readcount:{文章id}		// 统计某文章的阅读量,用户进来点一次进行加1
GET article:readcount:{文章id}		// 获得某文章的阅读量
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INCR article:readcount:1001
INCR article:readcount:1001
INCR article:readcount:1001
INCR article:readcount:1001
GET article:readcount:1001		(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web集群session共享&lt;/p&gt;
&lt;p&gt;Spring session + redis实现session共享&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式系统全局序列号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hash &lt;strong&gt;哈希hash是一个string类型的field和value的映射表，hash特适合用于存储对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储一个用户(user)信息：1主键&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hset&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hset user:1 name Rick age 20
hgetall user:1		(&amp;quot;name&amp;quot; &amp;quot;Rick&amp;quot; &amp;quot;age&amp;quot; &amp;quot;20&amp;quot;)
hget user:1 age					(&amp;quot;20&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hmset&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hmset user:2 name Kay age 20 sex male
hmget user:2 name age sex			(&amp;quot;Kay&amp;quot; &amp;quot;20&amp;quot; &amp;quot;male&amp;quot;)
hgetall user:2	 (&amp;quot;name&amp;quot; &amp;quot;Kay&amp;quot; &amp;quot;age&amp;quot; &amp;quot;18&amp;quot; &amp;quot;sex&amp;quot; &amp;quot;male&amp;quot;)
hvals user:2				(&amp;quot;Kay&amp;quot; &amp;quot;18&amp;quot; &amp;quot;male&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种方式存储用户信息的优缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原生：&lt;code&gt;set user:1:name james&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​			&lt;code&gt;set user:1:age 23&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​			&lt;code&gt;set user:1:sex boy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​	优点：简单直观，每个键对应一个值&lt;/p&gt;
&lt;p&gt;​	缺点：键数过多，占用内存多，用户信息过于分散，不用于生产环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将对象序列化存入Redis  &lt;code&gt;set user:1 serialize(userInfo)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​	优点： 编程简单&lt;/p&gt;
&lt;p&gt;​    缺点：序列化和反序列化有开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Hash类型&lt;/p&gt;
&lt;p&gt;​	优点：简单直观，使用合理可减少内存空间消耗&lt;/p&gt;
&lt;p&gt;​	缺点：要控制ziplist与hashtable两种编码转换，且hashtable会消耗更多内存erialize&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;电商购物车&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gci79x5onoj30ju128k57.jpg&#34; alt=&#34;image-20200304210814747&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;以用户id为key；商品id为filed；商品数量为value&lt;/p&gt;
&lt;p&gt;例如用户1001的购物车的相关操作：&lt;/p&gt;
&lt;p&gt;添加商品 ---&amp;gt; &lt;code&gt;hset cart:1001 10088 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;增加数量 ---&amp;gt; &lt;code&gt;hincrby cart:1001 10088 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;商品总数 ---&amp;gt;&lt;code&gt; hlen cart:1001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除商品 ---&amp;gt; &lt;code&gt;hdel cart:1001 10088&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取购物车所有商品 ---&amp;gt; &lt;code&gt;hgetall cart:1001&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rpush&lt;/code&gt;和&lt;code&gt;lpush&lt;/code&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga1031flckj31me0o2gnn.jpg&#34; alt=&#34;image-20191218172422826&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;p&gt;&lt;code&gt;rpush&lt;/code&gt;：在&lt;code&gt;list&lt;/code&gt;的尾部追加元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lpush&lt;/code&gt;：在&lt;code&gt;list&lt;/code&gt;的头部追加元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lrange key start stop&lt;/code&gt;	：返回列表&lt;code&gt;key&lt;/code&gt;中指定区间内的元素，区间以偏移量&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;stop&lt;/code&gt;指定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpush str a b c
lrange str 0 -1					(&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;)
lpush str1 a b c
lrange str1 0 -1					(&amp;quot;c&amp;quot; &amp;quot;b&amp;quot; &amp;quot;a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为有序，可以通过索引下标获取元素或某个范围内元素列表&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;llen&lt;/code&gt;  获取当前列表长度&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;lpop&lt;/code&gt; 把左边第一个元素删掉&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;rpop&lt;/code&gt; 把右边第一个元素删掉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;llen str			(3)
lpop str			(a)
rpop str			(c)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Stack	： LPUSH + LPOP  ==&amp;gt;  FILO&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Queue：LPUSH+ RPOP&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Blocking MQ ： LPUSH + BRPOP&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微博和微信公众号消息流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公众号A发微博，消息id为10018&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LPUSH msg:1001 10018&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;公众号B发微博，消息id为10086&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LPUSH msg:1001 10086&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看最新微博消息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LRANGE msg:rick 0 5&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sadd  sinter&lt;/code&gt;(求交集)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;保存多元素，与列表不一样的是&lt;strong&gt;不允许有重复元素&lt;/strong&gt;，且&lt;strong&gt;集合是无序&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1ga10bvy447j31d60o2dij.jpg&#34; alt=&#34;image-20191218173253651&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;pre&gt;&lt;code&gt;sadd user a b c					(3)
sadd user a						(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集合使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微博微信点赞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sadd like:{消息id} {用户id}&lt;/code&gt;	==&amp;gt;  点赞&lt;/p&gt;
&lt;p&gt;&lt;code&gt;srem like:{消息id} {用户id}&lt;/code&gt;	==&amp;gt;	取消点赞&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sismember like:{消息id} {用户id}&lt;/code&gt;	==&amp;gt;	检查用户是否点赞&lt;/p&gt;
&lt;p&gt;&lt;code&gt;smembers like:{消息id}&lt;/code&gt;		==&amp;gt;	获取点赞的用户列表&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scard like:{消息id}&lt;/code&gt;			==&amp;gt;	获取点赞用户数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微信小程序抽奖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sadd key {userID}&lt;/code&gt;		==&amp;gt;    点击参与抽奖&lt;/p&gt;
&lt;p&gt;&lt;code&gt;smembers key&lt;/code&gt;			 ==&amp;gt;	 查看参与抽奖所有用户&lt;/p&gt;
&lt;p&gt;&lt;code&gt;srandmember key[count](抽完后不剔除) / SPOP key [count](抽完后剔除)&lt;/code&gt;	==&amp;gt; 	抽取&lt;code&gt;count&lt;/code&gt;名中奖者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集合操作实现微博微信关注模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A关注的人：ASet:  {B,C,D}&lt;/p&gt;
&lt;p&gt;B关注的人：BSet:  {A,C,D,E}&lt;/p&gt;
&lt;p&gt;C关注的人：CSet:  {A,B,E,F}&lt;/p&gt;
&lt;p&gt;A和B的共同关注（求交集）： &lt;code&gt;SINTER ASet BSet&lt;/code&gt;	==&amp;gt; {C,D}&lt;/p&gt;
&lt;p&gt;A关注的人也关注B（列举出A关注的人是否关注B）：	&lt;code&gt;sismember CSet B sismember DSet B &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A可能认识的人（差集）：&lt;code&gt;sidff ASet BSet&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zset&#34;&gt;Zset&lt;/h3&gt;
&lt;p&gt;有序集合，常&lt;strong&gt;用于排行榜&lt;/strong&gt;，如视频网站需要对用户上传视频做排行榜，或&lt;strong&gt;点赞数与集合有联系，不能有重复的成员&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zadd zan 100 Rick
zadd zan 200 kay
zadd zan 150 Lee
zrange zan 0 -1 withscores			(&amp;quot;Rick&amp;quot; &amp;quot;100&amp;quot; &amp;quot;Lee&amp;quot; &amp;quot;150&amp;quot; &amp;quot;kay&amp;quot; &amp;quot;200&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
">Redis基础篇（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/springspringmvcmybatis-zheng-he/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;这篇文章不会教你Spring、SpringMVC、MyBatis具体的知识，而是教你如何整合这3大框架快速上手进行开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;整合的项目已同步至GitHub  ==&amp;gt; &lt;a href=&#34;https://github.com/Kay-Rick/SSM_Strat&#34;&gt;Click&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK12 (建议JDK1.8)&lt;/li&gt;
&lt;li&gt;maven-3.6.3&lt;/li&gt;
&lt;li&gt;Tomcat 9.0.24&lt;/li&gt;
&lt;li&gt;MySQL 5.7.29&lt;/li&gt;
&lt;li&gt;Spring：5.0.2.RELEASE&lt;/li&gt;
&lt;li&gt;spring-web：5.0.2.RELEASE&lt;/li&gt;
&lt;li&gt;MyBatis：3.4.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;架构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring 作为业务层，整合 SpringMVC 和 MyBatis，处理数据&lt;/li&gt;
&lt;li&gt;SpringMVC 作为表现层，显示数据&lt;/li&gt;
&lt;li&gt;MyBatis 作为持久层，与数据库交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mvnrepository.com&#34;&gt;maven仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mybatis.org/mybatis-3/&#34;&gt;MyBatis官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建maven项目&#34;&gt;创建Maven项目&lt;/h2&gt;
&lt;p&gt;根据maven提供的archetype选择webapp&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccj85r0zxj314f0lggp5.jpg&#34; alt=&#34;image-20200228232831452&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;项目名称：可以自己命名，这里统一为SpringMVC&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccj8rfylwj314f0lgwfh.jpg&#34; alt=&#34;image-20200228232909755&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccj93srkpj314f0lgt9e.jpg&#34; alt=&#34;image-20200227215902509&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在这里我们选择自己安装的maven目录和&lt;code&gt;setting.xml&lt;/code&gt;的配置文件，最好在自己的&lt;code&gt;setting.xml&lt;/code&gt;文件中配置阿里云的镜像，否则下载jar包会非常缓慢&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mirrors&amp;gt;
     &amp;lt;mirror&amp;gt;
     	&amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;
     	&amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;
     	&amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;
     	&amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
     &amp;lt;/mirror&amp;gt;
&amp;lt;/mirrors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;项目创建完成后，在右下角点 &lt;code&gt;Enable Auto-Import&lt;/code&gt;，这样IDE就会自动为我们导jar包&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccj9imcomj30qq093aak.jpg&#34; alt=&#34;image-20200228232949756&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;配置工作区目录&#34;&gt;配置工作区目录&lt;/h2&gt;
&lt;p&gt;创建完的Maven项目目录是这样的结构，接下来我们要进行完善&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjaxh0edj30c30b10sy.jpg&#34; alt=&#34;image-20200227220609312&#34; loading=&#34;lazy&#34;&gt;在&lt;/p&gt;
&lt;p&gt;main目录下，创建&lt;code&gt;java&lt;/code&gt;和&lt;code&gt;resource&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjba9ze1j30bj04f3yd.jpg&#34; alt=&#34;image-20200227220748872&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果因为IDE版本问题，创建目录没有提示的情况下，就创建两个普通的目录取名&lt;code&gt;java&lt;/code&gt;和&lt;code&gt;resource&lt;/code&gt;，然后右击创建出的目录，对应&lt;code&gt;java&lt;/code&gt;文件夹是&lt;code&gt;Source Root &lt;/code&gt;，&lt;code&gt;resource&lt;/code&gt;文件夹是&lt;code&gt;Resources Root&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjbmijcyj30mx0s10vz.jpg&#34; alt=&#34;image-20200227220954878&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;java&lt;/code&gt;目录下面创建这样几个包 &lt;code&gt;Controller&lt;/code&gt;控制器所在包、&lt;code&gt;dao&lt;/code&gt;数据库访问接口包、&lt;code&gt;entity&lt;/code&gt;对应&lt;code&gt;JavaBean&lt;/code&gt;所在包，&lt;code&gt;Service&lt;/code&gt;对应一些业务逻辑编写&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjbyg4apj30ar09smxa.jpg&#34; alt=&#34;image-20200227221521712&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;配置pomxml文件&#34;&gt;配置pom.xml文件&lt;/h2&gt;
&lt;p&gt;配置&lt;code&gt;properties&lt;/code&gt;下面的目录，方便我们对依赖&lt;code&gt;jar&lt;/code&gt;包版本的管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
    &amp;lt;spring.version&amp;gt;5.0.2.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;slf4j.version&amp;gt;1.6.6&amp;lt;/slf4j.version&amp;gt;
    &amp;lt;log4j.version&amp;gt;1.2.12&amp;lt;/log4j.version&amp;gt;
    &amp;lt;mysql.version&amp;gt;5.1.6&amp;lt;/mysql.version&amp;gt;
    &amp;lt;mybatis.version&amp;gt;3.4.5&amp;lt;/mybatis.version&amp;gt;
    &amp;lt;jackson.version&amp;gt;2.9.8&amp;lt;/jackson.version&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置&lt;code&gt;dependencies&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- spring --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.6.8&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${mysql.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- log start --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- log end --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${mybatis.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.3.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;c3p0&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;0.9.1.2&amp;lt;/version&amp;gt;
      &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- json begin --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- json end --&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置resource和webxml&#34;&gt;配置resource和Web.xml&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjdhfnmhj30wf0mmn0m.jpg&#34; alt=&#34;image-20200227222330196&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;resource&lt;/code&gt;目录下创建2个&lt;code&gt;xml&lt;/code&gt;文件和1个&lt;code&gt;properties&lt;/code&gt;的文件，分别是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext.xml&lt;/code&gt;   ===&amp;gt;  Spring的配置文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;log4j.properties&lt;/code&gt;  ===&amp;gt;  日志的相关配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;springmvc.xml&lt;/code&gt;	===&amp;gt;   SpringMVC的配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjedyz78j30b002zq2t.jpg&#34; alt=&#34;image-20200227222437061&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;applicationcontextxml&#34;&gt;ApplicationContext.xml&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;根据自己配置需要修改部分请一定看注释&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
	   http://www.springframework.org/schema/beans/spring-beans.xsd
	   http://www.springframework.org/schema/context
	   http://www.springframework.org/schema/context/spring-context.xsd
	   http://www.springframework.org/schema/aop
	   http://www.springframework.org/schema/aop/spring-aop.xsd
	   http://www.springframework.org/schema/tx
	   http://www.springframework.org/schema/tx/spring-tx.xsd&amp;quot;&amp;gt;

    &amp;lt;!--配置扫描注解，进行依赖注入--&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.rick&amp;quot;&amp;gt;
        &amp;lt;!-- 配置要忽略的注解Controller交给SpringMVC去控制 --&amp;gt;
        &amp;lt;context:exclude-filter type=&amp;quot;annotation&amp;quot; expression=&amp;quot;org.springframework.stereotype.Controller&amp;quot;/&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!--Spring整合MyBatis--&amp;gt;
    
    &amp;lt;!-- 配置数据源 根据自己的mysql具体数据库进行配置，我这里对应的ssm数据库，root用户，密码 257098 --&amp;gt;
    &amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/ssm&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;257098&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置 SqlSession 工厂 --&amp;gt;
    &amp;lt;bean id=&amp;quot;sqlSessionFactoryBean&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
        &amp;lt;!-- 引入数据源 --&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置 Dao 接口所在类--&amp;gt;
    &amp;lt;!-- 根据自己dao包所在位置进行配置 --&amp;gt;
    &amp;lt;bean id=&amp;quot;mapperScanner&amp;quot; class=&amp;quot;org.mybatis.spring.mapper.MapperScannerConfigurer&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;basePackage&amp;quot; value=&amp;quot;com.rick.dao&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
	
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;log4jproperties&#34;&gt;log4j.properties&lt;/h3&gt;
&lt;p&gt;直接复制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# Set root category priority to INFO and its only appender to CONSOLE.
#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
log4j.rootCategory=info, CONSOLE, LOGFILE

# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE

# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPatern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
t
# LOGFILE is set to be a File appender using a PatternLayout.
log4j.appender.LOGFILE=org.apache.log4j.FileAppender
log4j.appender.LOGFILE.File=d:\axis.log
log4j.appender.LOGFILE.Append=true
log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;springmvcxml&#34;&gt;springmvc.xml&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;有部分需自己修改看注释&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;!-- 扫描Controller的注解 ==&amp;gt; 对应自己的包 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.rick&amp;quot;&amp;gt;
        &amp;lt;!-- 只扫描 controller--&amp;gt;
        &amp;lt;context:include-filter type=&amp;quot;annotation&amp;quot; expression=&amp;quot;org.springframework.stereotype.Controller&amp;quot;/&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- 配置视图解析器 --&amp;gt;
    &amp;lt;bean id=&amp;quot;internalResourceViewResolver&amp;quot; class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/pages/&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.jsp&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 开启对SpringMVC注解的支持 --&amp;gt;
    &amp;lt;mvc:annotation-driven/&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;webxml&#34;&gt;web.xml&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!DOCTYPE web-app PUBLIC
 &amp;quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&amp;quot;
 &amp;quot;http://java.sun.com/dtd/web-app_2_3.dtd&amp;quot; &amp;gt;

&amp;lt;web-app&amp;gt;
  &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;

  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:ApplicationContext.xml&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;
  &amp;lt;!-- 将过滤器配置在servlet前面，否则IDE会报错 --&amp;gt;
  &amp;lt;!-- 配置过滤器，解决中文乱码问题--&amp;gt;
  &amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;!-- 字符集初始化为 UTF-8 --&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
  &amp;lt;/filter&amp;gt;

  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;

  &amp;lt;!-- 配置 spring 的监听器，默认只加载 WEB-INF 目录下的 applicationContext.xml 配置文件 --&amp;gt;
  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;

  &amp;lt;!-- 配置DispatcherServlet前端控制器--&amp;gt;
  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- 加载 springmvc.xml --&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;classpath:springmvc.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;!-- 启动服务器，加载该servlet --&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;

  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在配置web.xml的时候这里注意几个点根据自己的命名来确定：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjgbyo7jj316505zdgi.jpg&#34; alt=&#34;image-20200228134733041&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjgj60v9j31dh0dwjtl.jpg&#34; alt=&#34;image-20200228134902457&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;创建数据库表-实体类&#34;&gt;创建数据库表、实体类&lt;/h2&gt;
&lt;p&gt;在MySQL数据库管理工具中运行以下SQL创建数据库（该数据库定义了主键递增）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE ssm;
USE ssm;
CREATE TABLE user(
	id int primary key auto_increment,
	name varchar(20),
	age int 
);
INSERT INTO user(name,age) VALUES(&#39;aaa&#39;,12);
INSERT INTO user(name,age) VALUES(&#39;bbb&#39;,34);
INSERT INTO user(name,age) VALUES(&#39;ccc&#39;,56);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;entity&#34;&gt;entity&lt;/h3&gt;
&lt;p&gt;在entity包下创建User类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.entity;

/**
 * @Author: Rick
 * @Date: 2020/2/28 13:55
 * @Description:
 */
public class User {
    private Integer id;
    private String name;
    private Integer age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, age=&amp;quot; + age +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dao&#34;&gt;dao&lt;/h3&gt;
&lt;p&gt;dao包下创建数据库访问接口UserDao，并声明注解 @Repository交由Spring进行管理，声明@Mapper 对应MyBatis的SqlMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.dao;

import com.rick.entity.User;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * @Author: Rick
 * @Date: 2020/2/28 13:58
 * @Description:
 */
@Repository
@Mapper
public interface UserDao {

    @Insert(&amp;quot;insert into user(name,age) values(#{name},#{age})&amp;quot;)
    public void insertUser(User user);

    @Select(&amp;quot;select * from user&amp;quot;)
    public List&amp;lt;User&amp;gt; queryAll();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Service&lt;/code&gt;包下面创建接口&lt;code&gt;UserService&lt;/code&gt;和实现类&lt;code&gt;UserServiceImp&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjhbsv6tj30bc02wa9x.jpg&#34; alt=&#34;image-20200228140845755&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;UserService&lt;/code&gt;中定义逻辑接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.Service;

import com.rick.entity.User;

import java.util.List;

/**
 * @Author: Rick
 * @Date: 2020/2/28 14:04
 * @Description:
 */
public interface UserService {
    public void insertUser(User user);
    public List&amp;lt;User&amp;gt; queryAll();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现类&lt;code&gt;UserServiceImp&lt;/code&gt;声明注解&lt;code&gt;@Service&lt;/code&gt;交由Spring管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.Service.ServiceImp;

import com.rick.Service.UserService;
import com.rick.dao.UserDao;
import com.rick.entity.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * @Author: Rick
 * @Date: 2020/2/28 14:06
 * @Description:
 */
@Service
public class UserServiceImp implements UserService {
    @Autowired
    private UserDao userDao;

    @Override
    public void insertUser(User user) {
        userDao.insertUser(user);
        System.out.println(&amp;quot;插入User后：&amp;quot;);
        System.out.println(userDao.queryAll());
    }

    @Override
    public List&amp;lt;User&amp;gt; queryAll() {
        System.out.println(&amp;quot;Service查询全部数据：&amp;quot;);
        System.out.println(userDao.queryAll());
        return userDao.queryAll();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;controller&#34;&gt;Controller&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;UserController&lt;/code&gt;声明注解 &lt;code&gt;@Controller&lt;/code&gt;交由Spring管理，该类下面第一级路由信息&lt;code&gt;@RequestMapping(&amp;quot;/User&amp;quot;) @ResponseBody&lt;/code&gt;使方法的返回的数据为&lt;code&gt;JSON&lt;/code&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.Controller;

import com.rick.Service.ServiceImp.UserServiceImp;
import com.rick.entity.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @Author: Rick
 * @Date: 2020/2/28 14:15
 * @Description:
 */
@Controller
@RequestMapping(&amp;quot;/User&amp;quot;)
@ResponseBody
public class UserController {
    @Autowired
    private UserServiceImp userServiceImp;

    @RequestMapping(&amp;quot;/insert&amp;quot;)
    public String insertUser(User user){
        userServiceImp.insertUser(user);
        return user.toString();
    }

    @RequestMapping(&amp;quot;/getAll&amp;quot;)
    public String getAll(){
        return userServiceImp.queryAll().toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置tomcat服务器&#34;&gt;配置Tomcat服务器&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjijiamvj30d301zt8i.jpg&#34; alt=&#34;image-20200228142306310&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjiso3gxj30gn0ny0u3.jpg&#34; alt=&#34;image-20200228142331031&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjj1oiixj311d0ni0ti.jpg&#34; alt=&#34;image-20200228142443115&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;选择Artifact&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjjepvs3j30b603dq2r.jpg&#34; alt=&#34;image-20200228142458910&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjjm8eewj30gk0h7mxe.jpg&#34; alt=&#34;image-20200228142550819&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在这里可以配置整个这个SpringMVC项目的URL，默认是&lt;code&gt;http://localhost:8080/SpringMVC_war/&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjk3n0pcj30pp0ef3ym.jpg&#34; alt=&#34;image-20200228142613317&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjkb0vimj30pn0k4gmj.jpg&#34; alt=&#34;image-20200228142748311&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;启动项目&#34;&gt;启动项目&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjkijhzej30mu05g0st.jpg&#34; alt=&#34;image-20200228143009892&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;启动后先是自动跳转到&lt;code&gt;index.jsp&lt;/code&gt;页面下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjkpf113j30ka06udfy.jpg&#34; alt=&#34;image-20200228143555807&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;查询&#34;&gt;查询&lt;/h3&gt;
&lt;p&gt;根据自己配置的路由信息即可进行查询，这里就以&lt;code&gt;JSON&lt;/code&gt;数据的格式返回&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjkwqx1ej30s904p0sx.jpg&#34; alt=&#34;image-20200228143724347&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;插入&#34;&gt;插入&lt;/h3&gt;
&lt;p&gt;由于我们定义了自增主键id，因此插入数据库中的数据&lt;code&gt;id&lt;/code&gt;是根据数据库自增的，并不是&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjl6ek34j30ml04cwem.jpg&#34; alt=&#34;image-20200228144522652&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;至此，一个SSM的项目就可以运行起来，但仍有一功能不够完善，还需一些额外配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;在项目下创建一个存放自定义异常处理类的包 &lt;code&gt;Exception&lt;/code&gt;和&lt;code&gt;config&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjmj4543j30bn05q747.jpg&#34; alt=&#34;image-20200228153208748&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;Exception&lt;/code&gt;包下面创建异常处理类信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.Exception;

/**
 * @Author: Rick
 * @Date: 2020/2/28 15:12
 * @Description: 定义异常信息
 */
public class SysException extends Exception {
    private String message;

    public SysException(String message) {
        this.message = message;
    }

    public SysException() {
        
    }

    @Override
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;config&lt;/code&gt;包下面创建类进行异常统一处理跳转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.config;

import com.rick.Exception.SysException;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @Author: Rick
 * @Date: 2020/2/28 15:33
 * @Description: 统一异常处理
 */
@Component
public class MyExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
        SysException se = null;
        if (e instanceof SysException){
            se = (SysException)e;
        }else {
            se = new SysException(&amp;quot;系统正在维护中&amp;quot;);
        }
        System.out.println(se.getMessage());
        ModelAndView mv = new ModelAndView();
        mv.addObject(&amp;quot;errorMsg&amp;quot;,se.getMessage());
        // 指定跳转到 WEB-INF/pages/error.jsp
        mv.setViewName(&amp;quot;error&amp;quot;);
        return  mv;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建&lt;code&gt;error.jsp&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjo21vuwj30b604lt8n.jpg&#34; alt=&#34;image-20200228155033517&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: Rick
  Date: 2020/2/28
  Time: 15:38
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%--不忽略EL表达式--%&amp;gt;
&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Error&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Error&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;${errorMsg}&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;springmvc.xml&lt;/code&gt;中配置异常处理器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 对应自己写的异常类 --&amp;gt; 
&amp;lt;bean id=&amp;quot;sysException&amp;quot; class=&amp;quot;com.rick.Exception.SysException&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们&lt;code&gt;Controller&lt;/code&gt;中方法在调用时抛出异常就会被捕获&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/hello&amp;quot;)
public void hello(){
    int a = 10/0;
    System.out.println(a);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjoaslz6j30jk05l74d.jpg&#34; alt=&#34;image-20200228160859287&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;配置过滤器和拦截器&#34;&gt;配置过滤器和拦截器&lt;/h2&gt;
&lt;p&gt;通过SpringMVC配置过滤器放行静态资源&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjoocqmrj30a204za9z.jpg&#34; alt=&#34;image-20200228172146426&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;springmvc.xml&lt;/code&gt;中进行配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--配置哪些资源不拦截--&amp;gt;
&amp;lt;mvc:resources mapping=&amp;quot;/js/**&amp;quot; location=&amp;quot;/js/&amp;quot;/&amp;gt;
&amp;lt;mvc:resources mapping=&amp;quot;/images/**&amp;quot; location=&amp;quot;/images/&amp;quot;/&amp;gt;
&amp;lt;mvc:resources mapping=&amp;quot;/css/**&amp;quot; location=&amp;quot;/css/&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置拦截器（AOP思想）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;config&lt;/code&gt;包下面创建&lt;code&gt;MyInterceptor&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.config;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @Author: Rick
 * @Date: 2020/2/28 16:55
 * @Description: 拦截器
 */
public class MyInterceptor implements HandlerInterceptor {
    /**
     * Controller方法执行之前的预处理，决定是否放行，可用于登录拦截是否放行
     * @param request
     * @param response
     * @param handler
     * @return 是否放行(true/false)
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&amp;quot;preHandle执行了---Controller执行之前&amp;quot;);
//        决定是否拦截跳转
//        request.getRequestDispatcher(&amp;quot;/WEB-INF/pages/error.jsp&amp;quot;).forward(request,response);
        return true;
    }

    /**
     * Controller方法执行之后，DispatcherServlet视图渲染之前执行，可以对ModelAndView进行操作
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&amp;quot;postHandle执行了---Controller方法执行之后，DispatcherServlet视图渲染之前执行&amp;quot;);
        //        request.getRequestDispatcher(&amp;quot;/WEB-INF/pages/error.jsp&amp;quot;).forward(request,response);
    }

    /**
     * DispatcherServlet视图渲染结束后执行，一般进行资源的释放
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&amp;quot;afterCompletion执行了---最后&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;springmvc.xml&lt;/code&gt;中进行配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mvc:interceptors&amp;gt;
    &amp;lt;mvc:interceptor&amp;gt;
        &amp;lt;!--需要拦截的方法--&amp;gt;
        &amp;lt;mvc:mapping path=&amp;quot;/User/**&amp;quot;/&amp;gt;
        &amp;lt;!--不拦截的方法 &amp;lt;mvc:exclude-mapping path=&amp;quot;&amp;quot;/&amp;gt;--&amp;gt;

        &amp;lt;!--配置拦截器对象--&amp;gt;
        &amp;lt;bean class=&amp;quot;com.rick.config.MyInterceptor&amp;quot;/&amp;gt;
	&amp;lt;/mvc:interceptor&amp;gt;
	&amp;lt;!-- 配置多个拦截器时，按顺序配置即可 --&amp;gt;
&amp;lt;/mvc:interceptors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我执行&lt;code&gt;User&lt;/code&gt;中方法时就可以看到拦截的效果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjpgn6hsj30vk0a1q3n.jpg&#34; alt=&#34;image-20200228173013784&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;mybatis中使用mapperxml配置&#34;&gt;MyBatis中使用Mapper.xml配置&lt;/h2&gt;
&lt;p&gt;对于简单&lt;code&gt;SQL&lt;/code&gt;语句来说，注解使代码显得更加简洁,使用&lt;code&gt;@Mapper&lt;/code&gt;和&lt;code&gt;@Repository&lt;/code&gt;比较方便，但当我们涉及到一些复杂&lt;code&gt;SQL&lt;/code&gt;语句需要传参和动态&lt;code&gt;SQL&lt;/code&gt;的时候，注解就会显得比较麻烦，此时应该采用&lt;code&gt;xml&lt;/code&gt;的语句映射方式&lt;/p&gt;
&lt;p&gt;我们在&lt;code&gt;dao&lt;/code&gt;下面创建测试的接口&lt;code&gt;UserTestDao&lt;/code&gt;  &lt;strong&gt;!!!注意：我们不需要在接口上声明任何注解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.rick.dao;

import com.rick.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * @Author: Rick
 * @Date: 2020/2/28 18:01
 * @Description:
 */
public interface UserTestDao {
    public void insertUser(User user);
    public List&amp;lt;User&amp;gt; queryAll();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;resource&lt;/code&gt;目录下面创建&lt;code&gt;mapper&lt;/code&gt;目录并在下面创建&lt;code&gt;UserTestDao.xml&lt;/code&gt; 和&lt;code&gt;mybatis.xml&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjr296n6j30c706zdfv.jpg&#34; alt=&#34;image-20200228224328615&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;mybatis.xml&lt;/code&gt;	==&amp;gt; 这里面的&lt;code&gt;settings&lt;/code&gt; 具体细节&lt;strong&gt;可查官方文档进行配置&lt;/strong&gt;，为了简便，我们这里就不做配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;

&amp;lt;configuration&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;UserMapper.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;com.rick.dao.UserTestDao&amp;quot;&amp;gt;
    &amp;lt;!--
		mapper接口的方法名称要和mapper映射文件的statement的id一致。
		mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个。
		mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致。
	 --&amp;gt;
    &amp;lt;!--parameterType可以省略--&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; parameterType=&amp;quot;com.rick.entity.User&amp;quot;&amp;gt;
        insert into user(name, age) values (#{name}, #{age})
    &amp;lt;/insert&amp;gt;

    &amp;lt;!--注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。--&amp;gt;
    &amp;lt;select id=&amp;quot;queryAll&amp;quot; resultType=&amp;quot;com.rick.entity.User&amp;quot;&amp;gt;
        select * from user
    &amp;lt;/select&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意在配置对象参数和返回参数时，一定要配上java目录下面的引用，我这里是 com.rick.entity.User，若只写User，那么在编译时会找不到User类而报错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ApplicationContext.xml中配置SqlSession 工厂加入mapperLocations和configLocation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 配置 SqlSession 工厂 --&amp;gt;
&amp;lt;bean id=&amp;quot;sqlSessionFactoryBean&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
    &amp;lt;!-- 引入数据源 --&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;mapperLocations&amp;quot; value=&amp;quot;classpath:mapper/*.xml&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:mybatis.xml&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，&lt;code&gt;UserTestDao&lt;/code&gt;便与&lt;code&gt;UserDao&lt;/code&gt;的功能一样了，只不过&lt;code&gt;UserTsetDao&lt;/code&gt;是通过mapper和xml进行配置，&lt;code&gt;UserDao&lt;/code&gt;直接通过注解方式进行配置，各有优点，根据实际情况合理选用一种&lt;/p&gt;
&lt;h2 id=&#34;配置jdbc事务&#34;&gt;配置JDBC事务&lt;/h2&gt;
&lt;p&gt;配置&lt;code&gt;ApplicationContext.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--开启Spring的事务--&amp;gt;
    &amp;lt;!--配置事务管理器--&amp;gt;
    &amp;lt;bean id=&amp;quot;dataSourceTransactionManager&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--启用Spring事务的注解功能--&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&amp;quot;dataSourceTransactionManager&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后们就可以在业务&lt;code&gt;Service&lt;/code&gt;层进行声明注解&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gccjs9a31zj30nj03r749.jpg&#34; alt=&#34;image-20200228230539790&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;至此，一个较为完整的SSM整合基本完成~&lt;/p&gt;
">Spring、SpringMVC、MyBatis整合</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/dong-tai-gui-hua-ru-men-pian/"" data-c="
          &lt;h2 id=&#34;什么是动态规划问题&#34;&gt;什么是动态规划问题？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/Gswf1P6n0Gh9NkVBzDc1zg&#34;&gt;通过金矿故事介绍动态规划（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/P9AOcnjK10siUITIiOr7BQ&#34;&gt;通过金矿故事介绍动态规划（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过金矿故事我们可以了解到动态规划问题是一种用来解决一类&lt;strong&gt;最优化问题&lt;/strong&gt;的算法思想，就是将一个复杂的问题分解成若干个子问题，通过&lt;strong&gt;综合子问题的最优解来得到原来问题的最优解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;解决动态规划问题的核心在于：&lt;strong&gt;找到重复子问题，记住之前做的事&lt;/strong&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何理解动态规划中的概念&#34;&gt;如何理解动态规划中的概念？&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;重叠子问题&#34;&gt;重叠子问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个问题可以被分解为若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有“重叠子问题”，动态规划通过记录重叠子问题的解，来使下次碰到相同的子问题时直接使用之前记录的结果，依次避免大量重复计算。因此，一个问题必须拥有重叠子问题，才能使用动态规划去解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们从熟悉的斐波那契数列来理解重叠子问题&lt;/p&gt;
&lt;p&gt;初学者在接触斐波那契数列的时候，可能一般的写法是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int F(int n){
  if(n == 0 || n == 1) return 1;
  else return F(n - 1) + F(n - 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里就是&lt;strong&gt;不断地分解问题为子问题   ==&amp;gt;  动态规划问题必须要满足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而实际上，这个递归会涉及到很多重复的计算。&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybpgy1gc6eq02kwpj30tc0kgtai.jpg&#34; alt=&#34;image-20200223161917205&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;br&gt;
&lt;p&gt;当&lt;code&gt;n = 5&lt;/code&gt;的时候，可以得到&lt;code&gt;F(5) = F(4) + F(3)&lt;/code&gt;，接下来在计算&lt;code&gt;F(4)&lt;/code&gt;的时候，又会有&lt;code&gt;F(4) = F(3) + F(2)&lt;/code&gt;，这个时候我发现&lt;code&gt;F(3)&lt;/code&gt;被重复计算，可以推知，如果&lt;code&gt;n&lt;/code&gt;非常大，重复计算的次数将难以想象，实际复杂度会达到&lt;strong&gt;O(2&lt;sup&gt;n&lt;/sup&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了避免重复计算，我们可以开辟一个一维数组&lt;code&gt;dp&lt;/code&gt;，保存已经计算过的结果，用&lt;code&gt;dp[n&lt;/code&gt;]记录&lt;code&gt;F(n)&lt;/code&gt;的结果，并用&lt;code&gt;dp[n] = -1&lt;/code&gt; 表示当前还没有被计算过 ==&amp;gt; 就是我们说的&lt;strong&gt;做备忘录，记住之前做的事&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int dp[MAXN];

int F(int n){
  if(n == 0 || n == 1) return 1;		// 递归边界
  if(dp[n] != -1) return dp[n];			// 已经计算过，直接返回结果
  else{
    dp[n] = F(n - 1) + F(n - 2);
    return dp[n];
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;最优子结构&#34;&gt;最优子结构&lt;/h3&gt;
&lt;p&gt;我们通过&lt;strong&gt;数塔问题&lt;/strong&gt;来理解&amp;quot;最优子结构&amp;quot;这个概念&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybpgy1gc6gwrqvm1j30pu0ikq58.jpg&#34; alt=&#34;image-20200223173450683&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;其中第一层有一个数字，第二层有两个数字······第n层有n个数字，现在从第一层走到第n层，每次只能走向下一层连接的两个数字中的一个，问：最后路径上所有数字相加后得到的和最大是多少？&lt;/p&gt;
&lt;p&gt;如果按照题目描述，我们可以用二维数组&lt;code&gt;f&lt;/code&gt;，其中&lt;code&gt;f[i][j]&lt;/code&gt; 存放第&lt;code&gt;i&lt;/code&gt;层的第&lt;code&gt;j&lt;/code&gt;个数字，那么&lt;code&gt; f[1][1] = 5,f[2][1] = 8 ··· f[5][5] = 4&lt;/code&gt;此时，如果我们尝试穷举所有路径，然后记录路径上数字和的最大值，那么由于每层中每个数字都有两个分支，时间复杂度为O(2 &lt;sup&gt;n&lt;/sup&gt;)，这样的时间复杂度显然是我们不可以接受的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于上面的考虑，我们不妨令&lt;code&gt;dp[i][j]&lt;/code&gt; 表示从第i行第j个数字出发的到达最底层所有路径中能得到的最大和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以归纳得到一个信息：如果要求出&lt;code&gt;dp[i][j] &lt;/code&gt;，那么一定要先求出它的两个子问题，从位置&lt;code&gt;(i + 1, j)&lt;/code&gt;到达最底层的最大和&lt;code&gt;dp[i + 1][j] &lt;/code&gt;和 位置&lt;code&gt;(i + 1,j + 1)&lt;/code&gt;到达最底层的最大和&lt;code&gt;dp[i + 1][j + 1]&lt;/code&gt; ，即进行一次决策&lt;/p&gt;
&lt;center&gt;&lt;b&gt;dp[i][j] = max(dp [i + 1][j] ,dp [i + 1][j + 1] ) + f[i][j]&lt;/b&gt;&lt;/center&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt;称为&lt;strong&gt;问题的状态&lt;/strong&gt;，上面的式子称为&lt;strong&gt;状态转移方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现，状态&lt;code&gt;dp[i][j]&lt;/code&gt;只与第&lt;code&gt;i + 1&lt;/code&gt;层状态有关，而与其他层状态无关，那么这样的转移什么时候能够结束呢？我们可以发现在数塔的最后一层的&lt;code&gt;dp&lt;/code&gt;值总是等于元素本身&lt;/p&gt;
&lt;p&gt;这样就可以从最底层各位置的&lt;code&gt;dp&lt;/code&gt;值开始，不断地往上求出每一层各位置的&lt;code&gt;dp&lt;/code&gt;值，最后就会得到我们想要的&lt;code&gt;dp[1][1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;分析到这里，我们的问题基本得到解决，在这个过程中我们发现解决问题的关键在找到&lt;strong&gt;状态转移的方程&lt;/strong&gt;，如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有&lt;strong&gt;最优子结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划，&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;子问题独立&#34;&gt;子问题独立&lt;/h3&gt;
&lt;p&gt;想一想上面数塔问题中，我们在分解成重叠子问题的时候，状态&lt;code&gt;dp[i][j]&lt;/code&gt;只与第&lt;code&gt;i + 1&lt;/code&gt;层状态有关，而与其他层状态无关，这里就是子问题独立&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;边界&#34;&gt;边界&lt;/h3&gt;
&lt;p&gt;当我们找到数塔问题的状态转移方程，那么这样的转移什么时候能够结束呢？我们可以发现在数塔的最后一层的&lt;code&gt;dp&lt;/code&gt;值总是等于元素本身，在这个时候就可以进行返回了，这里就是我们所说的边界&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何解决动态规划问题&#34;&gt;如何解决动态规划问题？&lt;/h2&gt;
&lt;p&gt;当我们理解了动态规划中的一些重要概念以后，解决动态规划问题可以按下面的步骤去思考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造问题所对应的过程&lt;/li&gt;
&lt;li&gt;思考过程的最后一个步骤，看看有哪些选择情况&lt;/li&gt;
&lt;li&gt;找到最后一步的子问题，确保符合**“子问题重叠”，把子问题中不相同的地方设置为参数**&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使得子问题符合“最优子结构”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;找到边界，考虑边界的各种处理方式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考虑如何做备忘录&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分析所需时间是否满足要求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写出转移方程式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;我们再进一步提炼，得到解题中最为重要的&lt;strong&gt;四步法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;问题拆解，找到问题之间的具体联系&lt;/li&gt;
&lt;li&gt;状态定义&lt;/li&gt;
&lt;li&gt;递推方程推导&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们按照这四个步骤来实现数塔问题&lt;/p&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题拆解&lt;/p&gt;
&lt;p&gt;这里的总问题是求出最大的路径和，路径是这里的分析重点，路径是由一个个元素组成的，&lt;code&gt;[i][j]&lt;/code&gt; 位置的元素，经过这个元素的路径肯定也会经过 &lt;code&gt;[i - 1][j]&lt;/code&gt; 或者 &lt;code&gt;[i - 1][j - 1]&lt;/code&gt;，因此经过一个元素的路径和可以通过这个元素上面的一个或者两个元素的路径和得到。&lt;/p&gt;
&lt;p&gt;也就是我们要求得&lt;code&gt;[1][1]&lt;/code&gt;位置元素一定会经过&lt;code&gt;[2][1]&lt;/code&gt;或者&lt;code&gt;[2][2]&lt;/code&gt;，这样每一步递推下去，我们就会得到最终最大的路径和。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;状态定义&lt;/p&gt;
&lt;p&gt;状态的定义一般会和问题需要求解的答案联系在一起，这里其实有两种方式，一种是考虑路径从上到下，另外一种是考虑路径从下到上，因为元素的值是不变的，所以路径的方向不同也不会影响最后求得的路径和，如果是从上到下，你会发现，在考虑下面元素的时候，起始元素的路径只会从&lt;code&gt;[i - 1][j]&lt;/code&gt; 获得，每行当中的最后一个元素的路径只会从 &lt;code&gt;[i - 1][j - 1]&lt;/code&gt; 获得，中间二者都可，这样不太好实现，&lt;strong&gt;因此这里考虑从下到上的方式&lt;/strong&gt;，状态的定义就变成了 “&lt;strong&gt;最后一行元素到当前元素的最大路径和&lt;/strong&gt;”，对于 &lt;code&gt;[0][0]&lt;/code&gt; 这个元素来说，最后状态表示的就是我们的最终答案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;递推方程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dp[i][j] = max(dp[i + 1][j] ,dp[i + 1][j + 1] ) + f[i][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;p&gt;这里初始化时，我们需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
 * @Author: Rick
 * @Email: Kay_Rick@outlook.com
 * @Date: 2020-02-23 20:23:31
 * @Last Modified by: Rick
 * @Last Modified time: 2020-02-23 20:41:05
 * @Description: 动态规划 数塔问题
 */
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int maxn = 1000;
int f[maxn][maxn], dp[maxn][maxn];

int main(void){
    int n;  // 层数
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    // 输入数塔
    for (int i = 1; i &amp;lt;= n; i++)
    {
        for (int j = 1; j &amp;lt;= i; j++)
        {
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;f[i][j]);
        }
    }
    // 最后一行元素填入状态数组 ==&amp;gt; 边界
    for (int k = 1; k &amp;lt;= n; k++)
    {
        dp[n][k] = f[n][k];
    }
    // 从第n-1层不断往上计算出dp[i][j]
    for (int i = n - 1; i &amp;gt;= 1; i--)
    {
        for (int j = 1; j &amp;lt;= i; j++)
        {
            // 状态转移方程
            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + f[i][j];
        }
    }
    printf(&amp;quot;%d\n&amp;quot;, dp[1][1]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5
5
8 3
12 7 16
4 10 11 6
9 5 3 9 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;44
&lt;/code&gt;&lt;/pre&gt;
">动态规划（入门篇）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/ccji-chu-zheng-li-san/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇主要总结C++中的结构体、标准模板库(STL)、algorithm头文件下常用函数和C++11的部分新特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;结构体&#34;&gt;结构体&lt;/h2&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Stu
{
    int id;
    char gender;
    char name[20];
};
struct Stu stu1;	//	C语言定义时必须要声明struct
Stu stu2;			//  C++可以直接声明
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对链表节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct node
{
    node n;		/*** WRONG ***/   // 不能定义本身node类型
    Stu stu;	// Right
    node* next;		//  可以定义node*型指针变量
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;访问&#34;&gt;访问&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Stu
{
    int id;
    char name[20];
    Stu* next;
} stu, *p;

// 访问普通结构体变量
stu.id;
stu.name;
stu.next;
// 访问结构体指针变量
(*p).id;
(*p).name;
(*p).next;

p-&amp;gt;id;
p-&amp;gt;name;
p-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;stu.id = 1;
stu.gender = &#39;M&#39;;

scanf(&amp;quot;%d %c&amp;quot;,&amp;amp;stu.id, &amp;amp;stu.gender);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;strong&gt;构造函数来进行初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不需要写返回类型，且函数名与结构体名相同，每个结构体都有个默认的构造函数，&lt;strong&gt;如果自己重新定义了构造函数，则不能不经初始化就定义结构体变量   ==&amp;gt; 同Java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
 struct Stu
 {
     int id;
     char gender;
     Stu(){}
     Stu(int _id, char _gender){
         id = _id;
         gender = _gender;
     }
 };

int main(void) {
	Stu stu1(1,&#39;M&#39;);
	cout &amp;lt;&amp;lt; stu1.id &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; stu1.gender &amp;lt;&amp;lt; endl;	 1 M	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;标准模板库stl&#34;&gt;标准模板库(STL)&lt;/h2&gt;
&lt;h3 id=&#34;string&#34;&gt;string&lt;/h3&gt;
&lt;p&gt;string：字符串  ==&amp;gt;  头文件 &lt;code&gt;#include&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义string&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string str;
string str = &amp;quot;abcd&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问遍历&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int main(void) {
    string str1 = &amp;quot;abcdef&amp;quot;;
    for (int i = 0; i &amp;lt; str1.length(); i++)
    {
      printf(&amp;quot;%c&amp;quot;,str1[i]);	// abcdef
    }
      // 迭代器访问 ==&amp;gt; 同vector
    for (string :: iterator it = str1.begin(); it != str1.end(); it++)
    {
      printf(&amp;quot;%c&amp;quot;, *it);		// abcdef
    }

    /* 读入和输出整个字符串，只能用cin和cout */
    string str2;
    cin &amp;gt;&amp;gt; str2;	
      getline(cin, str2); 		// 读取一行的字符串，包括空格
    cout &amp;lt;&amp;lt; str2;

    /*将字符串转换成字符数组输出*/
    string str3 = &amp;quot;abcd&amp;quot;;
    printf(&amp;quot;%s\n&amp;quot;, str3.c_str());
    return 0;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// + 	==&amp;gt;	字符串拼接
string str1 = &amp;quot;abc&amp;quot;, str2 = &amp;quot;def&amp;quot;;
string str3 = str1 + str2;	// &amp;quot;abcdef&amp;quot;
// == != &amp;lt; &amp;gt;  ==&amp;gt; 字符串比较(字典序)

// length()/size()
string str = &amp;quot;abcdef&amp;quot;;
str.size();		// 6
str.length();	// 6

// clear()	==&amp;gt;	清空string中的数据
str.clear();

// substr()	==&amp;gt;	子串
string str = &amp;quot;abcdef&amp;quot;;
string s2 = str.substr(4); 		//  ef  表示从下标4开始一直到结束
string s3 = str.substr(2, 3); 	// cde  表示从下标2开始，3个字符

//find()	==&amp;gt;	查找子串
int main(void) {
    string str = &amp;quot;Thank you for your smile.&amp;quot;;
    string str1 = &amp;quot;you&amp;quot;;
    string str2 = &amp;quot;me&amp;quot;;
      /* str.find(str1),当str1是str的子串时，返回其在str中第一次出现的位置
         如果str1不是str的子串，则返回string::npos */
    if (str.find(str1) != string :: npos)
    {
      cout &amp;lt;&amp;lt; str.find(str1) &amp;lt;&amp;lt; endl;		// 6
    }
      /* str.find(str1, pos),从str的第pos号位开始匹配str1，返回值与上相同 */
    if (str.find(str1, 7) != string::npos)
    {
      cout &amp;lt;&amp;lt; str.find(str1, 7) &amp;lt;&amp;lt; endl;	// 14
    }
    if (str.find(str2) != string::npos)
    {
      cout &amp;lt;&amp;lt; str.find(str2) &amp;lt;&amp;lt; endl;
    }
    else
    {
      cout &amp;lt;&amp;lt; &amp;quot;I know there is no position for me.&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}

// insert()		==&amp;gt;	字符串插入
string str = &amp;quot;abcdef&amp;quot;;
string str2 = &amp;quot;123&amp;quot;;
/* insert(pos,string) ==&amp;gt; 从pos号位置插入字符串string */
str.insert(3, str2);	// str的第3号位置插入字符串str2
cout &amp;lt;&amp;lt; str;			// abc123def
/* insert(it,it2,it3) ==&amp;gt; it为原字符串要插入的位置，it2和it3为待插字符串首尾迭代器(左闭右开) */
str.insert(str.begin() + 3, str2.begin() + 1,str2.end());	
cout &amp;lt;&amp;lt; str;			// abc23def

// replace()	==&amp;gt; 替换子串
string str = &amp;quot;Maybe you will turn around.&amp;quot;;
string str1 = &amp;quot;will not&amp;quot;;
string str2 = &amp;quot;surely&amp;quot;;
/* str.replace(pos,len,str1) 将str从pos号位置开始、长度为len的子串替换为str1 */
str.replace(10, 4, str1);		//Maybe you will not turn around.
/* str.replace(it,it1,it2) 将str的迭代器[it1,it2)范围的子串替换为str2 */
str.replace(str.begin(), str.begin() + 5, str2);	//surely you will not turn around.

// erase()	==&amp;gt;	删除单个元素、删除一个区间内的所有元素
string str = &amp;quot;abcdef&amp;quot;;
/* str.erase(it)删除单个元素 */
str.erase(str.begin() + 4);		// abcdf
/* str.erase(first,last) 删除区间元素[first,last) */
str.erase(str.begin() + 2,str.end() - 1);	//	abf
/* str.erase(pos,length) 删除pos号位开始length长度*/
str.erase(0,2);					// f
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vector&#34;&gt;vector&lt;/h3&gt;
&lt;p&gt;vector： 变长数组   ==&amp;gt; 头文件&lt;code&gt;#include&amp;lt;vector&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&amp;lt;typename&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义vector&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 直接定义长度为10的int数组，默认这10个元素值都为0
vector&amp;lt;int&amp;gt; v(10); 

// 先定义一个vector变量量v1，然后将长度resize为8，默认这8个元素都是0
vector&amp;lt;int&amp;gt; v1;
v1.resize(8); 

// 在定义的时候就可以对vector变量进行初始化 把100长度的数组中所有的值都初始化为9
vector&amp;lt;int&amp;gt; v3(100, 9);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问遍历元素&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 通过下标访问
vector&amp;lt;int&amp;gt; vi(10);		//可一开始定义大小，也可不定义
int n = vi[index];		// index在 0 ~ vi.size() - 1

// 迭代器访问1 (迭代器可理解为指针)
// 迭代器 it 的类型就为 vector&amp;lt;int&amp;gt; ::iterator ,vi.begin()是取首元素地址
// 访问元素的值要对it 指针取值，要在前面加星号 所以是cout &amp;lt;&amp;lt; *it;
vector&amp;lt;int&amp;gt; ::iterator it = vi.begin();
for (int i = 0; i &amp;lt; 10; i++){
	cout &amp;lt;&amp;lt; *(it + i) &amp;lt;&amp;lt; &amp;quot; &amp;quot;;	 // 这里可以看出vi[i]和*(it + i)是等价的
}
   
// 迭代器访问2
for (vector&amp;lt;int&amp;gt;::iterator it = vi.begin(); it != vi.end(); it++){
	cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; vi;

// push_back()  ==&amp;gt;  vector后面追加元素x
for (int i = 0; i &amp;lt; 10; i++){
	vi.push_back(i);	// 0 1 2 3 4 5 6 7 8 9
}

// pop_back()   ==&amp;gt;  删除vector的伪元素
vi.pop_back();		// 删除vi尾元素3

// size()	==&amp;gt;  vector中元素个数
vi.size();		// 9

// begin()  ==&amp;gt;  vector中首元素地址
vi.begin();

// end()	==&amp;gt;  vector中*****最后一个元素的后一个地址*****

// clear()  ==&amp;gt;  清空vector中所有元素
vi.clear();		// vi清空

// insert()	==&amp;gt; 向vector的任意迭代器it处插入元素x，时间复杂度 O(N)
vector&amp;lt;int&amp;gt; vi;
for (int i = 0; i &amp;lt; 10; i++){
	vi.push_back(i);
}
vi.insert(vi.begin() + 2, -1);		// 将 -1 插入vi[2]的位置
for (int i = 0; i &amp;lt; vi.size(); i++){
	cout &amp;lt;&amp;lt; vi[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;		// 0 1 -1 2 3 4 5 6 7 8 9
}

// erase()	==&amp;gt;  删除单个元素、删除一个区间(左闭右开)所有元素
vector&amp;lt;int&amp;gt; vi;
for (int i = 0; i &amp;lt; 10; i++){
	vi.push_back(i);
}
/* 删除单个元素 */
vi.erase(vi.begin() + 2);	// 删除vi[2]
for (int i = 0; i &amp;lt; vi.size(); i++){
	cout &amp;lt;&amp;lt; vi[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;	// 0 1 3 4 5 6 7 8 9
}
/* 删除一个区间内元素 */
vi.erase(vi.begin() + 1, vi.begin() + 4);	// 删除 vi[1] vi[2] vi[3]
for (int i = 0; i &amp;lt; vi.size(); i++){
	cout &amp;lt;&amp;lt; vi[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;	// 0 5 6 7 8 9
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybply1gc35lllp9tj311e0a47kv.jpg&#34; alt=&#34;image-20200220204634323&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;
&lt;p&gt;set为集合，&lt;strong&gt;自动内部有序且不含重复元素的容器(内部红黑树实现，元素本身有序)&lt;/strong&gt;  ==&amp;gt;  头文件 &lt;code&gt;#include&amp;lt;set&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set&amp;lt;typename&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义set&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;set &amp;lt;int&amp;gt; name;
set &amp;lt;double&amp;gt; name;
set &amp;lt;int&amp;gt; a[100];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问遍历元素  ==&amp;gt; 只能通过迭代器来访问&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;set&amp;gt;
using namespace std;

int main(void) {
    set&amp;lt;int&amp;gt; st;
    st.insert(1);
    st.insert(2);
    st.insert(3);	
    st.insert(4);
    st.insert(5);
    st.insert(5);	//	重复 ，不可插入
    for (set&amp;lt;int&amp;gt; ::iterator  it = st.begin(); it != st.end(); it++)
    {
      cout &amp;lt;&amp;lt; *it;	// 1 2 3 4 5
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;set &amp;lt;int&amp;gt; st;

// insert(x)  ==&amp;gt;  将x插入set容器中，并自动递增排序和去重 O(logN) 其中N为set内元素个数
st.insert(1);
st.insert(2);
st.insert(3);
st.insert(5);
st.insert(4);	//	顺序不影响
st.insert(5);	//	重复，不可插入		==&amp;gt;  1 2 3 4 5

// find(value)	==&amp;gt;  返回set对应值为value的迭代器
set&amp;lt;int&amp;gt; ::iterator it = st.find(2);
cout &amp;lt;&amp;lt; *it;	//	2

// size()	==&amp;gt;	 获得set内元素个数
st.size();	// 5

// clear()	==&amp;gt;  清空set中所有元素
st.clear();	//	清空set

// erase()	==&amp;gt;	 删除单个元素(两种方式)、删除一个区间内(左闭右开)所有元素
int main(void) {
    set&amp;lt;int&amp;gt; st;
    st.insert(1);
    st.insert(2);
    st.insert(3);
    st.insert(4);
    st.insert(5);
      /* 删除单个元素 */
    st.erase(st.find(1));	// 传入迭代器 时间复杂度O(1)
    st.erase(2);			// 传入value 时间复杂度O(logN)
    for (set&amp;lt;int&amp;gt; ::iterator  it = st.begin(); it != st.end(); it++)
    {
      cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;	// 3 4 5
    }
      /* 删除一个区间内所有元素 */
      set&amp;lt;int&amp;gt; ::iterator it = st.find(4);
    st.erase(it, st.end());	// 删除元素4至末尾的元素 
    for (it = st.begin(); it != st.end(); it++)
    {
      cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;	// 3
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;map&#34;&gt;map&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;为映射，&lt;strong&gt;键值对(内部红黑树实现，元素本身有序)&lt;/strong&gt;	==&amp;gt;	头文件 &lt;code&gt;#include&amp;lt;map&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&amp;lt;typename1, typename2&amp;gt; mp&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义map&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;map&amp;lt;string, int&amp;gt; mp1;		// 映射到字符串时，必须使用string而不使用char[]
map&amp;lt;set&amp;lt;int&amp;gt;, string&amp;gt; mp2;	// 键值也可以是STL容器
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问遍历map&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;
using namespace std;

int main(void) {
    map&amp;lt;char, int&amp;gt; mp;
    mp[&#39;a&#39;] = 1;
    mp[&#39;b&#39;] = 2;
    mp[&#39;c&#39;] = 3;
    // 访问map具体key对应的value
    cout &amp;lt;&amp;lt; mp[&#39;c&#39;] &amp;lt;&amp;lt; endl;	// 3
    // 遍历map的key-value
    for (map&amp;lt;char, int&amp;gt; ::iterator it = mp.begin(); it != mp.end(); it++)
    {
      // map中的迭代器，it-&amp;gt;first访问键，it-&amp;gt;second访问值
      cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; endl;	// a 1 b 2 c 3
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;map&amp;lt;char, int&amp;gt; mp;
mp[&#39;a&#39;] = 1;
mp[&#39;b&#39;] = 2;
mp[&#39;c&#39;] = 3;
mp[&#39;d&#39;] = 4;

// find(key)	==&amp;gt;	返回键为key映射的迭代器 O(logN)
map&amp;lt;char, int&amp;gt; :: iterator it = mp.find(&#39;a&#39;);
cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; endl;	// a 1

// size()	==&amp;gt;	map中映射的个数
mp.size();	// 4

// clear()	==&amp;gt;	清空map中所有元素
mp.clear();

// erase()	==&amp;gt;	删除单个元素、删除一个区间内的所有元素
map&amp;lt;char, int&amp;gt; mp;
mp[&#39;a&#39;] = 1;
mp[&#39;b&#39;] = 2;
mp[&#39;c&#39;] = 3;
mp[&#39;d&#39;] = 4;
mp[&#39;e&#39;] = 5;
/* mp.erase(it) 出入要删除键值对的迭代器 O(1) */
mp.erase(mp.find(&#39;a&#39;));		// 删除 a 1
/* mp.erase(key) 删除键为key的键值对 O(logN) */
mp.erase(&#39;b&#39;);				// 删除 b 2
/* mp.erase(first, last) 删除[first, last) */
mp.erase(mp.find(&#39;d&#39;), mp.end());
for (map&amp;lt;char, int&amp;gt; ::iterator it = mp.begin(); it != mp.end(); it++){
	cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; endl;		// c 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;queue&#34;&gt;queue&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;队列   ==&amp;gt;	&lt;strong&gt;先进先出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;queue&amp;lt;typename&amp;gt;&lt;/code&gt;  name	==&amp;gt;	头文件 &lt;code&gt;#include&amp;lt;queue&amp;gt;&lt;/code&gt;;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义queue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;queue&amp;lt;int&amp;gt; qu;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问遍历  ==&amp;gt;  只能访问队首和队尾的元素&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

int main(void) {
    queue&amp;lt;int&amp;gt; qu;
    for (int i = 1; i &amp;lt;= 5; i++)
    {
      	qu.push(i);
    }
    cout &amp;lt;&amp;lt; qu.front() &amp;lt;&amp;lt; endl;		// 1
    cout &amp;lt;&amp;lt; qu.back() &amp;lt;&amp;lt; endl;		// 5
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// push(x)	==&amp;gt;	将x进入队列
queue&amp;lt;int&amp;gt; qu;
for (int i = 1; i &amp;lt;= 5; i++){
		qu.push(i);		// 1 2 3 4 5
}

// front()	==&amp;gt;	队首元素	back()	==&amp;gt;	队尾元素
cout &amp;lt;&amp;lt; qu.front() &amp;lt;&amp;lt; endl;		// 1
cout &amp;lt;&amp;lt; qu.back() &amp;lt;&amp;lt; endl;		// 5

// size()	==&amp;gt;	队列中元素个数
qu.size();	// 5

// empty()	==&amp;gt;	检测队列是否为空
qu.empty()	// 0(false) =&amp;gt; 不空 1(true) =&amp;gt; 空

// pop()	==&amp;gt;	队首元素出队
queue&amp;lt;int&amp;gt; qu;
for (int i = 1; i &amp;lt;= 5; i++)
{
		qu.push(i);
}
for (int i = 1; i &amp;lt;= 3; i++)
{
		qu.pop();
}
cout &amp;lt;&amp;lt; qu.front() &amp;lt;&amp;lt; endl;	// 4
cout &amp;lt;&amp;lt; qu.back() &amp;lt;&amp;lt; endl;	// 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stack&#34;&gt;stack&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;   栈  ==&amp;gt; &lt;strong&gt;先进后出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stack&amp;lt;typename&amp;gt; name&lt;/code&gt;    ==&amp;gt;	声明头文件 &lt;code&gt;#include&amp;lt;stack&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义stack&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

int main(void){
    stack&amp;lt;int&amp;gt; st;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问遍历 ==&amp;gt; 栈顶元素&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

int main(void) {
    stack&amp;lt;int&amp;gt; st;
    for (int i = 1; i &amp;lt;= 5; i++)
    {
      st.push(i);
    }
    cout &amp;lt;&amp;lt; st.top() &amp;lt;&amp;lt; endl;	// 5
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// push(x)	==&amp;gt; 将x入栈
stack&amp;lt;int&amp;gt; st;
for (int i = 1; i &amp;lt;= 5; i++)
{
		st.push(i);
}

//	top()	==&amp;gt;	取栈顶元素
cout &amp;lt;&amp;lt; st.top() &amp;lt;&amp;lt; endl;	// 5

// pop()	==&amp;gt;	弹出栈顶元素
st.pop();
st.pop();
cout &amp;lt;&amp;lt; st.top() &amp;lt;&amp;lt; endl;	// 3

// empty()	==&amp;gt;	检测栈是否为空
cout &amp;lt;&amp;lt; st.empty();		// 0(false) =&amp;gt;不空 1(true) =&amp;gt; 空

// size()	==&amp;gt; 栈内元素个数
cout &amp;lt;&amp;lt; st.size();		// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;algorithm&#34;&gt;algorithm&lt;/h2&gt;
&lt;h3 id=&#34;max-min-abs&#34;&gt;max()、min()、abs()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;max(x,y)，min(x,y)&lt;/code&gt;分别返回&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;中最大值和最小值，参数必须是两个(可以是浮点数)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;abs(x)&lt;/code&gt;返回&lt;code&gt;x(必须是整型)&lt;/code&gt;的绝对值 ，浮点数绝对值用&lt;code&gt;#include&amp;lt;math.h&amp;gt;&lt;/code&gt;头文件下&lt;code&gt;fabs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

int main(void){
    int x = 1;
    int y = -2;
    cout &amp;lt;&amp;lt; max(x, y) &amp;lt;&amp;lt; endl;	// 1
    cout &amp;lt;&amp;lt; min(x, y) &amp;lt;&amp;lt; endl;	// -2
    cout &amp;lt;&amp;lt; abs(y) &amp;lt;&amp;lt; endl;			// 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sort&#34;&gt;sort()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sort(首元素地址(必填),尾元素地址下一个地址(必填),比较函数(非必填))&lt;/code&gt;	==&amp;gt;	默认从小到大排序&lt;/p&gt;
&lt;p&gt;主要是对一个&lt;strong&gt;数组&lt;/strong&gt;进行排序(&lt;code&gt; int arr[]&lt;/code&gt; 数组或者 &lt;code&gt;vector&lt;/code&gt; 数组都⾏)， &lt;code&gt;vector&lt;/code&gt; 是&lt;strong&gt;容器&lt;/strong&gt;，要⽤ &lt;code&gt;v.begin()&lt;/code&gt; 和 &lt;code&gt;v.end()&lt;/code&gt; 表示头尾;而 &lt;code&gt;int arr[]&lt;/code&gt; 用 &lt;code&gt;arr &lt;/code&gt;表示数组的首地址， &lt;code&gt;arr+n &lt;/code&gt;表示尾部&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

bool cmp(int a, int b) { 		// cmp函数返回的值是bool类型
		return a &amp;gt; b; 			// 从⼤到小排列
}

int main() {
    /* 容器的排序 */
    vector&amp;lt;int&amp;gt; v(10);
    for (int i = 0; i &amp;lt; 10; i++) { 
      cin &amp;gt;&amp;gt; v[i];
    }
    sort(v.begin(), v.end());// 因为这里没有传入参数cmp，所以按照默认，v从小到大排列
    int arr[10];
    for (int i = 0; i &amp;lt; 10; i++) {
      cin &amp;gt;&amp;gt; arr[i];
    }
    sort(arr, arr + 10, cmp); // arr从大到小排列，因为cmp函数排序规则设置了从大到⼩
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意: sort 函数的 cmp 必须按照规定来写，即必须只是 &amp;gt; 或者 &amp;lt; ，⽐比如: return a &amp;gt; b; 或者 return a &amp;lt; b; ⽽不能是 &amp;lt;= 或者 &amp;gt;= ，因为快速排序的思想中， cmp 函数是当结果为 false 的 时候迭代器器指针暂停开始交换两个元素的位置，当 cmp 函数 return a &amp;lt;= b 时，若中间元素前面的元素都比它小，⽽而后⾯的元素都跟它相等或者⽐它⼩，那么 cmp 恒返回 true ，迭代器指针会不断右移导致程序越界，发⽣生段错误~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;结构体数组排序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

struct node{
  	int x, y;
}ssd[10];

bool cmp(node a, node b);
int main(void)
{
  	ssd[0].x = 2;
  	ssd[0].y = 2;
  	ssd[1].x = 1;
  	ssd[1].y = 3;
  	ssd[2].x = 3;
  	ssd[2].y = 1;
  	sort(ssd, ssd + 3, cmp);
  	for (int i = 0; i &amp;lt; 3; i++)
  	{
    	cout &amp;lt;&amp;lt; ssd[i].x &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ssd[i].y &amp;lt;&amp;lt; &amp;quot;,&amp;quot;;	//  3 1,2 2,1 3
  	}
	}
// 按x值从大到小排序
bool cmp(node a,node b){
  	return a.x &amp;gt; b.x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;结构体二级排序实现&#34;&gt;结构体二级排序实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

struct node{
    int x, y;
}ssd[10];

bool cmp(node a, node b);
int main(void)
{
    ssd[0].x = 2;
    ssd[0].y = 2;
    ssd[1].x = 1;
    ssd[1].y = 3;
    ssd[2].x = 2;
    ssd[2].y = 1;
    sort(ssd, ssd + 3, cmp);
    for (int i = 0; i &amp;lt; 3; i++)
    {
        cout &amp;lt;&amp;lt; ssd[i].x &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ssd[i].y &amp;lt;&amp;lt; &amp;quot;,&amp;quot;; // 2 1,2 2,1 3
    }
}
// 先按x从大到小排序,当x相等情况下，按照y从小到大排序
bool cmp(node a,node b){
    if (a.x != b.x)
    {
        return a.x &amp;gt; b.x;
    }else
    {
        return a.y &amp;lt; b.y;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;c11&#34;&gt;C++11&lt;/h2&gt;
&lt;h3 id=&#34;auto&#34;&gt;auto&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 是C++11里面的新特性，可以让编译器根据初始值类型直接推断变量的类型。比如这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto x = 3;			// x是int
auto y = 3.14;	// y是double

// 本来set的迭代器遍历要这样写:
for(set&amp;lt;int&amp;gt;::iterator it = s.begin(); it != s.end(); it++) {
		cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
}
// 现在可以直接替换成这样的写法:
for(auto it = s.begin(); it != s.end(); it++) {
		cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;		
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;to_string&#34;&gt;to_string()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;to_string&lt;/code&gt; 的头文件是 &lt;code&gt;#include &amp;lt;string&amp;gt;&lt;/code&gt; ，&lt;code&gt; to_string&lt;/code&gt; 最常用的就是把一个 &lt;code&gt;int&lt;/code&gt; 型变量或者一个数字转化 为 &lt;code&gt;string &lt;/code&gt;类型的变量，当然也可以转 &lt;code&gt;double &lt;/code&gt;、 &lt;code&gt;float&lt;/code&gt; 等类型的变量，以下是示例代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
int main() {
    string s1 = to_string(123); 				// 将123这个数字转成字符串 cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl;
    string s2 = to_string(4.5); 				// 将4.5这个数字转成字符串 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; s1 + s2 &amp;lt;&amp;lt; endl; 						// 将s1和s2两个字符串拼接起来并输出
    printf(&amp;quot;%s\n&amp;quot;, (s1 + s2).c_str()); 	// 如果想⽤printf输出string，得加⼀个.c_str()
    return 0; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;stoi-stod&#34;&gt;stoi、stod&lt;/h3&gt;
&lt;p&gt;使⽤&lt;code&gt; stoi&lt;/code&gt; 、 &lt;code&gt;stod&lt;/code&gt; 可以将字符串&lt;code&gt;string&lt;/code&gt;转化为对应的 &lt;code&gt;int&lt;/code&gt; 型、 &lt;code&gt;double&lt;/code&gt; 型变量，这在字符串处理的很&lt;/p&gt;
&lt;p&gt;多问题中很有帮助~以下是示例代码和⾮法输入的处理方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
int main() {
    string str = &amp;quot;123&amp;quot;; 
  	int a = stoi(str); cout &amp;lt;&amp;lt; a;
    str = &amp;quot;123.44&amp;quot;; 
  	double b = stod(str); 
  	cout &amp;lt;&amp;lt; b;
    return 0; 
}
/*
stoi如果遇到的是非法输入 (比如stoi(&amp;quot;123.4&amp;quot;)，123.4不是一个int型变量): 
1.会自动截取最前面的数字，直到遇到不是数字为止 (所以说如果是浮点型，会截取前面的整数部分)
2.如果最前面不是数字，会运行时发生错误

stod如果是非法输入:
1.会自动截取最前面的浮点数，直到遇到不满足浮点数为止 
2.如果最前⾯不是数字或者小数点，会运行时发生错误 
3.如果最前面是小数点，会自动转化后在前面补0
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相应的还有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stof&lt;/code&gt;     (string to float)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stold&lt;/code&gt;   (string to long double)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stol&lt;/code&gt;     (string to long)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stoll&lt;/code&gt;   (string to long long)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stoul &lt;/code&gt;   (string to unsigned long)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stoull&lt;/code&gt; (string to unsigned long long)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;unordered_map-unordered_set&#34;&gt;unordered_map、unordered_set&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;unordered_map&lt;/code&gt; 在头文件&lt;code&gt; #include &amp;lt;unordered_map&amp;gt;&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;&lt;code&gt; unordered_set&lt;/code&gt; 在头文件&lt;code&gt;#include&amp;lt;unordered_set&amp;gt;&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unordered_map&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; (或者 &lt;code&gt;unordered_set&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; )的区别是， &lt;code&gt;map&lt;/code&gt; 会按照键值对的键 &lt;code&gt;key &lt;/code&gt;进行排序( &lt;code&gt;set&lt;/code&gt; ⾥面会按照集合中的元素⼤小进⾏排序，从小到大顺序)，而 &lt;code&gt;unordered_map&lt;/code&gt; (或者 &lt;code&gt;unordered_set&lt;/code&gt; )省去了这个排序的过程，如果偶尔刷题时候用 &lt;code&gt;map&lt;/code&gt; 或者 &lt;code&gt;set&lt;/code&gt; 超时了，可以考虑用 &lt;code&gt;unordered_map&lt;/code&gt; (或者 &lt;code&gt;unordered_set&lt;/code&gt; )缩短代码运行时间、提⾼代码效率~至于用法和&lt;code&gt;map&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; 是一样的&lt;/p&gt;
&lt;h3 id=&#34;null和nullptr&#34;&gt;NULL和nullptr&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C中的NULL&lt;/p&gt;
&lt;p&gt;在C语言中，&lt;code&gt;NULL&lt;/code&gt;通常被定义为：&lt;code&gt;#define NULL ((void*)0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以说&lt;strong&gt;NULL实际上是一个空指针&lt;/strong&gt;，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int  *pi = NULL;
char *pc = NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++中的NULL&lt;/p&gt;
&lt;p&gt;但是问题来了，以上代码如果使用C++编译器来编译则是会出错的，&lt;strong&gt;因为C++是强类型语言&lt;/strong&gt;，&lt;code&gt;void*&lt;/code&gt;是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见，在C++中，&lt;strong&gt;NULL实际上是0&lt;/strong&gt;.因为&lt;strong&gt;C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了结果空指针的表示问题，C++引入了0来表示空指针&lt;/strong&gt;，这样就有了上述代码中的NULL宏定义。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
 
void func(void* i)
{
	cout &amp;lt;&amp;lt; &amp;quot;func1&amp;quot; &amp;lt;&amp;lt; endl;
}
 
void func(int i)
{
	cout &amp;lt;&amp;lt; &amp;quot;func2&amp;quot; &amp;lt;&amp;lt; endl;
}
 
void main(int argc,char* argv[])
{
	func(NULL);				// func2
	func(nullptr);		// func1
	getchar();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们对函数&lt;code&gt;func&lt;/code&gt;进行可重载，参数分别是&lt;code&gt;void*&lt;/code&gt;类型和&lt;code&gt;int&lt;/code&gt;类型，但是运行结果却与我们使用&lt;code&gt;NULL&lt;/code&gt;的初衷是相违背的，因为我们本来是想用&lt;code&gt;NULL&lt;/code&gt;来代替空指针，但是在将&lt;code&gt;NULL&lt;/code&gt;输入到函数中时，它却选择了&lt;code&gt;int&lt;/code&gt;形参这个函数版本，所以是有问题的，这就是用&lt;code&gt;NULL&lt;/code&gt;代替空指针在&lt;code&gt;C++&lt;/code&gt;程序中的二义性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;中的&lt;code&gt;nullptr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为解决&lt;code&gt;NULL&lt;/code&gt;代指空指针存在的二义性问题，在&lt;code&gt;C++11&lt;/code&gt;版本(2011年发布)中特意引入了&lt;code&gt;nullptr&lt;/code&gt;这一新的关键字来代指空指针，从上面的例子中我们可以看到，使用&lt;code&gt;nullptr&lt;/code&gt;作为实参，确实选择了正确的以&lt;code&gt;void*&lt;/code&gt;作为形参的函数版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c内存分配&#34;&gt;C++内存分配&lt;/h2&gt;
&lt;h3 id=&#34;newdelete&#34;&gt;new/delete&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new/delete&lt;/code&gt;是&lt;code&gt;c++&lt;/code&gt;中的关键字&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;new&lt;/code&gt;操作符申请内存分配时&lt;strong&gt;无须指定内存块的大小&lt;/strong&gt;，编译器会根据类型信息自行计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;操作符内存分配成功时，&lt;strong&gt;返回的是对象类型的指针，类型严格与对象匹配&lt;/strong&gt;，无须进行类型转换，故&lt;code&gt;new&lt;/code&gt;是符合类型安全性的操作符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;内存分配失败时，会抛出&lt;code&gt;bac_alloc&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mallocfree&#34;&gt;malloc/free&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc/free&lt;/code&gt;是&lt;code&gt;c&lt;/code&gt;中的系统函数，当然c++中也支持&lt;code&gt;malloc/free&lt;/code&gt;,不过效率不及&lt;code&gt;new/delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;则需要显式地指出所需内存的尺寸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;内存分配成功则是返回&lt;code&gt;void *&lt;/code&gt; ，需要通过强制类型转换将&lt;code&gt;void*&lt;/code&gt;指针转换成我们需要的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;分配内存失败时返回&lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
">C/C++基础整理（三）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/ccji-chu-zheng-li-er/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;接着上一篇C/C++整理的第二部分，本篇主要涉及到的是函数、指针部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;本篇推荐阅读博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liusicheng2008_liu/article/details/80412586&#34;&gt;深入理解char * ,char ** ,char a[] ,char *a[]的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/soonfly/article/details/51131141&#34;&gt;让你不再害怕指针——C指针详解(经典,非常详细)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/31412436/answer/683820765&#34;&gt;对于递归有没有什么好的理解方法？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;h3 id=&#34;定义函数&#34;&gt;定义函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;返回类型 函数名 ( 形式参数 ){
	声明
	语句
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;细节问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数无法返回数组。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定返回类型是void型说明函数没有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;C89&lt;/strong&gt;中，如果忽略返回类型，那么会假定函数返回值的类型是&lt;code&gt;int&lt;/code&gt;型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;C99&lt;/strong&gt;中，忽略返回类型是非法的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局变量-局部变量-值传递的传参方式&#34;&gt;全局变量、局部变量、值传递的传参方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;全局变量是指在定义之后的所有程序段内部都有效的变量（定义在所有函数之前）&lt;/p&gt;
&lt;p&gt;局部变量定义在函数内部，且只在函数内部生效，函数结束时局部变量销毁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;值传递&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

void change(int x){
    x = x + 1;
}

int main(void){
    int x = 10;
    change(x);
    printf(&amp;quot;%d&amp;quot;,x);		//	10
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果分析：&lt;/p&gt;
&lt;p&gt;当在主函数中定义了&lt;code&gt;x&lt;/code&gt;以后，将其作为&lt;code&gt;change()&lt;/code&gt;函数的参数传入，并令&lt;code&gt;x&lt;/code&gt;加1，但是最后输出时&lt;code&gt;x&lt;/code&gt;却仍然是10，这是因为&lt;code&gt;change()&lt;/code&gt;函数的参数&lt;code&gt;x&lt;/code&gt;为局部变量，仅在函数内部生效，通过&lt;code&gt;change(x)&lt;/code&gt;传递进去的&lt;code&gt;x&lt;/code&gt;其实只是传进去的一个&lt;strong&gt;副本&lt;/strong&gt;，也即&lt;code&gt;change&lt;/code&gt;函数的参数&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;main&lt;/code&gt;函数里的&lt;code&gt;x&lt;/code&gt;其实是作用于两个不同函数的不同变量（虽然名字相同），取成不同的名字也是可以的。这种传递参数的方式称为&lt;strong&gt;值传递&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;数组作为函数参数&#34;&gt;数组作为函数参数&lt;/h3&gt;
&lt;p&gt;函数的参数也可以是数组，且数组作为参数时，参数中数组的第一维不需要填写长度（&lt;strong&gt;如果是二维数组，那么第二维需要填写长度&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;数组作为参数时，在函数的调用中对数组元素的修改等同于是对原数组元素的修改（&lt;strong&gt;这与普通的局部变量不同，具体原因：数组传参时实际上传递的是数组第一个元素的地址，指针部分详谈&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：虽然数组可以作为参数，但是却不允许作为返回类型出现，如果想要返回数组，只能将返回的数组作为参数传入&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;函数递归调用&#34;&gt;函数递归调用&lt;/h3&gt;
&lt;p&gt;递归就是函数自己调自己的过程初学递归，对于递归一直难于理解，这里推荐的一篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/31412436/answer/683820765&#34;&gt;对于递归有没有什么好的理解方法？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机内存中，每个字节（理解为房间）都会有一个地址（可理解为房间号），即变量的存储位置，计算机就是通过地址找到某个变量的，&lt;strong&gt;变量的地址一般指它占用的字节中第一个字节存放的地址&lt;/strong&gt;，一个&lt;code&gt;int&lt;/code&gt;型的变量的地址就是它占用的4Byte当中第一个字节的地址&lt;/p&gt;
&lt;p&gt;指针就是变量的地址，指针变量：&lt;strong&gt;用于存放指针&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;指针在C语言中是较为难理解的一部分，这里只是做一些基础总结，推荐两篇博客&lt;/p&gt;
&lt;p&gt;一个房间号“&lt;strong&gt;指向&lt;/strong&gt;”一个房间，对应到计算机上就是一个地址“&lt;strong&gt;指向&lt;/strong&gt;”一个变量，在C语言中用“指针”来表示内存地址，可以理解为：&lt;strong&gt;指针就是变量的地址（指针是一个unsigned类型的整数）&lt;/strong&gt;  获取变量地址就是通过取地址运算符&amp;amp;，只要在变量前面加上&amp;amp;，就表示变量的地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

int main(void){
    int a = 5;
    int *p1 = &amp;amp;a;
    double pi = 3.14;
    double *p2 = &amp;amp;pi;
    printf(&amp;quot;%d\n&amp;quot;,sizeof(p1));		//	4
    printf(&amp;quot;%d\n&amp;quot;,sizeof(p2));		//	4
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从输出的结果我们可以看出：&lt;strong&gt;指针是一个&lt;code&gt;unsigned&lt;/code&gt;类型的整数&lt;/strong&gt;，并不会因为指针指向的是&lt;code&gt;double&lt;/code&gt;(8Byte)，对应指针变量分配空间变成8Byte&lt;/p&gt;
&lt;h3 id=&#34;定义-初始化指针变量&#34;&gt;定义、初始化指针变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;基本类型 *指针变量名
int *p1;		//	在使用指针变量 p 之前对其进行初始化是至关重要的
int a;
int *p2 = &amp;amp;a; 	// 一般是把变量的地址取出来，然后赋给对应类型的指针变量
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指针变量前面必须有“&lt;/strong&gt; ***** &lt;strong&gt;”&lt;/strong&gt;，表示该变量的类型为指针型变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义指针变量时必须指定基本类型，基类型表明了该指针变量所指向的变量类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;int * &lt;/code&gt;是指针变量的类型，而后面的&lt;code&gt;p&lt;/code&gt;才是变量名，用来存储地址，&lt;code&gt;&amp;amp;a&lt;/code&gt;是赋值给&lt;code&gt;p&lt;/code&gt;而不是&lt;code&gt;*p&lt;/code&gt;，也就是&lt;strong&gt;星号是类型的一部分&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间接寻址运算符 &lt;code&gt;*&lt;/code&gt;  访问到指针所指的对象，可以把 &lt;code&gt;*&lt;/code&gt; 理解为一把开启房间的钥匙，将其放在&lt;code&gt;p&lt;/code&gt;的前面,这样&lt;code&gt;*p&lt;/code&gt;就可以把房间打开，然后获取变量&lt;code&gt;a&lt;/code&gt;的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a =5;
int *p = &amp;amp;a;
printf(&amp;quot;%d\n&amp;quot;, *p);		// 5

//	对变量使用&amp;amp;运算符产生指向变量的指针，而对指针使用*运算符则可以返回到原始变量
j = *&amp;amp;i;   				/* same as j = i; */
//	只要p指向i，*p就是i的别名,*p拥有和i相同的值,改变*p的值，同时也会改变i的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将间接寻址运算符应用于未初始化的指针变量，会导致未定义的行为，对 *p 进行赋值则更加危险&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int *p;
printf(&amp;quot;%d&amp;quot;, *p);   /*** WRONG ***/

int *p;
*p = 1;   			/*** WRONG ***/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针变量的值可以是&lt;strong&gt;普通变量的地址&lt;/strong&gt;，也可以是&lt;strong&gt;数组的地址&lt;/strong&gt;或&lt;strong&gt;数组元素的地址&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybply1gbv0f1fjphj30nr0ex74t.jpg&#34; alt=&#34;image-20200212210331685&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任意数量的指针变量都可以指向同一个对象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指针赋值与运算&#34;&gt;指针赋值与运算&lt;/h3&gt;
&lt;p&gt;指针赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;p = q;			//	指针赋值语句	结果：指针q与p指向相同的位置
*p = *q;		//	不会指向同一变量，下图所示
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybply1gbv0e0wqr4j30g50huwf5.jpg&#34; alt=&#34;image-20200213194210095&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;指针加减法   ==&amp;gt;  常用于数组中&lt;/p&gt;
&lt;p&gt;对于一个&lt;code&gt;int *&lt;/code&gt; 类型的变量&lt;code&gt;p&lt;/code&gt;来说，&lt;code&gt;p + 1&lt;/code&gt; 是指 &lt;code&gt;p&lt;/code&gt; 所指的&lt;code&gt;int&lt;/code&gt;型变量的下一个&lt;code&gt;int&lt;/code&gt;型变量地址，这里所谓的**“下一个”是跨越了一整个&lt;code&gt;int&lt;/code&gt;型（&lt;code&gt;sizeof(int)&lt;/code&gt;个Byte  ==&amp;gt; 4Byte）**&lt;/p&gt;
&lt;h3 id=&#34;指针变量作为函数参数&#34;&gt;指针变量作为函数参数&lt;/h3&gt;
&lt;p&gt;指针类型可以作为函数参数的类型，**这时视为把变量的地址传入函数，如果在函数中对这个地址中的元素进行改变，原先的数据就会确实地被改变 ==&amp;gt; 地址传递 **&lt;/p&gt;
&lt;p&gt;用一个例子来理解： 使用指针交换两个数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

void swap(int *p1, int *p2){
	int temp;
	temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main(void){
    int a = 1, b = 2;
    int *p1 = &amp;amp;a, *p2 = &amp;amp;b;
    swap(p1, p2);       // only 指针名
    printf(&amp;quot;a = %d, b = %d&amp;quot;, *p1, *p2);		// a = 2, b = 1
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，把&lt;code&gt;&amp;amp;a&lt;/code&gt;（&lt;code&gt;a&lt;/code&gt;的地址）和&lt;code&gt;&amp;amp;b&lt;/code&gt;（&lt;code&gt;b&lt;/code&gt;的地址）作为参数传入，使得&lt;code&gt;swap&lt;/code&gt;函数中&lt;code&gt;int*&lt;/code&gt;类型指针变量&lt;code&gt;a&lt;/code&gt;存放&lt;code&gt;&amp;amp;a&lt;/code&gt;、指针变量&lt;code&gt;b&lt;/code&gt;存放&amp;amp;b。这时，&lt;code&gt;swap&lt;/code&gt;函数中的&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;都是地址，而 &lt;code&gt;*a&lt;/code&gt;和 &lt;code&gt;*b&lt;/code&gt;就是地址中存放的数据，可以“看成”是&lt;code&gt;int&lt;/code&gt;型变量，接下来就进行正常交换&lt;/p&gt;
&lt;p&gt;我们再来看几个&lt;strong&gt;错误交换的例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 值传递并不能对数据产生实质影响
void swap1(int p1, int p2){
    int temp = p1;
    p1 = p2;
    p2 = temp;
}

// 很多人认为*temp、*p1、*p2都可以“看作”int型变量，可这样交换，但这里的错误是因为temp没有初始化，存放的地址是随机的
void swap2(int *p1, int *p2){
    int *temp;		
    *temp = *p1;
    *p1 = *p2;
    *p2 = *temp;
}

// 这里的错误是因为直接把这个地址进行交换，我们之前说过地址其实是一个“无符号整型”的数，其本身和普通变量一样只是“值传递”，对地址本身进行修改其实跟之前对传入的普通变量进行交换的函数是一样的作用，都只是副本，没法对数据产生实质性影响 ==&amp;gt; 解决方法：指针的引用
void swap3(int *p1, int *p2){
    int *temp = p1;
    p1 = p2;
    p2 = temp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;const&lt;/code&gt;保护参数&lt;/p&gt;
&lt;p&gt;当传递指向变量x的指针给一个函数f时，&lt;strong&gt;通常意味着x的值将被修改f(&amp;amp;x)&lt;/strong&gt;;然而有的时候，f 可能仅仅需要对x的值进行检查，而不需要对其进行修改。可以使用&lt;code&gt;const&lt;/code&gt;关键字确保函数不会修改指针参数所指向的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 如果函数中的语句试图修改 *p 的值，编译器能够捕获此类错误。
void f(const int *p){
	*p = 0;   /*** WRONG ***/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指针作为返回值&#34;&gt;指针作为返回值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int *max(int *a, int *b){
	if (*a &amp;gt; *b)
	   return a;
	else
	   return b;
}

int main(void){
  	int *p, i, j;
	...
	p = max(&amp;amp;i, &amp;amp;j);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：不要返回指向自动局部变量的指针，一旦函数返回，局部变量将不复存在&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;指针与数组&#34;&gt;指针与数组&lt;/h3&gt;
&lt;p&gt;在C语言中，&lt;strong&gt;数组名称也作为数组的首地址使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;*a = 7;  		 	 /* stores 7 in a[0] */
*(a + 1) = 12;  	 /* stores 12 in a[1] */

// 数组遍历
for (p = &amp;amp;a[0]; p &amp;lt; &amp;amp;a[N]; p++)
	sum += *p;

// 可以简化为如下形式：
for (p = a; p &amp;lt; a + N; p++)
	sum += *p;

// 尽管数组名可以用作指针，但不能对其赋值，试图使其指向其它位置会导致错误发生：
while (*a != 0)
  	a++;           /*** WRONG ***/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常情况下，&lt;code&gt;a + i &lt;/code&gt;和 &lt;code&gt;&amp;amp;a[i]&lt;/code&gt;是等同的，均表示指向数组 &lt;code&gt;a &lt;/code&gt;中元素&lt;code&gt;i&lt;/code&gt;的指针&lt;br&gt;
同样地，&lt;code&gt; *(a+i)&lt;/code&gt; 与&lt;code&gt;a[i]&lt;/code&gt;也是等同的，均表示数组&lt;code&gt; a&lt;/code&gt; 中的元素 &lt;code&gt;i&lt;/code&gt;自身&lt;/p&gt;
&lt;p&gt;如果指针&lt;code&gt;p&lt;/code&gt;指向数组&lt;code&gt;a&lt;/code&gt;的元素，则可以通过对指针&lt;code&gt;p&lt;/code&gt;进行指针算术运算（或地址算术运算）访问数组&lt;code&gt;a&lt;/code&gt;中其他元素：C语言支持三种类型的指针算术运算（且仅有这三种类型）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指针加上整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;p &lt;/code&gt;指向数组元素&lt;code&gt; a[i]&lt;/code&gt;，则&lt;code&gt;p + j&lt;/code&gt;指向数组元素 &lt;code&gt;a[i + j]&lt;/code&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybply1gbv0fpv8x6j30pj0dvmxp.jpg&#34; alt=&#34;image-20200213194350262&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指针减去整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;p&lt;/code&gt; 指向&lt;code&gt; a[i]&lt;/code&gt;，则&lt;code&gt;p - j &lt;/code&gt;指向&lt;code&gt; a[i - j]&lt;/code&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybply1gbv0g8kelsj30pk0dzwf0.jpg&#34; alt=&#34;image-20200213194420453&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;两个指针相减  ==&amp;gt; 针对指向同一数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当两个指针相减时，结果为&lt;strong&gt;指针之间的距离&lt;/strong&gt;（以数组元素的个数作为度量）。&lt;br&gt;
如果&lt;code&gt;p&lt;/code&gt;指向&lt;code&gt;a[i]&lt;/code&gt; ，&lt;code&gt;q&lt;/code&gt;指向&lt;code&gt;a[j]&lt;/code&gt;，则 &lt;code&gt;p – q&lt;/code&gt;等于&lt;code&gt;i – j&lt;/code&gt;&lt;/p&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/0082zybply1gbv0gl7zrnj30q607uq37.jpg&#34; alt=&#34;image-20200213194440774&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指针引用c特性&#34;&gt;指针引用(C++特性)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;引用：不使用指针、不产生副本达到修改传入参数的目的  ==&amp;gt; 对引用变量的操作就是对原变量的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：要把引用的&lt;code&gt;&amp;amp;&lt;/code&gt;和取地址符&lt;code&gt;&amp;amp;&lt;/code&gt;区分开，&lt;strong&gt;引用并不是取地址的意思&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

int main(void){
    int x = 2;
    change(x);
    printf(&amp;quot;%d\n&amp;quot;,x);		//	1
    return 0;
}

void change(int &amp;amp;x){
    x = 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在上面写过一个通过将传递至交换来达到交换两个变量的效果，但是失败了=&amp;gt;[swap3()](# 指针变量作为函数参数)，这是因为对指针变量本身的修改无法作用到原指针变量上，那么就可以使用&lt;strong&gt;指针的引用&lt;/strong&gt;来实现这个效果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

int main(void){
    int a = 1, b = 2;
    int *p1 = &amp;amp;a, *p2 = &amp;amp;b;
    swap(p1, p2);
//	swap(&amp;amp;a, &amp;amp;b);		/*** WRONG 由于引用是产生变量的别名，因此常量不可使用 ***/		
    printf(&amp;quot;a = %d, b = %d\n&amp;quot;,*p1, *p2);	// a = 2, b = 1
    return 0;
}

void swap(int* &amp;amp;p1, int* &amp;amp;p2){
    int* temp = p1;
    p1 = p2;
    p2 = temp;
}
&lt;/code&gt;&lt;/pre&gt;
">C/C++基础整理（二）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/ccji-chu-zheng-li-yi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在已经学习过C语⾔的前提下，学习C++并使⽤它刷算法的学习成本非常低～&lt;br&gt;
这里做一点C语言重点总结和部分C++特性（C++向下兼容C，因此C语言的语法在C++中同样适用）以便于刷算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;数据类型&#34;&gt;#数据类型&lt;/h2&gt;
&lt;h3 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;取值范围&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大致范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;sup&gt;31 &lt;/sup&gt; ~  +(2&lt;sup&gt;31&lt;/sup&gt;-1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2 ×10 &lt;sup&gt;9&lt;/sup&gt; ~ 2 ×10 &lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;sup&gt;63&lt;/sup&gt; ~ (2&lt;sup&gt;63&lt;/sup&gt;-1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-9 ×10 &lt;sup&gt;18&lt;/sup&gt; ~ 9 ×10 &lt;sup&gt;18&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;sup&gt;128&lt;/sup&gt; ~ +2&lt;sup&gt;128&lt;/sup&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实际精度6~7位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;sup&gt;1024&lt;/sup&gt; ~ +2&lt;sup&gt;1024&lt;/sup&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实际精度15~16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;char&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-128 ~ +127&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-128 ~ +127&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0(false) or 1(true)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0(false) or 1(true)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于整型的使用，&lt;strong&gt;绝对值在10&lt;sup&gt;9&lt;/sup&gt;范围内&lt;/strong&gt;整数可定义为&lt;code&gt;int&lt;/code&gt;型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于浮点型，尽量不要使用float，&lt;strong&gt;全部使用&lt;/strong&gt;&lt;code&gt;double&lt;/code&gt;来存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符常量（必须是单个字符）必须用单引号标注      &#39;a&#39;&lt;/li&gt;
&lt;li&gt;字符常量使用&lt;strong&gt;ASCII码&lt;/strong&gt;统一编码，0-9、A-Z、a-z等都是可显示字符，它们的&lt;strong&gt;ASCII&lt;/strong&gt;码分别是48&lt;sub&gt;57、65&lt;/sub&gt;90、97~122，须记住&lt;strong&gt;小写字母比大写字母的ASCII码大32&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔型 头文件加&lt;code&gt;stdbool.h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;bool 变量量有两个值， &lt;code&gt;false&lt;/code&gt; 和&lt;code&gt;true&lt;/code&gt; ，以前⽤用C语⾔的时候都是⽤&lt;code&gt;int&lt;/code&gt; 的0 和1 表示&lt;code&gt;false&lt;/code&gt; 和&lt;code&gt;true&lt;/code&gt;的，现在C++⾥面引⼊了这个叫做&lt;code&gt;bool&lt;/code&gt; （布尔）的变量，而且&lt;strong&gt;C++把所有⾮非零值解释为&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; ，零值解释为&lt;code&gt;false&lt;/code&gt; 所以直接赋值一个数字给&lt;code&gt;bool &lt;/code&gt;变量也是可以的～它会自动根据int 值是不是零来决定给&lt;code&gt;bool &lt;/code&gt;变量赋值&lt;code&gt;true&lt;/code&gt; 还是&lt;code&gt;false &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool flag = true;
bool flag2 = -2; 		// flag2为true
bool flag3 = 0; 		// flag3为false
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号常量和const常量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define pi 3.14
const double pi = 3.14
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;
&lt;h4 id=&#34;c中的字符串&#34;&gt;C中的字符串&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;没有单独一种数据类型可以存储，只能用字符数组方式，字符串常量可以作为初值赋给字符数组，并使用%s格式输出&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;char str[20] = &amp;quot;Hello&amp;quot;;
printf(&amp;quot;%s&amp;quot;,str);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;头文件中常用API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strlen(str)&lt;/code&gt;	得到字符数组中&lt;strong&gt;第一个\0前面的字符个数&lt;/strong&gt;，注意字符串的存储方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strcmp(str1, str2)&lt;/code&gt;   返回两个字符串大小的比较结果&lt;/p&gt;
&lt;p&gt;比较原则：&lt;strong&gt;字典序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;str1[0···k-1] == str2[0···k-1]、str1[k] &amp;lt; str[k]，那么就说str1的字典序小于str2&lt;/p&gt;
&lt;p&gt;str1 &amp;lt; str2  返回负整数&lt;/p&gt;
&lt;p&gt;str1 = str2  返回0&lt;/p&gt;
&lt;p&gt;str1 &amp;gt; str2  返回正整数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strcpy(str1, str2)&lt;/code&gt;  把字符数组2复制给字符数组1，这里复制包括结束符\0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strcat(str1, str2)&lt;/code&gt;  把字符数组2接到字符数组1后面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

int main(void){
  	char str1[10], str2[10];
  	gets(str1);
  	gets(str2);
  	int len = strlen(str1);
  	int cmp = strcmp(str1, str2);
  	strcpy(str1, str2);
  	strcat(str1, str2);
  	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;c中字符串string类&#34;&gt;C++中字符串string类&lt;/h4&gt;
&lt;p&gt;以前⽤用&lt;code&gt;char[]&lt;/code&gt; 的⽅方式处理理字符串串很繁琐，现在有了&lt;code&gt;string&lt;/code&gt; 类，定义、拼接、输出、处理理都更更加简单啦～不过&lt;code&gt;string &lt;/code&gt;只能⽤用&lt;code&gt;cin&lt;/code&gt; 和&lt;code&gt;cout&lt;/code&gt; 处理，无法用&lt;code&gt;scanf&lt;/code&gt; 和&lt;code&gt;printf&lt;/code&gt; 处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string s = &amp;quot;hello world&amp;quot;; // 赋值字符串串
string s2 = s;
string s3 = s + s2; 			// 字符串串拼接直接⽤用+号就可以
string s4;
cin &amp;gt;&amp;gt; s4; 								// 读⼊入字符串串
cout &amp;lt;&amp;lt; s; 								// 输出字符串串
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;string类中常用API
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;str.length()&lt;/code&gt;	  获取&lt;code&gt;str&lt;/code&gt;的长度  &lt;strong&gt;有几个字符就是长度多少&lt;/strong&gt;，不存在&lt;code&gt;char[] &lt;/code&gt;⾥面的什么末尾的结束符之类的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str.substr()&lt;/code&gt;      截取字符串&lt;/li&gt;
&lt;li&gt;⽤用&lt;code&gt;cin&lt;/code&gt; 读⼊入字符串串的时候，是以空格为分隔符的，如果想要读入一整⾏的字符串，就需要⽤用&lt;code&gt;getline&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string s; // 定义⼀一个空字符串串s
getline(cin, s); // 读取⼀一⾏行行的字符串串，包括空格
cout &amp;lt;&amp;lt; s.length(); // 输出字符串串s的⻓长度
string s2 = s.substr(4); // 表示从下标4开始⼀一直到结束
string s3 = s.substr(5, 3); // 表示从下标5开始，3个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;string中一些更加详细的用法在C++标准模板库STL中再做详细整理&lt;/p&gt;
&lt;h2 id=&#34;输入输出&#34;&gt;输入输出&lt;/h2&gt;
&lt;h3 id=&#34;scanf-printf&#34;&gt;scanf()、printf()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int n;
char str[10];
scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
scanf(&amp;quot;%s&amp;quot;, str);		//  ！！！
printf(&amp;quot;%d&amp;quot;, n);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组名称本身就代表了这个数组第一个元素的地址，所以不需要再加取地址运算符，再scanf()中，除了char数组整个输入的情况下不加&amp;amp;之外，其他变量类型都需要加&amp;amp;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;格式控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;%md  可以使不足m位的int型以m位进行&lt;strong&gt;右对齐&lt;/strong&gt;输出，高位&lt;strong&gt;空格补齐&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;%0d   不足m位时，前面&lt;strong&gt;高位补0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;%.mf   浮点数保留m位输出  四舍五入用round()函数&lt;/li&gt;
&lt;li&gt;%c   char&lt;/li&gt;
&lt;li&gt;%s   char[]&lt;/li&gt;
&lt;li&gt;%lld long long&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;scanf的双引号的内容其实就是整个输入，只不过把数据换成它们对应的格式符并把变量的地址按次序写在后面而已&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了%c外，scanf对其他格式控制符(如%d)的输入是以&lt;strong&gt;空白符(空格、换行等)为结束标志&lt;/strong&gt;的，%c &lt;strong&gt;是可以读入空格和换行的&lt;/strong&gt;我们看下面两个例子&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char const *argv[])
{
	char str[10];
	scanf(&amp;quot;%s&amp;quot;, str);
	printf(&amp;quot;%s\n&amp;quot;, str);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abcd efg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abcd
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char const *argv[])
{
    int a;
    char str[10];
    char c;
    scanf(&amp;quot;%d%c%s&amp;quot;,&amp;amp;a, &amp;amp;c, str);
    printf(&amp;quot;a = %d, c = %c, str = %s\n&amp;quot;,a, c, str);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 a bcd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 1, c =  , str = a
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;getchar-putchar&#34;&gt;getchar()、putchar()&lt;/h3&gt;
&lt;p&gt;注意：&lt;code&gt;getchar()&lt;/code&gt;可接受换行符(Enter)和空格符(Space)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char const *argv[])
{
    char c1, c2, c3;
    c1 = getchar();
    c2 = getchar();
    c3 = getchar();
    putchar(c1);
    putchar(c2);
    putchar(c3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a b c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a
b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a
b
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;gets-puts&#34;&gt;gets()、puts()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gets() &lt;/code&gt;用来输入一行字符串并将其存放于一维数组中， &lt;code&gt;gets()&lt;/code&gt;识别**换行符&lt;code&gt;\n&lt;/code&gt;**作为输入结束&lt;/p&gt;
&lt;p&gt;&lt;code&gt;puts()&lt;/code&gt;用来输出一行字符串，&lt;strong&gt;并紧跟一个换行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char const *argv[])
{
    char str[10];
    gets(str);
    puts(str);
    return 0;	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc def
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc def
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;!!字符数组存放方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于字符数组是由若干个char类型的元素组成，因此字符数组的每一位都是一个char字符，&lt;strong&gt;末尾都有一个空字符\0表示存放的字符串结尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空字符\0在使用gets获scanf输入字符串时会自动添加在输入的字符串后面，并且占用一个字符位、puts和printf就是通过识别\0作为字符串的结尾来输出的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特别提醒&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开辟字符串数组的时候千万要记得字符数组的长度一定要比实际存储字符串长度至少多1(\0)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;适用scanf函数的%s格式或者gets函数输入字符串时，可不用担心\0的问题，&lt;strong&gt;但如果适用getchar()一定要在输入的每个字符串后面加入\0&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

int main(void){
    char str[15];
    for(int i = 0; i &amp;lt; 3; i++){
      str[i] = getchar();
    }
    puts(str);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc?@w??
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上结果是《算法笔记》里面输出结果，但在我的Mac里跑出来却没有乱码，目前还不清楚是否为clang++编译器的原因&lt;/p&gt;
&lt;h3 id=&#34;cin-cout&#34;&gt;cin、cout&lt;/h3&gt;
&lt;p&gt;cin与cout是C++中输入与输出函数，需添加头文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可不指定格式，也不需要加取地址运算符&amp;amp;，可在后面继续扩展&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; db &amp;gt;&amp;gt; c &amp;gt;&amp;gt; str;
cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot;hello&amp;quot; &amp;lt;&amp;lt; db &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;		// endl表示换行
cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; str;	//输出中间没有空格要自己进行补全
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int main(void){
      int a;
      char c;
      double db;
      char str[10];
      cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; c &amp;gt;&amp;gt; db &amp;gt;&amp;gt; str;
      cout&amp;lt;&amp;lt; a &amp;lt;&amp;lt; c &amp;lt;&amp;lt; db &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
      return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;123 a 3.14 Rick
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;123a3.14Rick
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;123a3.14Rick
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;123a3.14Rick
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对算法考试而言：并不推荐使用&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;cout&lt;/code&gt;来进行输入和输出，因为他们在输入/输出大量数据的情况下表现非常糟糕，推荐使用&lt;code&gt;scanf&lt;/code&gt;和&lt;code&gt;printf&lt;/code&gt;进行函数的输入和输出&lt;/strong&gt;&lt;/p&gt;
">C/C++基础整理（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/shi-xi-mian-jing/"" data-c="
          &lt;p&gt;为了准备学院大三下学期6个月的实习，自己投递了一些公司的Java的开发岗并参加了面试，主要有百度、SAP、新浪微博、京东数科... 由于我大一大二的时候并没有真正地接触到技术，所做的项目也是少之又少，也就局限于学院里安排的一些课程设计，从准备简历到投简历到再修改简历再面试来来回回折腾了不少次，踩过的坑也算是引以为戒。接下来我主要从&lt;strong&gt;简历制作、准备面试、面试真题、经验教训&lt;/strong&gt;这几个方面来说（实习生的身份）&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;简历制作&#34;&gt;简历制作&lt;/h2&gt;
&lt;p&gt;简历看似是一个简单的事情，但是对于求职来说是至关重要的一环，因为简历制作的好坏决定着你能否经过HR的筛选拿到面试的资格以及决定着面试过程中面试官提问的大多数问题。我主要提供一个简历的制作思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个人信息：姓名、年龄、&lt;strong&gt;联系方式、邮箱&lt;/strong&gt;、住址、&lt;strong&gt;个人博客、GitHub地址&lt;/strong&gt;(做的好的话，绝对的加分点)等&lt;/li&gt;
&lt;li&gt;*** 专业技能**：
&lt;ul&gt;
&lt;li&gt;无论是实习生还是将来找工作，都慎用**&amp;quot;精通&amp;quot;**二字&lt;/li&gt;
&lt;li&gt;有的同学可能不知道该怎样写自己的技能点，就用短短的一句比如“&lt;strong&gt;熟悉Java开发&lt;/strong&gt;”就描述完了，那么这样的简历太过笼统肯定是缺少亮点的，即使有可能你确实很厉害，但也有可能拿不到面试的资格。如果没有思路，可以&lt;strong&gt;去招聘网站去看下具体投递岗位的技能需求&lt;/strong&gt;，&lt;strong&gt;适当地&lt;/strong&gt;包装技能，可以将技能点进一步细化。比如“熟悉Java开发”我就可以延伸到：Java基础较好、熟悉Java并发编程、IO模型、深入理解集合框架等等。我这里只是简单举个例子，具体情况根据个人掌握的程度来进行确定。&lt;strong&gt;包装上去的技能点一定要能经地住面试官的提问，很难的问题也许不会，但基础性的问题一定要非常熟悉&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;教育背景：学校+专业。如果在校成绩较好，也可列一些具体的数据上去，作为在校生这也算是一个亮点&lt;/li&gt;
&lt;li&gt;获奖经历：奖学金、比赛获奖等等 如果比赛比较突出专业性的技能，可以稍作详细描述，这也是绝对的加分点&lt;/li&gt;
&lt;li&gt;*** 项目经验**
&lt;ul&gt;
&lt;li&gt;尽量写和你要应聘岗位相关的项目经历，不一定要写上去所有的项目，如果某个项目你觉得自己说不清楚的话就不要写上去，有的面试官会很关心项目问题，问的很深，所以**“不熟悉的项目慎重”**&lt;/li&gt;
&lt;li&gt;写上去的项目进行包装：项目背景可不用介绍，介绍这个项目实现的功能，&lt;strong&gt;你在这个项目中负责哪一部分的开发？用了什么技术解决了什么问题？达到了怎样的预期效果？&lt;/strong&gt;（如果有&lt;strong&gt;具体的数据做支撑将会更棒&lt;/strong&gt;）你对于这个项目的思考？(这个可以不用具体写在简历上，当面试官让你谈这个项目的时候也许会问到你，如果遇到某种场景，这个项目可以应对吗？如果不可以又有哪些办法解决？这个要有个心理准备)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不过分包装&lt;/strong&gt;，作为实习生的身份，面试官也能理解我们在学校项目经历的不足，如果你的基础知识及技能足够好的话，那也是OK的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自我评价：简短的一段自我评价，最好有具体例子做支撑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简历不用太长，1-2页即可，PDF格式&lt;/p&gt;
&lt;p&gt;实习的话，投递简历渠道推荐几个：BOSS直聘、牛客网、实习僧以及找人内推会比较快而且知道简历处理的进度&lt;/p&gt;
&lt;p&gt;总结一点： &lt;strong&gt;适当包装，切忌过度包装&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;准备面试&#34;&gt;准备面试&lt;/h2&gt;
&lt;p&gt;当投递完简历后，一定要保证&lt;strong&gt;手机在正常工作日时间的通畅&lt;/strong&gt;，一般自己联系企业，会有HR给你打电话约面试的时间，面试的形式主要是：视频面试、电话面试、现场面试(一般是本地的公司会约你现场面试)在约好具体面试时间后，就要开始面试的准备&lt;/p&gt;
&lt;h3 id=&#34;复习&#34;&gt;复习&lt;/h3&gt;
&lt;p&gt;具体岗位的不同，复习方法也有所区别，我们去看实习招聘岗位的分布情况，主要是算法研发岗、前后端研发岗、测试岗等。作为一个实习生(在校)主要复习的思路主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据结构与算法&lt;/p&gt;
&lt;p&gt;​	重中之重，无论是什么岗位(算法、研发、测试等)都会进行考察，常见的一些算法要能够手写出来&lt;/p&gt;
&lt;p&gt;​	常见面试题：数组、链表、树遍历算法、DFS、BFS、查找、排序等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机网络(前端开发和后端开发必问)&lt;/p&gt;
&lt;p&gt;​	常见面试题：TCP、UDP区别、 TCP三次握手、四次挥手流程及为什么三次为什么四次？DNS协议相关...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统基础&lt;/p&gt;
&lt;p&gt;​	常见面试题：主要是涉及到并发编程的话，处理机的调度(进程、线程、死锁等)常问...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库原理(后端开发必问，前端开发偶有问到)&lt;/p&gt;
&lt;p&gt;​	常见面试题：数据库索引、数据库范式、数据库事务管理(ACID)、SQL优化思路...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;投递具体岗位的技能要求，这里有一点，岗位上明确要求的技能基本都会被问到，所以要做一些针对性复习，然后这时可以&lt;strong&gt;去GitHub或者牛客网再找找面经看看&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目，在这里复习项目中的技能点我觉得是很有必要的，因为和面试官谈论项目问题时，大多数面试官就会以你当前的项目中的技能点进行发问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试岗位有必要将软件工程再好好复习一遍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于公共基础课的复习，这里分享一个公众号文章可以进行适当突击--&amp;gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/ZqLPc2ja72qyfV2n-0mYSA&#34;&gt;Click&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;面试流程&#34;&gt;面试流程&lt;/h3&gt;
&lt;p&gt;一般实习的话，面试3轮（2轮技术面试+1轮HR面试）&lt;/p&gt;
&lt;p&gt;这里主要谈论技术性面试&lt;/p&gt;
&lt;p&gt;面试流程主要是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-2分钟自我介绍&lt;/li&gt;
&lt;li&gt;面试官从项目说起，让你介绍你的项目，这期间面试官会提问&lt;/li&gt;
&lt;li&gt;基础知识和技能的提问，一般10个问题左右&lt;/li&gt;
&lt;li&gt;如果是视频面试和现场面试，有很大可能性现场出算法题目让你写代码（尤其想去字节跳动的话，每轮面试都会有算法题目，做不出来基本是一票否决的），电话面试也不排除让你进行描述&lt;/li&gt;
&lt;li&gt;面试结束前，面试官都会问：你还有什么要问我的吗？(这个问题提前做点准备就好)这里推荐大家看一下--&amp;gt; &lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/%E9%9D%A2%E8%AF%95%E5%AE%98-%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E8%A6%81%E9%97%AE%E6%88%91.md&#34;&gt;Click&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;面试真题&#34;&gt;面试真题&lt;/h2&gt;
&lt;p&gt;由于我接到的面试都是Java开发相关的，我主要对面试中遇到的&lt;strong&gt;CS公共基础课和Java相关知识&lt;/strong&gt;进行总结&lt;/p&gt;
&lt;h3 id=&#34;数据结构与算法篇&#34;&gt;数据结构与算法篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B树和B+树的区别（新浪微博）&lt;/li&gt;
&lt;li&gt;你了解哪些排序算法？算法的思想、时间复杂度、空间复杂度？（京东数科）&lt;/li&gt;
&lt;li&gt;LeetCode第1题及第15题：两数之和及三数之和问题（新浪微博）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计算机网络篇&#34;&gt;计算机网络篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TCP三次握手、四次挥手流程？为什么三次，为什么四次？（新浪微博、百度）&lt;/li&gt;
&lt;li&gt;TCP和UDP区别，有TCP为什么还要有UDP？（百度、京东数科）&lt;/li&gt;
&lt;li&gt;TCP粘包和拆包问题有了解吗？（新浪微博）&lt;/li&gt;
&lt;li&gt;TCP是怎样保持连接的？（京东数科）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作系统篇&#34;&gt;操作系统篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;并发编程中死锁有了解吗？死锁产生的条件是什么？你在项目中是怎样解除避免和解除死锁的？（百度）&lt;/li&gt;
&lt;li&gt;进程的都有哪些状态？怎么转换的？（新浪微博）&lt;/li&gt;
&lt;li&gt;Linux下文件的操作命令（京东数科）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库篇&#34;&gt;数据库篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库范式了解吗？在项目中怎么运用的？会出现什么问题？（新浪微博、SAP、京东数科）&lt;/li&gt;
&lt;li&gt;MySQL中编码遇到过什么问题吗？为什么不选UTF-8编码选UTF-8mb4？（SAP）&lt;/li&gt;
&lt;li&gt;MySQL数据库索引？底层是怎么实现的？（京东数科、新浪微博）&lt;/li&gt;
&lt;li&gt;MySQL中存储引擎InnoDB和MyISAM有什么区别？分别用于什么场景？（新浪微博）&lt;/li&gt;
&lt;li&gt;数据库事务有了解吗？事务的隔离级别？你在项目中使用的隔离级别是什么？（新浪微博）&lt;/li&gt;
&lt;li&gt;SQL优化有什么思路？（新浪微博）&lt;/li&gt;
&lt;li&gt;项目中使用到外键了吗？外键作用？使用外键要注意些什么问题？（新浪微博）&lt;/li&gt;
&lt;li&gt;除了MySQL数据库你还用到哪些数据库？Redis数据库和MySQL数据库的区别？（新浪微博）&lt;/li&gt;
&lt;li&gt;现场出题设计一个数据库表（百度）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java篇&#34;&gt;Java篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类和对象的区别？（百度）&lt;/li&gt;
&lt;li&gt;单例设计模式了解吗？有几种写法？手写一个单例设计模式（百度）&lt;/li&gt;
&lt;li&gt;讲讲&lt;em&gt;static&lt;/em&gt;关键字和&lt;em&gt;final&lt;/em&gt;关键字（百度）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;synchronized&lt;/em&gt;关键字是怎么用的？底层实现有了解吗？还有用过其他的锁吗？（百度）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BIO、NIO、AIO&lt;/em&gt;区别有哪些？项目中有用到吗？&lt;em&gt;Netty&lt;/em&gt;？（百度、新浪微博）&lt;/li&gt;
&lt;li&gt;接口和抽象类的区别？什么时候用接口，什么时候用抽象类？接口可以继承接口吗？（京东数科）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;HashMap&lt;/em&gt;和&lt;em&gt;HashTable&lt;/em&gt;的区别是什么？（京东数科）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ConcurrentHashMap&lt;/em&gt;和&lt;em&gt;HashMap&lt;/em&gt;的区别是什么？&lt;em&gt;ConcurrentHashMap&lt;/em&gt;为什么线程安全？（新浪微博）&lt;/li&gt;
&lt;li&gt;HashMap和HashSet的区别？HashSet是如何检查重复的？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Java&lt;/em&gt;中线程的状态？*join()、yield()*方法是干什么？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Object&lt;/em&gt;类下有哪些方法？（京东数科）&lt;/li&gt;
&lt;li&gt;字符串&amp;quot;&lt;em&gt;123&lt;/em&gt;&amp;quot;转换成整型&lt;em&gt;123&lt;/em&gt;的&lt;em&gt;API&lt;/em&gt;是什么？整型&lt;em&gt;123&lt;/em&gt;转换成字符串“&lt;em&gt;123&lt;/em&gt;”的API又是什么？（京东数科）&lt;/li&gt;
&lt;li&gt;创建线程有几种方式？分别是怎么做的？（京东数科、新浪微博）&lt;/li&gt;
&lt;li&gt;线程池用过吗？如何创建一个线程池？其中各个参数的含义是什么？为什么要用线程池？coreSize？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;synchronized、ReentrantLock&lt;/em&gt;区别？（京东数科）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CountDownLatch&lt;/em&gt;和&lt;em&gt;Semaphore&lt;/em&gt;用过吗？他们的区别是什么？&lt;em&gt;CountDownLatch&lt;/em&gt;应用场景？比如现在要让第5个线程等待前4个线程执行完毕再执行，具体怎么做？（新浪微博）&lt;/li&gt;
&lt;li&gt;使用&lt;em&gt;synchronized&lt;/em&gt;来实现单缓冲区的生产者消费者模型的代码思路？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;JVM&lt;/em&gt;有了解吗？&lt;em&gt;JVM&lt;/em&gt;中参数&lt;code&gt;–Xms&lt;/code&gt;和&lt;code&gt;-Xmx&lt;/code&gt;是什么意思？（新浪微博）&lt;/li&gt;
&lt;li&gt;设计模式有了解过哪些？单例设计模式知道哪几种写法？策略设计模式了解吗？你在项目中用到了哪些设计模式？（京东数科、新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Spring&lt;/em&gt;中依赖注入有几种方式？怎么做的？（京东数科）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Spring&lt;/em&gt;框架中有哪些组件了解吗？分别做什么的？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SpringMVC&lt;/em&gt;的这种&lt;em&gt;MVC&lt;/em&gt;模式了解吗？他的工作原理是什么？用到了哪些设计模式？（京东数科、百度）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SpringMVC&lt;/em&gt;中要接受用户传来的参数要怎么做？&lt;em&gt;REST&lt;/em&gt;的风格呢？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Spring&lt;/em&gt;中&lt;em&gt;bean&lt;/em&gt;的创建过程了解吗？（新浪微博）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SpringBoot&lt;/em&gt;和&lt;em&gt;SpringMVC&lt;/em&gt;的区别和联系是什么？了解&lt;em&gt;SpringBoot&lt;/em&gt;的启动流程吗？&lt;em&gt;SpringBoot&lt;/em&gt;自动配置是如何实现的？（新浪微博）&lt;/li&gt;
&lt;li&gt;权限验证&lt;em&gt;Spring Security&lt;/em&gt;了解吗？ &lt;em&gt;JPA&lt;/em&gt;会用吗？（SAP）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;经验教训&#34;&gt;经验教训&lt;/h2&gt;
&lt;p&gt;​		由于这是我第一次求职的经历，从简历这一步开始就踩了很多的坑，技能描述简略，泛泛而谈，项目描述草率，没有任何一点的包装，就拿去投了很多家公司，基本都石沉大海，在几位学长的指导下修改了简历，又重新投递。我之前确实没有做过什么技术，又不甘愿去做测开，所以也是从这个学期开始才决定做Java后端的开发，很多东西也都是现学，在学技术这期间我不时地后悔大一大二没好好做技术，自己是在还债，恰逢学校的事情又很多，然后整个一个学期压力都蛮大的，我到现在都还清楚地记得等待每一个面试电话时自己心中焦灼的心情。&lt;/p&gt;
&lt;p&gt;​		每一次的面试对我来说都是一次成长，放下心中的浮躁，踏踏实实地做事情。最后感谢&lt;a href=&#34;https://github.com/zjs1224522500&#34;&gt;顺佬&lt;/a&gt;对我Java学习的指导、俊佬对我简历的指导、谢导提供的实习信息及京东对我的肯定&lt;/p&gt;
">实习面经</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Stay Foolish&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;博主&#34;&gt;👨‍💻 博主&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2021.09 - Now  西安交通大学 - 计算机科学与技术 - 硕博连读&lt;/li&gt;
&lt;li&gt;2017.09 - 2021.06 电子科技大学 - 软件工程 - 本科&lt;/li&gt;
&lt;li&gt;2020.03 - 2020.06 京东数字科技 - Java软件开发实习生&lt;/li&gt;
&lt;li&gt;2022.08 - 2022.09 华为终端BG - OpenHarmony - C++软件开发实习生&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;联系我&#34;&gt;📬 联系我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;mailto:Kay_Rick@outlook.com&#34;&gt;Kay_Rick@outlook.com&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kay-rick.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>







</html>